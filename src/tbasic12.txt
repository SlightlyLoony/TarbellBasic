*
*
* TARBELL BASIC SOURCE MODULE #12
* COPYRIGHT (C) 1978 TARBELL ELECTRONICS
* LAST CHANGE ON THIS MODULE MADE 12-21-78.
*
PCLDM	DB	'READING...',8DH
PCSVM	DB	'WRITING...',8DH
*
* RTN. D.59
* OUTPUT LINE DESCRIPTOR
LNDSC	LDA	RUNF	;SEE IF WE ARE RUNNING
	ANA	A
	JZ	LND44	;PRINT COMMAND
	LHLD	LINE	;GET ADDRESS OF CURRENT LINE
	PUSH	H	;SAVE LINE
	LXI	D,0	;CLEAR DE
LNDS1	PUSH	D	;SAVE COUNT
	LHLD	LINE	;CHECK FOR BEGINNING OF SOURCE
	XCHG	
	LHLD	FSRC	;FIRST SOURCE ADDRESS
	CALL	CMP16	;CHECK 'EM OUT
	JZ	LNDS2	;SURE WAS
	LHLD	FRAV	;CHECK FOR DIRECT MODE START
	CALL	CMP16
	JZ	LNDS2
LNDS8	CALL	MBOS	;BACK UP ONE
	POP	D	;RECOVER COUNT
	MOV	A,M	;GET A BYTE
	CPI	85H
	JZ	LNDS1
	CPI	9CH	;CHECK FOR TAB
	JZ	LNDS1
	DCX	D	;CHECK FOR COLON OR BACKSLASH
	CPI	9EH
	JZ	LNDS1	;SURE WAS
	CPI	9BH
	JZ	LNDS1
	CPI	9DH
	JZ	LNDS1	;YUP
	INX	D	;INDEX BACK TO NORMAL
	INX	D	;UPDATE COUNT
	CPI	9FH	;IS IT A STATEMENT NAME
	JNZ	LNDS1	;NO, SO LOOP AND TRY AGAIN
	DCX	D	;CORRECT COUNT
	PUSH	D	;SAVE IT
	INX	H	;CORRECT INDEX
	PUSH	H	;SAVE H
	LXI	H,SPMGE
	CALL	LNOT
	POP	H
	CALL	PRIT	;PRINT THE NAME
LNDS3	POP	H	;GET BACK COUNT
	MOV	A,H	;SEE IF IT'S ZERO
	ORA	L
	JZ	LNDS4	;YUP, SO RETURN
	PUSH	H	;SAVE IT AGAIN
	LXI	H,PLUSM	;PRINT A PLUS SIGN
	CALL	MSGER
	POP	H	;GET BACK COUNT
	LXI	D,TMP9	;CONVERSION SPACE
	CALL	BBCD	;CONVERT BINARY TO BCD
	MVI	A,4	;STORE NUMBER START/STOP
	STA	TMP9-1
	INR	A
	STA	TMP10
	LXI	H,TMP9-1	;ADDRESS
	CALL	PRIT	;PRINT THE NUMBER OUT
LNDS4	POP	H	;RESTORE LINE
	SHLD	LINE
	RET		;DONE
DRAT1	DB	'"'+80H	;QUOTE MESSAGE
LNDS2	LDAX	D	;GET BYTE
	CPI	9FH	;CHECK FOR NAME TAG
	JZ	LNDS8	;SURE IS!
	LXI	H,LNMSG	;GET START MESSAGE
	CALL	LNOT	;DUMP IT
	JMP	LNDS3
*
LNMSG	DB	20H
	DB	'DIRECT MODE ENTR','Y'+80H
SPMGE	DB	0A0H
*
LND44	LXI	H,LND45	;PRINT "COMMAND"
	CALL	MSGER
	RET		;DONE0LT
*
LND45	DB	'ENTR'
	DB	'Y'+80H
*
* INTERPRETER MODULE
* RTN. E.1
* PUSH ITEM ON CONTROL STACK
* IN: HL = ADDRESS OF ITEM TO PUSH
PUSZ	PUSH	H	;SAVE THE REGISTERS
	PUSH	D
	PUSH	B
	PUSH	PSW
	CALL	GTIN	;HOW MANY BYTES IN ITEM?
	MOV	B,D	;DE TO BC
	MOV	C,E
	XCHG		;HL TO DE
	LHLD	PNTR	;GET STACK ADDRESS
	PUSH	H
	PUSH	D
	PUSH	B
	DAD	B
	XCHG
	LHLD	FARY
	CALL	CMP16
	MVI	B,27H
	JC	ERROR
	POP	B
	POP	D
	POP	H
	XCHG		;BACK TO THE RIGHT PLACE
	CALL	MVDN	;MOVE IT IN QUICK LIKE
	XCHG		;DESTINATION TO HL
	DAD	B	;COMPUTE NEW STACK POINTER
	SHLD	PNTR	;SAVE IT
	POP	PSW	;GET ALL THE REGISTERS BACK
	POP	B
	POP	D
	POP	H
	RET		;DONE.
*
* RTN. E.2
* POP ITEM FROM CONTROL STACK
* OUT: HL = ADDRESS OF ITEM POPPED
POPS	PUSH	D	;SAVE REGISTERS
	PUSH	B
	PUSH	PSW
	LHLD	PNTR	;GET STACK ADDRESS
	DCX	H	;GET LAST BYTE OF TOP OF STACK
	MOV	A,M
	CALL	GTIN	;COMPUTE NUMBER OF BYTES IN ITEM
	CALL	SUB16	;COMPUTE NEW ADDRESS
	INX	H
	SHLD	PNTR	;UPDATE POINTER
	POP	PSW	;RESTORE REGISTERS
	POP	B
	POP	D
	RET		;DONE.
* RTN. E.3
* GET ITEM ADDRESS
* IN: HL = ITEM LOCATION
* OUT: BC = ADDRESS OF ITEM
GEIM	MOV	A,M	;GET FIRST BYTE
	CPI	2	;IS IT A LABEL?
	JZ	GEIM1	;YUP
	MOV	C,L	;MOVE HL TO BC
	MOV	B,H
	ANA	A	;CHECK FOR LITERAL
	RZ		;IT WAS
	INX	B	;CORRECT
	RET
GEIM1	INX	H	;GET LABEL NUMBER OUT
	MOV	C,M
	INX	H
	MOV	B,M
	PUSH	D	;SAVE DE
	CALL	DFND	;GET THE POINTER
	MOV	B,H	;MOVE HL TO BC
	MOV	C,L
	POP	D	;RESTORE DE
	RET		;DONE..
* RTN. E.4
* FIND OPERAND
* OUT: HL = ADDRESS OF OPERAND
* CARRY SET IF OPERAND IS A STRING
FNOP	CALL	POPS	;POP ONE OFF CONTROL STACK
FNOPO	MOV	A,M	;GET A BYTE
	CPI	2	;IS THIS A POINTER?
	JZ	FNOP1	;YUP
	ANA	A	;IS THIS A LITERAL?
	JZ	FNOP2	;YUP
	CPI	4	;IS THIS A CONSTANT?
	JZ	FNOP3	;YUP
	CPI	9	;IS IT END MARKER?
	JZ	FNOP	;YUP, SO DIG FOR ANOTHER
	MVI	B,26H	;ERROR
	JMP	ERROR
FNOP1	INX	H	;GET THE POINTER OUT
	MOV	E,M
	INX	H
	MOV	D,M
	XCHG		;PUT IT IN HL
	MOV	A,M	;GET A BYTE
	ANA	A	;IS IT A LITERAL?
	JZ	FNOP2	;YUP
	ANI	3EH	;STRIP OFF SUPERFLUOUS BITS
	CPI	2	;IS IT A NUMBER?
	JZ	FNOP5	;YUP
	CPI	8	;IS IT A STRING ARRAY/VARIABLE?
	JZ	FNOP4	;YUP
	MVI	B,26H	;ERROR
	JMP	ERROR
FNOP2	INX	H	;GET NEXT ADDRESS
	STC		;INDICATE STRING
	RET		;DONE
FNOP3	INX	H	;GET NEXT ADDRESS
	MOV	A,M	;CHECK IF IT'S A NUMBER
	ANI	0EH	;STRIP OFF ID BITS
	CPI	2	;IS IT A NUMBER?
	JNZ	FNOP6	;NOPE
FNOP5	XRA	A	;CLEAR CARRY
	RET		;DONE
FNOP4	INX	H	;GET POINTER ADDRESS
	INX	H
	INX	H
	MOV	E,M	;GET A BYTE
	INX	H
	MOV	D,M	;GET THE OTHER
	XCHG		;TO HL
	STC		;INDICATE STRING
	RET		;DONE
FNOP6	SUI	6	;SET CARRY IF IT'S A STRING
	CMC
	INX	H	;GET POINTER OUT
	MOV	E,M
	INX	H
	MOV	D,M
	XCHG		;TO HL
	RNC		;NOT A STRING
	MOV	E,M	;GET ANOTHER POINTER
	INX	H
	MOV	D,M
	XCHG		;TO HL
	RET		;DONE.
*
* RTN. E.5
* GET OPERANDS FOR OPERATORS
* IN: CARRY SET IF NUMERICS ONLY OK.
* OUT:
* HL = OPERAND 1 ADDRESS
* DE = OPERAND 2 ADDRESS (TOP OF STACK)
* BC = DESTINATION ADDRESS
* CARRY SET IF OPERANDS ARE STRINGS
GOFO	MVI	A,0	;CLEAR A
	RAL		;SHIFT THE CARRY INTO BIT 0
	LXI	B,TMP10	;SET INDEX
	STAX	B	;INITIALIZE THE COUNTER
	CALL	FNOP	;GET AN OPERAND
	LDAX	B	;GET COUNTER
	INR	A	;ADD 2 WITHOUT AFFECTING CARRY
	INR	A
	JNC	GOFOA
	ADI	2
GOFOA	STAX	B	;SAVE COUNTER
	PUSH	H	;GET ANOTHER OPERAND
	CALL	FNOP
	LDAX	B
	INR	A
	INR	A
	JNC	GOFOB
	ADI	2
GOFOB	PUSH	H	;SAVE THE ADDRESS
	CPI	8	;IS IT STRINGS?
	JZ	GOFO2	;YUP
	ORI	1	;SET BIT 0
	CPI	5	;IS IT NUMERICS?
	JZ	GOFO3	;YUP
	MVI	B,24H	;MIXED OPERANDS, NO NO
	JMP	ERROR
GOFO2	STC		;SET CARRY FOR INDICATION OF STRING
GOFO3	LHLD	PNTR	;GET NEXT AVAILABLE STACK ADDRESS
	INX	H	;AFTER ID
	MOV	C,L	;BC=HL
	MOV	B,H
	POP	H	;GET BACK ADDRESSES
	POP	D
	RET		;ALL DONE.
*
* RTN. E.6
* LOGICAL OPERATOR PREPARER
OPR10	STC		;NUMERIC ONLY
	CALL	GOFO	;GET OPERANDS
	PUSH	B	;SAVE DESTINATION
	PUSH	D	;SAVE O2
	CALL	BCDB	;CONVERT TO BINARY
	XTHL		;GET O2
	CALL	BCDB	;CONVERT TO BINARY
	POP	D	;GET BACK BINARY O1
	MOV	C,L	;BC = HL
	MOV	B,H
	POP	H	;GET BACK DESTINATION
	XTHL		;PUT IT ON THE STACK
	PCHL		;RETURN
* RTN. E.7
* LOGICAL OPERATOR ENDER
OPR20	XCHG		;SWAP
	POP	H	;GET RETURN ADDRESS
	XCHG		;SWAP
	CALL	BBCD	;CONVERT TO FLOATING POINT
* RTN. E.8
* NUMERIC FINISHER
OPR30	LHLD	PNTR	;GET STACK ADDRESS
	MVI	M,4	;STUFF A NUMBER INDICATOR
	LXI	D,7	;ADD 7
	DAD	D
	MVI	M,5	;STUFF AN END OF NUMBER INDICATOR
	INX	H	;NEXT AVAILABLE
	SHLD	PNTR	;RESET PNTR
	RET		;ALL DONE.
* RTN. E.9 
* RELATIONAL OPERATOR FINISHER
OPR40	JC	OPR41	;TRUE ANSWER
	XCHG		;HL TO DE
	LXI	H,ZERO0	;GET A ZERO
	LXI	B,6	;NUMBER OF BYTES
	CALL	MVDN	;MOVE IT IN
	JMP	OPR30	;FINISH UP
OPR41	XCHG		;HL TO DE
	LXI	H,NEGA1	;GET A ONE
	LXI	B,6	;NUMBER OF BYTES
	CALL	MVDN	;MOVE IT IN
	JMP	OPR30	;FINISH IT UP
* RTN. E.10
* RELATIONAL OPERATOR PREPARER
OPR50	XRA	A	;CLEAR CARRY
	CALL	GOFO	;GET OPERANDS
	PUSH	B	;SAVE DESTINATION
	JC	OPR51	;LOOKS LIKE STRINGS
	CALL	CMPR	;COMPARE NUMBERS
	POP	H	;GET BACK THE DESTINATION
	RET		;DONE
OPR51	XCHG		;SWAP HL,DE
	CALL	STRNG	;COMPARE STRINGS
	POP	H	;GET BACK DESTINATION
	RET		;DONE
* RTN. E.11
* OR PROCESSOR
OPRA	CALL	OPR10	;GET OPERANDS
	MOV	A,E	;BC OR DE TO HL
	ORA	C
	MOV	L,A
	MOV	A,D
	ORA	B
	MOV	H,A
	JMP	OPR20	;STORE IT
* RTN. E.12
* AND PROCESSOR
OPRB	CALL	OPR10	;GET OPERANDS
	MOV	A,E	;BC AND DE TO HL
	ANA	C
	MOV	L,A
	MOV	A,D
	ANA	B
	MOV	H,A
	JMP	OPR20	;STORE IT
* RTN. E.13
* NOT PROCESSOR
OPRC	CALL	OPR10
	MOV	A,C	;BC NOT DE TO HL
	CMA
	ANA	E
	MOV	L,A
	MOV	A,B
	CMA
	ANA	D
	MOV	H,A
	JMP	OPR20	;STORE IT
* RTN. E.14
* >= PROCESSOR
OPRD	CALL	OPR50	;COMPARE
	CMC		;SET CARRY FOR TRUE
	JMP	OPR40	;STORE
* RTN. E.15
* <= PROCESSOR
OPRE	CALL	OPR50	;COMPARE
	JC	OPR40	;TRUE
	JNZ	OPR40	;NOT TRUE
	STC		;ALSO TRUE
	JMP	OPR40	;STORE IT
* RTN. E.16
* > PROCESSOR
OPRF	CALL	OPR50	;COMPARE
	CMC		;SET CARRY IF TRUE
	JNZ	OPR40	;TRUE
	XRA	A	;CLEAR CARRY
	JMP	OPR40	;NOT TRUE
* RTN. E.17
* < PROCESSOR
OPRG	CALL	OPR50	;COMPARE
	JMP	OPR40	;STORE
* RTN. E.18
* <> PROCESSOR
OPRH	CALL	OPR50	;COMPARE
	STC
	JNZ	OPR40	;STRORE
	CMC
	JMP	OPR40	;STORE
* RTN. E.19
* = PROCESSOR
OPRI	LDA	FNFLG	;CHECK FOR FN MODE
	ANA	A
	RNZ
	LDA	OPFLG	;LOOK FOR A CHANNEL STATEMENT
	CPI	87H	;CHECK IT
	RZ		;IT WAS, SO IGNORE THIS EQUALS
	CALL	OPR50	;COMPARE
	STC
	JZ	OPR40	;STORE
	CMC
	JMP	OPR40	;STORE
* RTN. E.20
* - PROCESSOR
OPRP	STC		;NUMERIC ONLY
	CALL	GOFO	;GET OPERANDS
	CALL	SUBER	;SUBTRACT
	JMP	OPR30	;STORE
* RTN. E.21
* / PROCESSOR
OPRJ	STC		;NUMERIC ONLY
	CALL	GOFO	;GET OPERANDS
	CALL	DIVER	;DIVIDE
	JMP	OPR30	;STORE
* RTN. E.22
* * PROCESSOR
OPRK	STC		;NUMERIC ONLY
	CALL	GOFO	;GET OPERANDS
	CALL	MULER	;MULTIPLY
	JMP	OPR30	;STORE
* RTN. E.23
* POWERS PROCESSOR
OPRL	STC		;NUMERIC ONLY
	CALL	GOFO	;GET OPERANDS
	CALL	PWRS	;Y TO X
	JMP	OPR30	;STORE
* RTN. E.24
* + PROCESSOR
OPRM	XRA	A	;NUMERIC OR ALPHABETIC
	CALL	GOFO	;GET OPERANDS
	JC	OPRM1	;STRINGS
	CALL	ADDER	;ADD
	JMP	OPR30	;STORE
OPRM1	PUSH	H
	PUSH	D	
	CALL	COUNT
	LHLD	PNTR
	MVI	M,0
	INX	H
	DAD	D
	XTHL
	CALL	COUNT
	MOV	B,D
	MOV	C,E
	POP	D
	CALL	MOVE
	XCHG
	DAD	B	
	MVI	M,1
	XTHL	
	CALL	COUNT
	MOV	B,D
	MOV	C,E
	XCHG
	LHLD	PNTR
	INX	H
	XCHG
	CALL	MOVE
	XCHG
	DAD	B
	DCX	H
	MOV	A,M
	ANI	7FH
	MOV	M,A
	POP	H
	INX	H
	SHLD	PNTR
	RET
* RTN. E.25
* UNARY - OPERATOR PROCESSOR
OPRN	CALL	FNOP	;GET OPERAND
	MVI	B,24H	;ERROR CODE JUST IN CASE
	JC	ERROR	;NEGATE A STRING?
	XCHG		;ADDX TO DE
	LHLD	PNTR	;FIND WHERE TO STORE
	INX	H
	CALL	CMP16	;SEE IF THEY ARE EQUAL
	JZ	OPRN1	;YUP
	XCHG		;NOPE
	LXI	B,6	;NUMBER OF BYTES
	CALL	MOVE	;MOVE IT IN
	XCHG		;NEW ADDRESS TO HL
OPRN1	MVI	A,80H	;SET UP TO CHANGE SIGN
	XRA	M
	MOV	M,A
	JMP	OPR30	;STORE
* RTN. E.26
* UNARY NOT PROCESSOR
OPRO	CALL	FNOP	;GET OPERAND
	MVI	B,24H	;ERROR CODE JUST IN CASE
	JC	ERROR	;CAN'T LOGICALLY OPERATE ON A STRING,DUMMY.
	CALL	BCDB	;CONVERT TO BINARY
	MOV	A,H	;INVERT IT
	CMA
	MOV	H,A
	MOV	A,L
	CMA
	MOV	L,A
	XCHG		;TO DE
	LHLD	PNTR	;GET ADDRESS TO STORE TO
	INX	H
	XCHG		;BACK TO HL
	CALL	BBCD	;CONVERT TO BCD
	JMP	OPR30	;STORE
*
NEGA1	DB	82H,0,0,0,0,1	;NEGATIVE ONE
C2767	DB	2,0,0,3,27H,67H	;32767
*
LINK12	LINK	B:TBASIC13
