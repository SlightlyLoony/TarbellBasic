*
*
* TARBELL BASIC SOURCE MODULE #13
* COPYRIGHT (C) 1978 TARBELL ELECTRONICS
* LAST CHANGE ON THIS MODULE MADE 12-17-78.
*
* ASSIGN MEMORY BLOCK
* SQUISHES MEMORY IF IT RUNS OUT
* IN: HL = NUMBER OF BYTES NEEDED
*  DE = BACKPOINTER ADDRESS
*  A = ID BYTE
* OUT: HL = FIRST ASSIGNED ADDRESS
*
AMBL	PUSH	PSW	;SAVE ID
	PUSH	D	;SAVE BACKPOINTER
	PUSH	H	;SAVE NUMBER OF BYTES
	XRA	A	;CLEAR OVERFLOW FLAG
	STA	TMP10+1
AMBL2	XCHG		;NUMBER TO DE
	LHLD	FARY	;GET FIRST USED ADDRESS
	CALL	SUB16	;SUBTRACT
	MVI	B,27H
	JNC	ERROR
	LXI	D,900	;STACK MARGIN
	CALL	SUB16	;SUBTRACT AGAIN
	JNC	ERROR
	XCHG		;TO DE
	LHLD	PNTR	;TOP OF STACK ADDRESS
	CALL	CMP16	;SEE IF WE ARE OUT OF MEMORY
	JNC	AMBL1	;YUP, SO SQUISH
	POP	D	;GET NUMBER OF BYTES
	INX	D	;ADD THREE
	INX	D
	INX	D
	LHLD	FARY	;GET FIRST USED BYTE
	DCX	H	;STORE THE NUMBER OF BYTES
	MOV	M,D
	DCX	H
	MOV	M,E
	CALL	SUB16	;COMPUTE FIRST ADDRESS OF BLOCK
	SHLD	FARY	;UPDATE FARY
	POP	D	;GET BACKPOINTER
	POP	PSW	;GET ID BYTE
	MOV	M,A	;STORE THEM
	INX	H
	MOV	M,E
	INX	H
	MOV	M,D
	INX	H	;GET FIRST ASSIGNED ADDRESS
	RET		;DONE.
AMBL1	LDA	TMP10+1	;CHECK OVERFLOW FLAG
	ANA	A
	MVI	B,27H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;OH,OH, OUT OF MEMORY
	INR	A	;SO SET IT
	STA	TMP10+1
	LHLD	SDIR	;INITIALIZE SQUISH LOOP
	SHLD	TMP9
	SHLD	TMP8
AMBL4	LHLD	TMP8	;TMP8=FARY?
	XCHG
	LHLD	FARY
	CALL	CMP16	;COMPARE
	JZ	AMBL6	;YUP, SO THE LOOP'S DONE
	XCHG		;TMP8 TO HL
	DCX	H	;PULL OUT NUMBER OF BYTES
	MOV	D,M
	DCX	H
	MOV	E,M
	CALL	SUB16	;FIND FIRST BYTE OF BLOCK
	MOV	A,M	;GET ID BYTE
	ANA	A	;IS IT ACTIVE?
	JP	AMBL3	;NOPE
	PUSH	H	;SAVE BLOCK ADDRESS
	LHLD	TMP8	;TMP8=TMP9?
	XCHG
	LHLD	TMP9
	CALL	CMP16
	POP	H	;RESTORE BLOCK ADDRESS
	JNZ	AMBL5	;NOT EQUAL
	SHLD	TMP9	;RESET TO
AMBL3	SHLD	TMP8	;RESET FROM
	JMP	AMBL4	;LOOP FOR ANOTHER BLOCK
AMBL5	XCHG		;COMPUTE NUMBER OF BYTES
	CALL	SUB16
	XCHG		;SWAP 'EM
	SHLD	TMP8	;NEW FROM
	LHLD	TMP9	;GET TO
	CALL	SUB16	;NEW TO
	SHLD	TMP9
	MOV	C,E	;BC=DE
	MOV	B,D
	XCHG		;DE = HL
	LHLD	TMP8	;GET FROM
	CALL	MOVE	;MOVE BLOCK
	LDAX	D	;LOOK FOR STRING ARRAY POINTER BLOCK
	CPI	82H	;CHECK ID BYTE
	JNZ	LOOP1	;IT'S NOT
	PUSH	H	;SAVE 'EM ALL
	PUSH	D
	PUSH	B	;WELL, ALMOST
	XCHG		;HL=DE
	INX	H	;+1
	MOV	E,M
	INX	H
	MOV	D,M	;GET OUT THE BACKPOINTER
	INX	H	;POINT TO FIRST #OF ELEMENTS
	PUSH	H	;SAVE IT
	XCHG		;HL=DE-2
	DCX	H
	DCX	H
	MOV	E,M	;DE=(HL,HL+1)
	INX	H
	MOV	D,M
	POP	H	;RESTORE POINTER, DE=NUMBER OF DIMENSIONS
	DAD	D	;HL=HL+DE*2
	DAD	D
	PUSH	H	;SAVE IT
	MOV	L,C	;BC=(BC-5-DE*2)/2
	MOV	H,B
	CALL	SUB16
	CALL	SUB16
	LXI	D,5
	CALL	SUB16
	MOV	A,H
	ANA	A
	RAR
	MOV	B,A
	MOV	A,L
	RAR
	MOV	C,A
	POP	H	;RESTORE POINTER
LOOP	MOV	E,M
	INX	H
	MOV	D,M	;GET A POINTER OUT
	DCX	H	;GET HL RIGHT
	DCX	D	;DE=DE-2
	DCX	D
	XCHG		;(DE,DE+1)=HL
	MOV	M,E
	INX	H
	MOV	M,D
	XCHG		;GET IT BACK
	INX	H	;HL=HL+2 TO POINT TO NEXT ONE
	INX	H
	DCX	B	;UPDATE ELEMENT COUNTER
	MOV	A,B
	ORA	C	;CHECK FOR BEING DONE
	JNZ	LOOP	;NOPE, MORE TO GO
	POP	B	;RESTORE ALL THE REGISTERS
	POP	D
	POP	H
LOOP1	XCHG		;TO TO HL
	INX	H	;GET BACKPOINTER OUT
	MOV	E,M
	INX	H
	MOV	D,M
	XCHG
	INX	D	;STORE NEW FRONTPOINTER
	MOV	M,E
	INX	H
	MOV	M,D
	JMP	AMBL4	;LOOP FOR ANOTHER BLOCK
AMBL6	LHLD	TMP9	;SET NEW FARY
	SHLD	FARY
	POP	H	;RESTORE HL
	PUSH	H
	JMP	AMBL2	;TRY AGAIN
* RTN. E.28
* ARRAY OPERATOR PROCESSOR
AOOP	LHLD	PNTR	;GET TOP OF STACK
AOOP1	DCX	H	;GET LAST ITEM
	MOV	A,M	;GET BYTE
	CALL	GTIN	;HOW BIG IS IT?
	CALL	SUB16	;MOVE BACK TO IT
	MOV	A,M	;GET BYTE
	CPI	0DH	;IS IT A COMMA?
	JZ	AOOP1	;YUP, SO LOOP AGAIN
	CALL	GTIN	;HOW BIG IS THIS THING?
	CALL	SUB16	;GET THE BEGINNING OF IT
	INX	H
	MOV	A,M	;GET THE ID BYTE
	CPI	2	;IS IT A LABEL?
	MVI	B,10H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;NOPE
	INX	H	;GET THE POINTER OUT
	MOV	E,M
	INX	H
	MOV	D,M
	XCHG		;TO HL
	LDA	OPFLG	;IS THIS A DIMENSION STATEMENT?
	CPI	0A5H	;CHECK
	JZ	AOOP6	;YUP
	MOV	A,M	;GET BYTE
	CPI	0FFH	;CHECK FOR UNFILLED
	MVI	B,28H	;ERROR CODE JUST IN CASE
	JZ	ERROR	;UNDIMENSIONED ARRAY ERROR
	ANI	0CH	;CHECK FOR ARRAY
	MVI	B,10H	;ERROR CODE JUST IN CASE
	JZ	ERROR	;NOT AN ARRAY
	INX	H	;GET NUMBER OF DIMENSIONS OUT
	MOV	E,M
	INX	H
	MOV	D,M
	XCHG
	SHLD	CNVR1	;SAVE IT
	XCHG
	INX	H	;GET POINTER OUT
	MOV	E,M
	INX	H
	MOV	D,M
	XCHG
	SHLD	CNVR3	;SAVE IT
	LXI	H,0	;GET A SIXTEEN BIT 0
	PUSH	H	;STUFF IT UP YOUR STACK
	JMP	AOOP2	;TO MIDDLE OF LOOP
AOOP3	CALL	POPS	;LOOK FOR A COMMA
	MOV	A,M	;GET IT
	CPI	0DH	;IS IT A COMMA?
	MVI	B,10H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;IT WASN'T
	LHLD	CNVR3	;GET POINTER
	MOV	E,M	;PULL OUT NUMBER OF ELEMENTS
	INX	H
	MOV	D,M
	LHLD	CNVR5	;GET OFFSET
	CALL	I6X16	;MULTIPLY
	PUSH	H	;SAVE PRODUCT
AOOP2	CALL	FNOP	;LOOK FOR AN OPERAND
	MVI	B,24H	;ERROR CODE JUST IN CASE
	JC	ERROR	;THE TURKEY USED A STRING FOR A SUBSCRIPT
	CALL	BCDB	;CONVERT TO BINARY
	PUSH	H	;SAVE HL
	LHLD	CNVR3	;GET POINTER
	MOV	E,M	;PULL OUT NUMBER OF ELEMENTS
	INX	H
	MOV	D,M
	INX	H
	SHLD	CNVR3	;UPDATED POINTER
	POP	H	;RESTORE HL
	XCHG		;SWAP 'EM
	DCX	H	;CORRECTION FACTOR
	CALL	CMP16	;CHECK FOR TOO BIG
	INX	H	;UNCORRECTION FACTOR
	MVI	B,29H	;ERROR CODE JUST IN CASE
	XCHG
	JC	ERROR	;TOO BIG A SUBSCRIPT
	POP	D	;GET TRIAL OFFSET BACK
	DAD	D	;ADD IT
	SHLD	CNVR5	;SAVE IT TO OFFSET
	LHLD	CNVR1	;GET DIMENSION COUNT
	DCX	H	;UPDATE COUNT
	SHLD	CNVR1
	MOV	A,H	;IS IT ZERO?
	ORA	L
	JNZ	AOOP3	;NO, SO LOOP FOR ANOTHER DIMENSION
	CALL	POPS	;POP OFF THE LABEL
	INX	H	;GET THE POINTER OUT
	MOV	E,M
	INX	H
	MOV	D,M
	XCHG		;TO HL
	DCX	D	;GET ADDRESS TO SAVE IT TO
	MOV	A,M	;GET THE ID BYTE
	STAX	D	;STUFF IT IN
	XCHG
	INX	H	;GET ADDRESS FOR POINTER 
	INX	H
	INX	H
	MOV	M,E	;STUFF IT IN
	INX	H
	MOV	M,D
	XCHG
	PUSH	D	;SAVE ADDRESS
	MOV	A,M	;GET ID BYTE
	ANI	4	;CHECK FOR STRING/NUMERIC ARRAY
	JNZ	AOOP4	;WASN'T A STRING
	LHLD	CNVR5	;GET OFFSET
	LXI	D,2	;GET OFFSET *2
	CALL	I6X16
	JMP	AOOP5
AOOP4	LHLD	CNVR5	;GET OFFSET
	CALL	FSTML	;MULTIPLY BY SIX
AOOP5	XCHG		;OFFSET TO DE
	LHLD	CNVR3	;GET POINTER
	DAD	D	;ADD
AOOPA	XCHG		;TO DE
	POP	H	;GET ADDRESS ON STACK BACK
	DCX	H
	DCX	H	;STORE ELEMENT POINTER
	MOV	M,D
	DCX	H	
	MOV	M,E
	JMP	OPR30	;NUMERIC FINISHER
AOOP6	PUSH	H	;SAVE POINTER
	MOV	A,M	;GET ID BYTE
	CPI	0FFH	;IS IT AN UNDIMENSIONED ARRAY?
	JZ	AOOP7	;YUP
	INX	H	;GET POINTER
	INX	H
	INX	H
	MOV	E,M
	INX	H
	MOV	D,M
	XCHG
	CALL	KILL	;INACTIVATE THE BLOCK
AOOP7	LHLD	PNTR	;GET TOP OF STACK
	SHLD	CNVR1	;PRESET FLAGS
	SHLD	LLST
	LXI	H,1
	SHLD	CNVR3
	DCX	H
	SHLD	CNVR5
AOOP8	CALL	FNOP	;GET AN OPERAND
	MVI	B,24H	;ERROR CODE JUST IN CASE
	JC	ERROR	;A STRING FOR A SUBSCRIPT?
	CALL	BCDB	;CONVERT TO BINARY
	INX	H	;CORRECTION
	XCHG		;TO DE
	LHLD	LLST	;GET PLACE TO PUT IT
	MOV	M,E	;STUFF IT IN
	INX	H
	MOV	M,D
	INX	H
	SHLD	LLST	;STORE UPDATED INDEX
	LHLD	CNVR3	;GET ELEMENT COUNT
	CALL	I6X16	;MULTIPLY
	SHLD	CNVR3	;STORE NEW ELEMENT COUNT
	LHLD	CNVR5	;INCREMENT DIMENSION
	INX	H
	SHLD	CNVR5	;RESTORE IT
	CALL	POPS	;LOOK FOR COMMA
	MOV	A,M	;GET A BYTE
	CPI	0DH	;IS IT A COMMA?
	JZ	AOOP8	;YES, SO CONTINUE THE LOOP
	INX	H	;GET THE POINTER OUT
	MOV	E,M
	INX	H
	MOV	D,M
	LHLD	STAB	;GET START OF SYMBOL TABLE
	PUSH	H
	LHLD	SDIR	;GET START OF SYMBOL DIRECTORY
	XCHG		;TO DE
	SHLD	TMP10	;SAVE THE POINTER TO FIND
	XCHG		;BACK TO HL
AOOPB	MOV	E,M	;GET OUT TRIAL POINTER
	INX	H
	MOV	D,M
	INX	H
	INX	H
	XTHL		;GET THE TABLE ADDRESS
	PUSH	D	;SAVE POINTER
	CALL	COUNT	;FIND THE END
	DAD	D	;ADD
	POP	D	;GET POINTER BACK
	XTHL		;GET SDIR BACK
	PUSH	H	;SAVE IT
	LHLD	TMP10	;SEE IF WE'VE FOUND IT YET
	CALL	CMP16
	POP	H	;RESTORE SDIR
	JNZ	AOOPB	;NOPE, SO LOOP AGAIN
	POP	H	;GET STRING LOCATION
	DCX	H	;GET LAST CHARACTER
	MOV	A,M
	STA	TMP10	;SAVE IT
	LHLD	CNVR3	;COMPUTE NUMBER OF BYTES TO ASSIGN
	LXI	D,2
	LDA	TMP10	;SEE IF THIS IS A NUMERIC ARRAY
	CPI	'$'+80H	
	JZ	AOOPC	;NOPE
	LXI	D,6	;YUP
AOOPC	CALL	I6X16
	PUSH	H	;SAVE IT
	LHLD	CNVR5
	LXI	D,2
	CALL	I6X16
	POP	D
	DAD	D	;GOT IT
	POP	D	;GET ADDRESS
	INX	D	;GET POINTER ADDRESS
	INX	D
	INX	D
	PUSH	D	;SAVE IT
	LDA	TMP10	;CHECK FOR NUMERIC ARRAY
	CPI	'$'+80H
	JZ	AOOPE
	MVI	A,84H	;NUMERIC ARRAY ID BYTE
	JMP	AOOPF
AOOPE	MVI	A,82H	;ID BYTE
AOOPF	CALL	AMBL	;ASSIGN A BLOCK
	POP	D	;GET POINTER ADDRESS BACK
	XCHG
	MOV	M,E
	INX	H
	MOV	M,D
	PUSH	D	;SAVE IT
	DCX	H	;GET NUMBER OF DIMENSIONS BYTES
	DCX	H
	XCHG		;SWAP
	LHLD	CNVR5	;GET NUMBER OF DIMENSIONS
	XCHG
	MOV	M,D
	DCX	H
	MOV	M,E
	DCX	H	;GET ID BYTE ADDRESS
	LDA	TMP10	;CHECK FOR NUMERIC ARRAY
	CPI	'$'+80H
	JZ	AOOPG
	MVI	M,4
	JMP	AOOPH
AOOPG	MVI	M,48H	;STRING ARRAY ID BYTE
AOOPH	LHLD	CNVR5	;GET NUMBER OF DIMENSIONS
	LXI	D,2
	CALL	I6X16
	MOV	B,H	;NUMBER OF BYTES TO MOVE
	MOV	C,L
	LHLD	CNVR1	;GET NUMBER OF ELEMENTS FLAGS
	POP	D	;TO ADDRESS
	CALL	MOVE	;MOVE 'EM IN, BOYS
	XCHG
	DAD	B	;COMPUTE ADDX FOR STRING POINTER
	PUSH	H	;SAVE HL
	LHLD	CNVR3	;GET NUMBER OF ELEMENTS
	MOV	B,H	;TO BC
	MOV	C,L
	POP	H	;GET HL BACK
	LDA	TMP10	;CHECK FOR NUMERIC ARRAY
	CPI	'$'+80H
	JNZ	AOOPD	;SURE IS
	LXI	D,DUMS	;DUMMY STRING ADDRESS
AOOP9	MOV	M,E	;STUFF IN THE POINTERS
	INX	H
	MOV	M,D
	INX	H
	DCX	B	;UPDATE COUNTE
	MOV	A,B
	ORA	C	;IS BC = 0?
	JNZ	AOOP9	;NO, SO LOOP FOR MORE STORES
	RET		;DONE.
AOOPD	PUSH	B	;SAVE NUMBER OF
	XCHG		;HL TO DE
	LXI	H,ZERO0	;GET A ZERO
	LXI	B,6	;NUMBER OF BYTES
	CALL	MOVE	;MOVE IT IN
	XCHG		;DE BACK TO HL
	DAD	B	;UPDATE IT
	POP	B	;GET NUMBER BACK
	DCX	B	;SEE IF WE ARE DONE
	MOV	A,B
	ORA	C
	JNZ	AOOPD	;NOPE
	RET		;DONE.
	DB	0,0,0
DUMS	DB	080H	;DUMMY STRING 
* RTN. E.29
* 16 BY 16 MULTIPLY
* HL=HL*DE, OVERFLOW GENERATES ERROR 30
I6X16	MOV	B,H	;BC = HL
	MOV	C,L
	PUSH	D	;SAVE DE
	MOV	D,C
	CALL	MULT	;ONE OF THREE
	XCHG		;DE TO HL
	POP	D
	PUSH	D
	MOV	D,B
	CALL	MULT	;SECOND OF THREE
	MOV	A,E	;ADD 'EM UP
	ADD	H
	MOV	H,A
	MVI	B,30H	;ERROR CODE JUST IN CASE
	JC	ERROR	;OVERFLOW
	POP	D	
	MOV	E,C
	CALL	MULT	;THE LAST
	MOV	A,E
	ADD	H
	MOV	H,A
	JC	ERROR	;OVERFLOW
	RET		;DONE
* RTN. E.30
* KILL ASSIGNED BLOCK
* IN: HL POINTS TO DATA START
KILL	DCX	H	;BACK UP THREE
	DCX	H
	DCX	H
	MOV	A,M	;GET ID BYTE
	ANI	7FH	;CLEAR ACTIVE BIT
	MOV	M,A	;STUFF IT BACK
	RET		;DONE.
*
* RTN. E.32
* EVALUATE POLISH EXPRESSION
* IN: HL = BEGINNING OF EXPRESSION
* OUT: HL = BEGINNING OF STACK
*  DE = END OF EXPRESSION 
EVPE	XCHG		;HL TO DE
	XRA	A	;CLEAR FNFLG
	STA	FNFLG
EVPE5	XRA	A	;CLEAR ROCK FLAG
	STA	ROCK
	LHLD	PNTR	;SEE WHERE TO START THE STACK
	PUSH	H	;SAVE IT
	XCHG		;DE BACK TO HL
	INX	H	;GET NEXT BYTE
EVPE7	MOV	A,M	;GET THE BYTE OUT
	PUSH	H	;SAVE ADDRESS
	CPI	0DH	;IS IS A COMMA?
	JZ	EVPE111	;YUP
	PUSH	PSW	;SAVE
	XRA	A	;CLEAR ROCK
	STA	ROCK
	POP	PSW
EVPE111	CPI	9	;IS IT END OF EXPRESSION?
	JZ	EVPE2	;YUP
	CPI	6	;IS IT AN OPERAND?
	JC	EVPE1	;YUP
	CPI	0FH	;IS IT A COMMA OR SEMICOLON?
	JC	EVPE4	;YUP
	CPI	40H	;IS IT A FUNCTION?
	JP	EVPE3	;YUP
	CPI	34H	;IS IT AN ARRAY OPERATOR?
	JZ	EVPE8	;YUP
	CPI	36H	;IS IT A FN OPERATOR?
	JZ	EVPE9	;YUP
	SUI	0FH	;MUST BE A REGULAR OLD OPERATOR
	ADD	A	;DOUBLE IT
	LXI	H,OPRCS	;OPERATOR PROCESSOR JUMP TABLE
	CALL	ADHL	;ADD OFFSET
	MOV	E,M	;GET THE ADDRESS OUT
	INX	H
	MOV	D,M
	LXI	H,EVPE6	;PUSH RETURN ADDRESS
	PUSH	H
	XCHG		;JUMP ADDRESS TO HL
	PCHL		;GO GET IT
EVPE9	CALL	FNPR	;PROCESS FN
	JMP	EVPE6
EVPE8	CALL	AOOP	;PROCESS THE ARRAY OPERATOR
EVPE6	POP	H	;GET ADDRESS OF ITEM PROCESSED
	MOV	A,M	;GET FIRST BYTE
	CALL	GTIN	;HOW BIG IS IT?
	DAD	D	;ADD IT UP
	JMP	EVPE7	;LOOP FOR THE NEXT ONE
EVPE3	SUI	40H	;MAKE FIRST ONE ZERO
	ADD	A	;DOUBLE IT
	LXI	H,FPRCS	;FUNCTION PROCESSOR ADDRESS TABLE
	CALL	ADHL	;ADD IT
	MOV	E,M	;FISH OUT THE ADDRESS
	INX	H
	MOV	D,M
	LXI	H,EVPE6	;PUSH RETURN ADDRESS
	PUSH	H
	XCHG		;ADDRESS TO HL
	PCHL		;GO GET IT
EVPE1	MOV	A,M	;GET ID BYTE
	CPI	2	;IS IT A LABEL?
	JNZ	EVPEP	;NOPE
	LDA	FNFLG	;CHECK FOR FN MODE
	ANA	A
	JNZ	EVPEJ	;FN MODE
EVPEP	CALL	GEIM	;GET OPERAND ADDRESS
	LHLD	PNTR	;GET TOP OF STACK
	MVI	M,2	;START OF LABEL INDICATOR
	INX	H
	MOV	M,C	;STUFF IN THE ADDRESS
	INX	H
	MOV	M,B
	INX	H
	MVI	M,3	;END OF LABEL INDICATOR
	INX	H
	SHLD	PNTR	;UPDATED PNTR
	JMP	EVPE6	;LOOP FOR ANOTHER ONE
EVPE4	LDA	ROCK	;SEE IF IGNORE TIME
	ANA	A
	JNZ	EVPE6	;SURE IS
	CALL	PUSZ	;STUFF IT ONTO THE STACK
	JMP	EVPE6	;LOOP FOR ANOTHER ONE
EVPE2	CALL	PUSZ	;PUSH THE 09 ONTO THE STACK
	POP	D	;GET BACK PARAMETERS
	POP	H
	RET		;DONE.......
*
* OPERATOR PROCESSOR ADDRESS TABLE.
*
OPRCS	DW	OPRQ	;ASSIGNMENT OPERATOR
	DW	OPRA	;OR
	DW	OPRB	;AND
	DW	OPRC	;NOT
	DW	OPRD	;>=
	DW	OPRE	;<=
	DW	OPRF	;>
	DW	OPRG	;<
	DW	OPRH	;<>
	DW	OPRI	;=
	DW	OPRP	;-
	DW	OPRM	;+
	DW	OPRJ	;?
	DW	OPRK	;*
	DW	OPRN	;UNARY -
	DW	OPRO	;UNARY NOT
	DW	OPRL	;POWERS
*
* RTN. E.33
* RUN CONTROLLER
RUN8	LHLD	NPNTR
	SHLD	PNTR
	POP	H	;GET NEXT ADDRESS
	XCHG
	LHLD	ESRC
	CALL	CMP16
	JZ	RUN4	;DONE
	LHLD	SLIN
	CALL	CMP16
	JZ	RUN4A	;DONE
	XCHG		;ADDRESS BACK TO HL
RUN	SHLD	LINE	;UPDATE LINE FLAG
	MVI	A,0FFH	;SET RUN FLAG
	STA	RUNF
RUN1	CALL	CONT	;CHECK FOR CONTROL C PUSHED
	JZ	RUN2	;SURE WAS
	LHLD	PNTR	;SET NPNTR
	SHLD	NPNTR
	LHLD	PNTR	;CHECK FOR OUT OF MEMORY
	XCHG
	LHLD	FARY
	CALL	CMP16	;PNTR SHOULD BE SMALLER
	MVI	B,27H	;ERROR CODE JUST IN CASE
	JC	ERROR	;OOPS, ALL OUT
	LHLD	LINE	;GET CURRENT STATEMENT CODE
RUNA	MOV	A,M	;GET OPCODE
	CPI	9BH	;IS IT AN ELSE?
	JZ	RUNELS	;YUP
	CPI	9FH	;IS IT A STATEMENT NAME?
	JZ	RUNB	;YUP
	CPI	9CH	;IS IT A TAB?
	JZ	RU000	;YUP
	CPI	35H	;IS IT A REMARKS SECTION?
	JZ	RUNC	;YUP
	CPI	86H	;IS IT A REMARKS STATEMENT?
	JZ	RUNC	;YUP
	CPI	0A4H	;IS IT A DEF STATEMENT?
	JZ	RUNG	;YUP
	CPI	9EH	;IS IT A COLON OR BACKSLASH?
	JZ	RU000	;YUP
	CPI	9DH
	JZ	RU000	;YUP
	STA	OPFLG	;SET OPCODE FLAG
	CPI	0A0H	;IS IT A NORMAL STATEMENT?
	JM	RUN6	;NOPE
	INX	H	;CHECK FOR TRAILING EXPRESSION
	MOV	A,M
	CPI	9
	JNZ	RUN7	;NO EXPRESSION FOLLOWING
	CALL	EVPE	;EVALUATE IT
	INX	D	;GET NEXT COMMAND ADDRESS
	PUSH	D	;ONTO THE STACK
	STC		;SET CARRY
RUN9	PUSH	PSW	;SAVE FLAGS
	PUSH	H	;SAVE FIRST STACK ADDRESS
	LHLD	LINE	;GET OPCODE AGAIN
	MOV	A,M
	SUI	0A0H	;SUBTRACT OFFSET
	ADD	A	;DOUBLE IT
	LXI	H,NSPRC	;NORMAL STATEMENT PROCESSOR ADDRESSES
	CALL	ADHL	;ADD IT UP
	MOV	E,M	;GET OUT ADDRESS
	INX	H
	MOV	D,M
	XCHG		;TO HL
	POP	D	;GET BACK STACK ADDRESS
	POP	PSW	;GET BACK FLAGS
	LXI	B,RUN8	;PUSH RETURN ADDRESS
	PUSH	B
	PCHL		;JUMP TO PROCESSOR
RUNELS	LXI	B,1	;MOVE UP ONE LOGICAL LINE
	INX	H	;UPDATE LINE
	SHLD	LINE
	CALL	LILO1	;DO IT
	LHLD	LINE	;RUN
	JMP	RUN
RUN7	XRA	A	;CLEAR CARRY
	PUSH	H	;SAVE ADDRESS
	JMP	RUN9	;PROCESS IT
RUN6	SUI	80H	;SUBTRACT OFFSET
	ADD	A	;DOUBLE IT
	LXI	H,OSPRC	;ODDBALL STATEMENT PROCESSOR ADDRESSES
	CALL	ADHL	;ADD IT
	MOV	E,M	;GET THE ADDRESS OUT
	INX	H
	MOV	D,M
	LXI	H,RUN8	;PUSH RETURN ADDRESS
	PUSH	H
	XCHG		;ADDRESS TO HL
	PCHL		;GO GET IT
RUN4	XRA	A	;CLEAR RUNF
	LHLD	ESRC
	SHLD	LINEA
RUN4TES	STA	RUNF
	INR	A	;SET COMMAND MODE
	STA	CMND
	JMP	RSTRT	;BACK TO EXECUTIVE
RUNB	MVI	A,5	;SET UP TO GET STATEMENT ADDRESS
	CALL	ADHL	;ADD IT UP
	JMP	RUN	;DO IT
RUN2	CALL	CRLF	;CARRIAGE RETURN
	LHLD	LINE	;SAVE LINE POINTER
	SHLD	LINEA
	LXI	H,RNMSG	;PRINT BREAK MESSAGE
	CALL	MSGER	;DUMP IT
	CALL	LNDSC	;PRINT LINE DESCRIPTOR
	XRA	A
	JMP	RUN4TES	;BACK TO EXECUTIVE
RUNC	INX	H	;GET NEXT ADDRESS
	MOV	A,M	;GET A BYTE
	DCR	A	;CHECK FOR 01 CODE
	JNZ	RUNC	;NOPE
	INX	H	;FOUND IT
	PUSH	H	;ONTO THE STACK
	JMP	RUN8	;DO NEXT STATEMENT
PLUSM	DB	'+'+80H
RNMSG	DB	'BREAK IN',0A0H
* RTN. E.34
* ASSIGNMENT OPERATOR PROCESSOR
OPRQ	CALL	FNOP	;GET SOURCE
	PUSH	H	;SAVE ADDRESS
	PUSH	PSW	;SAVE FLAGS
	XRA	A	;CLEAR CHANGE STRING FLAG
	STA	TMP7
	CALL	POPS	;GET DESTINATION
	MOV	A,M	;GET ID BYTE
	CPI	2	;IS IT A LABEL?
	JZ	OPRQ1	;YUP
	CPI	4	;IS IT A NUMBER BLOCK?
	JZ	OPRQ6	;YUP
	ANA	A	;IS IT A LITERAL?
	MVI	B,31H
	JZ	ERROR	;YUP
	MVI	B,10H
	JMP	ERROR	;NOPE
OPRQ1	INX	H	;GET POINTER OUT
	MOV	E,M
	INX	H
	MOV	D,M
	MOV	A,D	;CHECK FOR 0 POINTER
	ORA	E
	MVI	B,18H	;ERROR CODE JUST IN CASE
	JZ	ERROR	;SURE WAS
	XCHG		;TO HL
	MOV	A,M	;GET ID BYTE
	ANI	0EH	;STRIP OFF ID BITS
	CPI	2	;IS IT A NUMBER?
	JNZ	OPRQ2	;NOPE
	POP	PSW	;GET FLAGS BACK
	JNC	OPRQ4	;NOT STRING INTO NUMBER
	POP	D	;GET SOURCE
	PUSH	D	;SAVE IT AGAIN
	LDAX	D	;GET A BYTE
	CPI	80H	;NULL STRING?
	MVI	B,32H
	JNZ	INPTA	;STRING INTO NUMBER
	LDA	OPFLG	;ARE WE IN AN INPUT INSTRUCTION?
	CPI	0A7H
	MVI	B,32H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;NOPE
	XCHG
	POP	B
	LXI	H,ZERO0
	LXI	B,6
	CALL	MOVE
	XCHG
	SHLD	SCFLG
	RET		;DONE
OPRQ4	XCHG		;LOCATION TO DE
	POP	H	;GET SOURCE ADDRESS
	LXI	B,6	;NUMBER OF BYTES
	CALL	MOVE	;MOVE IT IN
	XCHG		;STORE ADDRESS FOR "FOR"
	SHLD	SCFLG
	RET		;DONE.
OPRQ2	CPI	8	;IS IT A STRING POINTER
	JNZ	OPRQ3	;NOPE
	POP	PSW	;GET FLAGS BACK
	MVI	B,33H	;ERROR CODE
	CNC	OQ00	;NUMBER INTO A STRING
	INX	H	;GET POINTER LOCATION
	INX	H
	INX	H
	MOV	E,M	;GET POINTER OUT
	INX	H
	MOV	D,M
OPRQ8	XCHG		;SWAP
	PUSH	D	;SAVE LOCATION OF POINTER
	CALL	KILL	;ELIMINATE THE BLOCK
	POP	H	;GET BACK POINTER LOCATION
OPRQ5	XTHL		;SWAP IT WITH STRING LOCATION
	LDA	TMP7	;CHECK FOR CHANGE STRING FLAG
	ANA	A
	JNZ	OQ01	;YUP
OQ02	CALL	COUNT	;HOW MANY LITTLE INDIANS?
	XTHL		;POINTER LOCATION TO HL
	XCHG		;SWAP
	DCX	D	;GET IT RIGHT
	MVI	A,81H	;ID BYTE
	PUSH	D	;SAVE POINTER LOCATION
	PUSH	H	;SAVE NUMBER OF BYTES
	CALL	AMBL	;ASSIGN MEMORY SPACE
	POP	B	;NUMBER TO TRANSFER
	XCHG		;DESTINATION TO DE
	POP	H	;POINTER LOCATION
	XTHL		;SWAP IT WITH SOURCE
	CALL	MOVE	;MOVE THE STRING IN
	POP	H	;GET POINTER LOCATION
	MOV	M,E	;STUFF IT IN
	INX	H
	MOV	M,D
	RET		;DONE.
OPRQ3	MOV	A,M	;GET BYTE AGAIN
	INR	A
	MVI	B,10H	;ERROR CODE JUST IN CASE
	JNZ	ERROR
	POP	PSW	;GET FLAGS
	JNC	OPRQ4	;NUMERIC TRANSFER
	MVI	M,8	;STORE ID BYTE
	INX	H	;GET POINTER LOCATION
	INX	H
	INX	H
	INX	H
	JMP	OPRQ5	;PROCESS
OPRQ6	INX	H	;GET NEXT BYTE
	MOV	A,M
	CPI	4	;NUMERIC ARRAY?
	JNZ	OPRQ7	;NOPE
	POP	PSW	;GET BACK FLAGS
	MVI	B,32H
	JC	INPTA	;STRING INTO NUMERIC
	INX	H	;GET POINTER OUT
	MOV	E,M
	INX	H
	MOV	D,M
	JMP	OPRQ4+1	;PROCESS
OPRQ7	POP	PSW	;GET FLAGS
	MVI	B,33H
	CNC	OQ00	;NUMBER INTO STRING
	INX	H	;GET POINTER OUT
	MOV	E,M
	INX	H
	MOV	D,M
	XCHG		;TO HL
	MOV	E,M	;GET STRING POINTER OUT
	INX	H
	MOV	D,M
	JMP	OPRQ8
OQ00	LDA	OPFLG	;CHECK FOR INPUT STATEMENT
	CPI	0A7H
	STA	TMP7
	RZ		;IT WAS
	CPI	0A0H
	RZ		;IF CLOAD, IT'S OK
	JMP	ERROR	;IT WASN'T
OQ01	LHLD	LLST
	SHLD	PNTR
	LHLD	TMP11+2
	JMP	OQ02
* RTN. E.35
* PRINT PROCESSOR
SPRA	MVI	A,0	;SET TERMINAL MODE
	STA	CSST
	STA	CATV
SPRAZ	XCHG		;TO HL
	PUSH	H	;SAVE ADDRESS
	JNC	SPRA8	;SKIP IF NO EXPRESSION
SPRA1	MOV	A,M	;GET STACK BYTE
	CPI	9	;END?
	JZ	SPRA6	;YUP
	CPI	0DH	;COMMA?
	JZ	SPRA5	;YUP
	CPI	0EH	;SEMICOLON?
	JZ	SPRA2	;YUP
	LDA	BFLAG	;IS IT BINARY MODE
	ANA	A
	JNZ	SPRAB2	;YUP
	MOV	A,M
	CPI	6	;IS IT SPECIAL OPERAND?
	JZ	SP000	;YUP
SPRAB2	PUSH	H	;SAVE THE ADDRESS
	LDA	BFLAG	;CHECK FOR BINARY OUTPUT
	ANA	A
	JNZ	SPRAB1	;SURE IS
	CALL	FNOPO	;GET OPERAND
	JC	SPRAA	;STRING
	XCHG		;TO DE
	LHLD	PNTR	;PLACE TO PUT STRING
	LDA	CSST	;CHECK FOR CASSETTE MODE
	ANA	A
	JNZ	SPRACAS	;SURE IS
	MVI	M,20H	;STORE A SPACE
	INX	H	;NEXT ADDRESS
	XCHG		;BACK TO NORMAL
	CALL	NMST	;CONVERT NUMBER TO STRING
	XCHG		;TO HL
	MVI	M,0A0H	;STORE END SPACE
SPRA3	LHLD	PNTR	;PLACE TO OUTPUT FROM
SPRAA	CALL	LNOT	;SEND IT OUT
SPRA4	POP	H	;GET ADDRESS BACK
SPRA2	MOV	A,M	;GET BYTE BACK
	CALL	GTIN	;HOW BIG IS IT?
	DAD	D	;ADD IT UP
	JMP	SPRA1	;LOOP FOR MORE ON THE STACK
SPRAB1	CALL	FNOPO	;GET THE OPERAND
	JC	SPRAB3	;IF STRING
	MVI	B,6	;NUMBER OF BYTES
SPRAB11	MOV	A,M	;GET A BYTE
	PUSH	H	;SAVE
	PUSH	B
	CALL	OBPORT	;SEND IT
	POP	B
	POP	H	;RESTORE
	DCR	B	;DONE?
	INX	H	;UPDATE INDEX
	JNZ	SPRAB11	;NOPE
	JMP	SPRA4	;YUP
SPRAB3	PUSH	H	;SAVE ADDRESS
	XRA	A	;SEND A	0
	CALL	OBPORT	;INDICATING A STRING
	POP	H	;RESTORE ADDRESS
SPRAB31	MOV	A,M	;GET A CHARACTER
	PUSH	H	;SAVE ADDRESS
	CALL	OBPORT
	POP	H
	MOV	A,M
	INX	H	;UPDATE INDEX
	ANA	A	;DONE?
	JP	SPRAB31	;NOPE
	JMP	SPRA4
SPRA5	PUSH	H	;SAVE ADDRESS
	LDA	BFLAG	;CHECK FOR BINARY OUTPUT
	ANA	A
	JNZ	SPRA4	;YUP, SO IGNORE
	LDA	CSST	;CHECK FOR CASSETTE MODE
	ANA	A
	JNZ	Q0000	;SURE IS
	LDA	POSIT	;PRINT HEAD POSITION
	MOV	L,A	;TO HL
	MVI	H,0
	MVI	E,14	;SET UP
	CALL	DIV	;TO DIVIDE BY 14 FOR COLUMNS
	MVI	A,14
	SUB	H	;SUBTRACT REMAINDER
	JZ	SPRA4	;NO MOVE AT ALL
	LHLD	PNTR	;PLACE FOR SPACE STRING
SPRAB	MVI	M,20H	;STUFF A SPACE
	INX	H	;UPDATE POSITION
	DCR	A	;UPDATE COUNT
	JNZ	SPRAB	;MORE TO DUMP
	DCX	H	;SET UPPER BIT ON LAST ONE
	MVI	M,0A0H
	JMP	SPRA3	;DUMP IT
SPRA6	DCX	H	;LOOK AT LAST BYTE
	MOV	A,M
	CPI	0DH	;COMMA?
	JZ	SPRA7	;YUP
	CPI	0EH	;SEMICOLON?
	JZ	SPRA7	;YUP
	LDA	BFLAG	;CHECK FORBINARY MODE
	ANA	A
	JNZ	SPRA7	;YUP
SPRA8	LXI	H,SPRMS	;SEND A CARRIAGE RETURN
	CALL	LNOT
SPRA7	POP	H	;GET BACK FIRST ADDRESS
	SHLD	PNTR	;CLEAR THE STACK
	LDA	BFLAG	;BINARY MODE?
	ANA	A
	JNZ	SPRABF	;YUP
	LDA	CSST	;CASSETTE MODE?
	ANA	A
	RZ		;NOPE
	XRA	A	;CLEAR OUT ANY CASSETTE MODE
	STA	CSST
	RET		;DONE.
SPRABF	XRA	A	;CLEAR AND STOP MOTORS
	STA	BFLAG
	RET		;DONE
SPRACAS	XCHG		;CONVERT TO STRING
	CALL	NMST
	XCHG
	DCX	H
	MOV	A,M	;SET LAST BIT
	ORI	80H
	MOV	M,A
	JMP	SPRA3	;DONE
*
SPRMS	DB	8DH	;CARRIAGE RETURN MESSAGE
*
LINK13	LINK	B:TBASIC14
