*
*
* TARBELL BASIC SOURCE MODULE #5
* COPYRIGHT (C) 1978, 1979 TARBELL ELECTRONICS
* LAST CHANGE MADE ON THIS MODULE 12-19-78.
*
* RTN. B.11
* FIXED POINT MULTIPLY
* (HL) TIMES (DE), PRODUCT IN WORK1
FMUL	PUSH	D	;SAVE REGISTERS
	PUSH	H
	XCHG
	LXI	D,TEMP2	;MOVE OPERANDS INTO TEMP1 AND TEMP2
	LXI	B,6
	CALL	MVDN
	POP	H	;GET OTHER ADDRESS BACK
	PUSH	H
	LXI	D,TEMP1
	CALL	MVDN
	LXI	H,WORK1+11	; GET ADDRESS TO STORE PRODUCT
	LDA	TEMP1+5	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+5
	MOV	B,A
	CALL	MUL2	;GET PARTIAL PRODUCT
	MOV	M,C	;STORE IN WORK1
	DCX	H	;UPDATE
	MOV	M,B	;STORE
	DCX	H
	LDA	TEMP1+4	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+4
	MOV	B,A
	CALL	MUL2	;GET PARTIAL PRODUCT
	MOV	M,C	;STORE IN WORK1
	DCX	H
	MOV	M,B
	DCX	H
	LDA	TEMP1+3	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+3
	MOV	B,A
	CALL	MUL2	;GET PARTIAL PRODUCT
	MOV	M,C	;STORE IN WORK1
	DCX	H
	MOV	M,B
	DCX	H
	LDA	TEMP1+2	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+2
	MOV	B,A
	CALL	MUL2	;GET PARTIAL PRODUCT
	MOV	M,C	;STORE IN WORK1
	DCX	H
	MOV	M,B
	INX	H	;GET READY FOR ADDING
	INX	H
	LDA	TEMP1+3	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+2
	MOV	B,A
	CALL	FMUL1	;ADD PARTIAL PRODUCT
	LDA	TEMP1+2	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+3
	MOV	B,A
	CALL	FMUL1	;ADD PARTIAL PRODUCT
	INX	H	;GET NEXT COLUMN
	LDA	TEMP1+2	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+4	
	MOV	B,A
	CALL	FMUL1	;ADD PARTIAL PRODUCT
	LDA	TEMP1+4	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+2
	MOV	B,A
	CALL	FMUL1	;ADD PARTIAL PRODUCT
	INX	H	;GET NEXT COLUMN
	LDA	TEMP1+2	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+5
	MOV	B,A
	CALL	FMUL1	;ADD PARTIAL PRODUCT
	LDA	TEMP1+3	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+4
	MOV	B,A
	CALL	FMUL1	;ADD PARTIAL PRODUCT
	LDA	TEMP1+4	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+3
	MOV	B,A
	CALL	FMUL1	;ADD PARTIAL PRODUCT
	LDA	TEMP1+5	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+2	
	MOV	B,A
	CALL	FMUL1	;ADD PARTIAL PRODUCT
	INX	H	;GET NEXT COLUMN
	LDA	TEMP1+3	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+5
	MOV	B,A
	CALL	FMUL1	;ADD PARTIAL PRODUCT
	LDA	TEMP1+5	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+3
	MOV	B,A
	CALL	FMUL1
	INX	H	;GET LAST COLUMN
	LDA	TEMP1+4	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+5
	MOV	B,A
	CALL	FMUL1
	LDA	TEMP1+5	;GET MULTIPLIERS
	MOV	C,A
	LDA	TEMP2+4
	MOV	B,A
	CALL	FMUL1
	POP	H	;RESTORE REGISTERS
	POP	D
	RET		;DONE!!!
FMUL1	CALL	MUL2	;GET PRODUCT
	PUSH	H	;SAVE INDEX
	MOV	A,C	;ADD TO WORK1
	ADD	M
	DAA		;BCD ADJUST
	MOV	M,A	;STUFF IT BACK
FMUL3	DCX	H	;GET NEXT BYTE ADDRESS
	MOV	A,B	;ADD IT
	ADC	M
	DAA		;BCD ADJUST
	MOV	M,A	;STUFF IT BACK
	JNC	FMUL2	;DONE
	MVI	B,0	;CLEAR B
	JMP	FMUL3	;LOOP TO PROPAGATE CARRY
FMUL2	POP	H	;RESTORE INDEX
	RET		;GO BACK
* RTN. B.12
* FLOATING POINT MULTIPLY
* (HL) TIMES (DE) TO (BC)
FLML	PUSH	B	;SAVE DESTINATION
	CALL	FMUL	;MULTIPLY MANTISSA'S
	LDA	WORK1+4	;GET BYTE TO SEE WHERE TO ADD ROUNDING
	ANI	0F0H	;STRIP OFF UPPER DIGIT
	MVI	A,50H	;GET ROUNDING NUMBER
	JNZ	FLML1	;OK, WE GOT THE RIGHT ONE
	MVI	A,05H	;REPLACE WITH THE LOWER 5
FLML1	PUSH	H	;SAVE REGISTER
	LXI	H,WORK1+8	;GET READY TO ADD ROUNDING
FLML2	ADD	M	;ADD A BYTE
	DAA		;BCD ADJUST
	MOV	M,A	;PUT IT BACK
	DCX	H	;SET UP FOR NEXT BYTE
	MVI	A,1	;SET UP FOR CARRY PROPAGATE
	JC	FLML2	;LOOP IF CARRY UP
	LXI	H,WORK1	;SET UP TO CLEAR TOP OF BUFFER
	MVI	A,4	;NUMBER OF BYTES
	CALL	ZERO	;CLEAR IT
	POP	H	;RESTORE REGISTER
	PUSH	D	;SAVE LOCATION
	LXI	D,WORK1	;GET LOCATION OF WORK1 TO DE
	CALL	NORM	;NORMALIZE WORK1
	POP	H	;GET LOCATION BACK
	PUSH	D	;SAVE MANTISSA LOCATION
	MOV	D,M	;GET SIGNS AND EXPONENTS TO DE
	INX	H
	MOV	E,M
	XRA	A	;CLEAR A
	STA	MERR	;CLEAR THE ERROR FLAG
	CALL	EXAD	;ADD THE EXPONENTS
	LXI	D,1	;SET UP TO CORRECT NORMALIZATION
	CALL	EXAD	;CORRECTION
	POP	D	;GET BACK MANTISSA LOCATION
	LDA	TEMP1	;GET SIGNS BYTE
	LXI	H,TEMP2	;GET ADDRESS OF THE OTHER
	XRA	M	;COMPUTE SIGN OF RESULT
	ANI	80H	;STRIP OFF ALL BUT SIGN BIT
	ORI	03H	;PUT IN ID BITS
	MOV	H,A	;SAVE IT
	MOV	A,B	;GET EXPONENT SIGN
	ANI	40H	;STRIP ALL BUT EXPONENT SIGN
	ORA	H	;PUT IN OTHER BITS
	POP	H	;GET DESTINATION
	MOV	M,A	;STORE SIGNS BYTE
	INX	H
	MOV	M,C	;STORE EXPONENT BYTE
	INX	H
	XCHG		;SWAP ADDRESSES FOR MOVE
	LXI	B,4	;NUMBER OF BYTES TO MOVE
	CALL	MVDN	;MOVE THE MANTISSA IN
	XCHG		;SEE IF IT'S A FLOATING ZERO
	MOV	A,M
	DCX	H
	DCX	H
	ANA	A
	RNZ		;NOPE
	XCHG
	LXI	H,ZERO0
	CALL	MOVE
	RET		;DONE
* RTN. B.51
* SQUARE ROOT EXTRACTION
* SQR(HL) TO (DE)
SQUR	PUSH	D	;SAVE DESTINATION
	PUSH	H	;SAVE N
	MOV	A,M
	ANA	A	;SEE IF THIS IS A MINUS NUMBER
	MVI	B,39H	;JUST IN CASE
	JM	ERROR	;CAN'T HAVE A SQUARE ROOT OF A MINUS NUMBER, ROCK!
	LXI	D,TMP5	;SET FIRST GUESS TO N
	LXI	B,6	;NUMBER OF BYTES
	CALL	MOVE	;MOVE IT IN, BOYS
	LXI	D,ZERO0	;CHECK FOR INPUT=0
	CALL	CMPR
	JZ	SQUR2	;SURE IS
SQUR1	LXI	H,TMP5	;TMP6=TMP5*TMP5
	LXI	B,TMP6
	MOV	E,L
	MOV	D,H
	CALL	MULER
	LXI	B,TMP6	;COMPUTE DELTA Y
	POP	H	;GET N
	PUSH	H	;SAVE IT AGAIN
	MOV	E,C
	MOV	D,B
	CALL	SUBER
	LXI	B,TMP6	;COMPUTE DELTA X BY DELTA Y/SLOPE
	MOV	L,C
	MOV	H,B
	LXI	D,TWO22
	CALL	DIVER
	LXI	B,TMP6
	MOV	L,C
	MOV	H,B
	LXI	D,TMP5	
	CALL	DIVER	;DIVIDE BY GUESS
	CALL	TRMN1	;CHECK FOR DONENESS
	JC	SQUR2	;AHHH, DONE TO A T
	LXI	B,TMP5
	LXI	D,TMP6	;ADD DELTA X FOR NEXT GUESS
	MOV	L,C
	MOV	H,B
	CALL	ADDER
	JMP	SQUR1	;TRY AGAIN
SQUR2	POP	H	;CLEAN UP THE STACK
	POP	D	;GET THE DESTINATION
	LXI	H,TMP5	;GET THE SOURCE
	LXI	B,6	;NUMBER OF BYTES
	MOV	A,M	;CLEAR ANY MINUS SIGN
	ANI	7FH
	MOV	M,A
	CALL	MOVE	;MOVE IT IN
	RET		;ALL DONE!
* RTN. B.13
* UNPACK PACKED BCD
* HL = SOURCE ADDRESS
* DE = DESTINATION ADDRESS
* B  = NUMBER OF SOURCE BYTES TO UNPACK
UNPK	MOV	A,M	;GET A PACKED BYTE
	MOV	C,A	;SAVE IT IN C
	RLC		;GET UPPER DIGIT TO BOTTOM
	RLC
	RLC
	RLC
	ANI	0FH	;STRIP OFF UPPER DIGIT
	STAX	D	;STORE TO DESTINATION
	INX	D	;UPDATE INDEX
	MOV	A,C	;GET PACKED BYTE AGAIN
	ANI	0FH	;STRIP OFF UPPER DIGIT
	STAX	D	;STORE TO DESTINATION
	INX	D	;UPDATE INDEXES
	INX	H
	DCR	B	;CHECK BYTES COUNTER
	JNZ	UNPK	;LOOP FOR MORE BYTES TO UNPACK
	RET		;ALL DONE
* RTN. B.14
* POWERS OF TWO GENERATOR
* ASSUMES NUMBER IN WORK 2+6 THROUGH WORK 2+11
* POWERS OF TWO TO WORK 1+0 THROUGH WORK 2+5
PWER	MVI	B,18	;INITIALIZE BYTE COUNTER
	LXI	H,WORK2+11	;INITIALIZE SOURCE COUNTER
	LXI	D,WORK2+5	;INITIALIZE DESTINATION COUNTER
	XRA	A	;CLEAR CARRY
PWER1	MOV	A,M	;GET A BYTE
	ADC	A	;DOUBLE IT, WITH CARRY
	DAA		;BCD ADJUST
	STAX	D	;STORE IT TO DESTINATION
	DCX	H	;UPDATE INDEXES
	DCX	D
	DCR	B	;CHECK BYTES COUNTER
	JNZ	PWER1	;LOOP FOR MORE ADDING TO DO
	RET		;DONE
* RTN. B.15
* DIVIDE TEST AND SUBTRACT
* HL = FIRST DIGIT OF TEST NUMBER
* DE = FIRST DIGIT OF DIVIDEND
*  C = DIGIT OF QUOTIENT SO FAR
* QFLAG = NUMBER OF DIVISOR DIGITS + 1
* SIGN FLAG IS SET ON EXIT IF NO SUBTRACT WAS PERFORMED
TSTR	PUSH	D	;SAVE DIVIDEND INDEX
	LDA	QFLAG	;GET NUMBER OF BYTES TO TEST
	DCR	A	;CORRECT FOR LAST ADDRESS OFFSET
	MOV	B,A	;PUT IT IN B
TSTR1	LDAX	D	;GET A DIVIDEND BYTE
	SUB	M	;COMPARE WITH DIVISOR POWER
	JM	TSTR4	;JUMP IF DIVIDEND SMALLER
	JNZ	TSTR6	;JUMP IF DIVIDEND LARGER
	INX	D	;UPDATE INDEXES
	INX	H
	DCR	B	;TEST BYTES COUNTER
	JNZ	TSTR1	;LOOP FOR MORE TESTING
TSTR7	LDA	QFLAG	;OK, NUMBER FITS, SO SUBTRACT IT
	MOV	B,A	;PUT NUMBER OF BYTES TO SUBTRACT IN B
	XRA	A	;CLEAR CARRY FLAG
TSTR2	DCX	H	;UPDATE INDEXES
	DCX	D
	LDAX	D	;GET DIVIDEND BYTE
	SBB	M	;SUBTRACT POWER OF DIVISOR
	JP	TSTR3	;JUMP IF NO BORROW
	ADI	10	;CORRECT FOR DECIMAL
TSTR3	STAX	D	;STORE RESULT
	DCR	B	;CHECK BYTES COUNTER
	JNZ	TSTR2	;LOOP FOR MORE BYTES TO SUBTRACT
TSTR4	POP	D	;RESTORE DIVIDEND INDEX
	RET		;DONE
TSTR6	MOV	A,L	;ADD OFFSET TO INDEXES
	ADD	B
	MOV	L,A	;PUT IT BACK
	JNC	TSTR5	;NO CARRY
	INR	H	;PROPAGATE CARRY
TSTR5	MOV	A,E	;AND THE OTHER ONE
	ADD	B
	MOV	E,A
	JNC	TSTR7
	INR	D
	JMP	TSTR7
* RTN. B.16
* DIVIDE MANTISSAS FOR FLOATING POINT DIVIDE
* ASSUMES:
* WORK4 HAS POWERS OF TWO OF DIVISOR
* WORK3 HAS UNPACKED DIVIDEND IN +1 THROUGH +8
* QUOTIENT WILL BE IN WORK5 ON EXIT, +0 WILL BE
* NONZERO, QFLAG WILL BE ZERO IF FIRST DIGIT
* OF QUOTIENT WAS ZERO
DIV1A	MVI	A,0FFH	;SET A NONZERO
	STA	ZFRST	;SET ZFRST NONZERO
	LXI	D,WORK3	;GET FIRST ADDRESS OF DIVIDEND
	XRA	A	;CLEAR A AND SET ZERO FLAG
	LXI	H,WORK5	;GET ADDRESS OF FIRST QUOTIENT DIGIT
DIV10	PUSH	H	;SAVE REGISTERS
	PUSH	PSW
	MVI	C,0	;SET QUOTIENT DIGIT TO 0
	LXI	H,WORK4+2	;GET X8 ADDRESS
	CALL	TSTR	;CHECK IT
	JM	DIV11	;JUMP IF IT DIDN'T FIT
	MVI	A,8	;MOVE BIT INTO C IF IT DID FIT
	ORA	C
	MOV	C,A
DIV11	LXI	H,WORK4+14	;GET X4 ADDRESS
	CALL	TSTR	;CHECK IT
	JM	DIV12	;JUMP IF IT DIDN'T FIT
	MVI	A,4	;MOVE BIT INTO C IF IT DID FIT
	ORA	C
	MOV	C,A
DIV12	LXI	H,WORK4+26	;GET X2 ADDRESS
	CALL	TSTR	;CHECK IT
	JM	DIV13	;JUMP IF IT DIDN'T FIT
	MVI	A,2	;MOVE BIT INTO C IF IT DID FIT
	ORA	C
	MOV	C,A
DIV13	LXI	H,WORK4+38	;GET X1 ADDRESS
	CALL	TSTR	;CHECK IT
	JM	DIV14	;JUMP IF IT DIDN'T FIT
	MVI	A,1	;MOVE BIT INTO C IF IT DID FIT
	ORA	C
	MOV	C,A
DIV14	INX	D	;UPDATE DIVIDEND INDEX
	POP	PSW	;RESTORE REGISTER
	POP	H
	JZ	DIV15	;JUMP IF NO SIGNIFICANT DIGITS YET
DIV16	MOV	M,C	;STORE QUOTIENT DIGIT
	INR	A	;INCREMENT SIGNIFICANT DIGIT COUNTER
	INX	H	;INCREMENT QUOTIENT INDEX
	CPI	9	;CHECK TO SEE IF WE ARE DONE
	JNZ	DIV10	;NOPE, SO LOOP FOR MORE
	RET		;DONE
DIV15	DCR	C	;CHECK FOR C = 0
	INR	C	;RESTORE VALUE
	JNZ	DIV16	;NOPE, WASN'T 0, SO STORE IT
	STA	ZFRST	;OOPS, GOT AN INSIGNIFICANT 0
	JMP	DIV10	;LOOP FOR NEXT DIGIT
* RTN. B.17
* FP DIVIDE
* (HL)/(DE) TO (BC)
DIV2A	PUSH	B	;SAVE PARAMETERS
	PUSH	H
	PUSH	D
	INX	D	;CHECK FOR DIVIDE BY ZERO
	INX	D
	LDAX	D	;GET THE MSD OF MANTISSA
	ANA	A	;SET FLAGS
	JZ	DERR	;YUP, SURE WAS ZERO
	MVI	A,10	;SET UP NUMBER OF DIGITS FLAG
	STA	QFLAG
	XRA	A	;CLEAR SOME BYTES
	STA	MERR	;CLEAR ERROR FLAG
	STA	WORK2+6
	STA	WORK2+7
	MVI	A,18	;ZERO OUT 18 BYTES
	PUSH	H	;SAVE HL
	LXI	H,WORK3
	CALL	ZERO
	POP	H	;RESTORE HL
	LXI	D,WORK3+1	;GET ADDRESS FOR UNPACKED DIVIDEND
	MVI	B,4	;NUMBER OF BYTES
	INX	H	;GET MANTISSA ADDRESS
	INX	H
	MOV	A,M	;GET THE MSD
	ANA	A	;SET FLAGS
	JNZ	DIV2G	;JUMP IF DIVIDEND IS NOT ZERO
	POP	H	;CLEAN UP STACK
	POP	H
	POP	H	;GET DESTINATION ADDRESS
	MVI	M,3	;STORE FLOATING POINT BITS
	MVI	A,5	;NUMBER OF BYTES
	INX	H	;GET EXPONENT LOCATION
	CALL	ZERO	;ZERO IS STORED
	RET		;DONE....
DIV2G	CALL	UNPK	;UNPACK IT
	XRA	A	;CLEAR OUT THE TRAILING BYTE
	STAX	D
	POP	H	;GET DIVISOR ADDRESS
	PUSH	H	;SAVE IT AGAIN
	INX	H	;GET MANTISSA ADDRESS
	INX	H
	LXI	D,WORK2+8	;GET ADDRESS TO STORE IT
	LXI	B,4	;NUMBER OF BYTES TO MOVE
	CALL	MVDN	;MOVE IT
	CALL	PWER	;COMPUTE X2,X4,X8
	LXI	H,WORK1	;SET UP TO UNPACK POWERS OF TWO OF DIVISOR
	LXI	D,WORK4-1
	MVI	B,24	;NUMBER OF BYTES TO UNPACK
	CALL	UNPK	;UNPACK IT
	CALL	DIV1A	;DIVIDE THE MANTISSAS
	POP	H	;GET LOCATIONS AGAIN
	POP	D
	PUSH	D	;SAVE THEM
	PUSH	H
	MOV	B,M	;GET SIGNS AND EXPONENTS
	INX	H
	MOV	C,M
	XCHG
	MOV	D,M
	INX	H
	MOV	E,M
	MVI	A,40H	;CHANGE EXPONENT SIGN
	XRA	B
	MOV	B,A	;PUT IT BACK
	CALL	EXAD	;ADD EXPONENTS
	LDA	ZFRST	;CHECK TO SEE IF THERE WAS A 0 FIRST
	ANA	A	;SET FLAGS
	JNZ	DIV22	;NOPE, SO SKIP THE EXPONENT OFFSET
	LXI	D,4001H	;SET UP A -1 EXPONENT
	CALL	EXAD	;ADD IN THE OFFSET
DIV22	POP	H	;GET LOCATIONS BACK
	POP	D
	LDAX	D	;GET MANTISSA SIGN
	XRA	M
	ANI	80H	;STRIP OFF THE SIGN
	PUSH	PSW
	MOV	A,B	;GET COMPUTED SIGN
	ANI	7FH	;STRIP OFF ALL BUT SIGN
	ORI	3	;SET IN FLOATING POINT BITS
	MOV	B,A	;PUT IT BACK
	POP	PSW
	ORA	B	;PUT THE TWO TOGETHER
	POP	H	;GET DESTINATION
	MOV	M,A	;STORE SIGNS BYTE
	INX	H	;UPDATE INDEX
	MOV	M,C	;STORE EXPONENT
	INX	H	;GET MANTISSA LOCATION
	XCHG		;SET UP FOR PACK
	XRA	A	;SET UP FOR ROUNDING
	STA	WORK5-1	;CLEAR EXTRA DIGIT
	MVI	A,5	;ROUNDING CONSTANT
	LXI	H,WORK5+8	;GET ADDRESS OF LSD+1
	ANA	A	;CLEAR CARRY
DIV2B	ADC	M	;ADD A BYTE
	CPI	10	;CHECK FOR OVERFLOW
	JM	DIV2C	;SKIP CORRECTION IF NO OVERFLOW
	SBI	10	;OFFSET
DIV2C	CMC		;ADJUST CARRY
	MOV	M,A	;STORE THE RESULT
	MVI	A,0	;CLEAR A
	DCX	H	;UPDATE INDEX
	JC	DIV2B	;LOOP FOR MORE CARRY PROPAGATE
	LXI	H,WORK5-1	;SET UP SOURCE ADDRESS
	MOV	A,M	;GET THE BYTE
	ANA	A	;CHECK FOR ZERO
	JNZ	DIV2D	;YUP, IT'S ZERO, SO DON'T CORRECT
	INX	H	;CORRECT FOR REAL FIRST DIGIT
DIV2D	MVI	C,4	;NUMBER OF BYTES TO PACK
	CALL	PACK	;PACK THEM
	RET
* RTN. B.18
* PACK BCD DIGITS
* HL = SOURCE
* DE = DESTINATION
*  C = NUMBER OF BYTES TO PACK
PACK	MOV	A,M	;GET A BYTE
	RLC		;SHIFT INTO UPPER HALF
	RLC
	RLC
	RLC
	INX	H	;UPDATE INDEX
	ORA	M	;OR IN THE LOWER DIGIT
	STAX	D	;STORE IT TO DESTINATION
	INX	H	;UPDATE INDEXES
	INX	D
	DCR	C	;CHECK BYTES COUNTER
	JNZ	PACK	;LOOP IF MORE TO DO
	RET		;DONE
DERR	MVI	A,4	;SET ERROR FLAG
	STA	MERR
	POP	D	;CLEAN UP STACK
	POP	H
	POP	B
	RET		;ERROR RETURN
* RTN. B.19
* INTEGER ADD AND SUBTRACT
* (HL)+-(DE)=(BC)
ISUB	PUSH	B	;SUBTRACT ENTRANCE
	PUSH	H	;SAVE REGISTERS
	XCHG		;SET UP TO MOVE SUBTRACTED VALUE
	LXI	D,TEMP1	;GET DESTINATION ADDRESS
	LXI	B,6	;NUMBER OF BYTES
	CALL	MVDN	;MOVE IT
	MVI	A,80H	;MASK MANTISSA SIGN BIT
	XCHG		;PUT THE ADDRESS IN HL
	XRA	M	;CHANGE THE SIGN BIT
	MOV	M,A	;PUT IT BACK
	POP	D	;RESTORE REGISTERS
	POP	B	
IADD	XRA	A	;CLEAR A
	STA	ASFLG	;CLEAR FLAGS
	STA	MERR
	PUSH	B	;SAVE DESTINATION
	PUSH	H	;SAVE ONE SOURCE
	LXI	H,WORK1	;SET UP TO CLEAR WORKING REGISTERS
	MVI	A,24	;NUMBER OF BYTES TO CLEAR
	CALL	ZERO	;CLEAR THEM
	POP	H	;RESTORE THE SOURCE
	LDAX	D	;GET A SIGNS BYTE
	XRA	M	;GET BITS DIFFERENT
	ANI	80H	;MASK OUT ALL BUT MANTISSA SIGN
	JZ	IADD1+2	;JUMP IF BOTH SIGNS ARE THE SAME
	MOV	A,M	;GET SIGNS BYTE FROM (HL)
	ANI	80H	;STRIP OFF SIGN BIT
	JNZ	IADD2	;JUMP IF (HL) IS MINUS
	XCHG		;SWAP
IADD2	PUSH	D	;SAVE LOCATIONS
	PUSH	H
	LXI	D,WORK1	;GET ADDRESS TO MOVE MINUS NUMBER TO
	LXI	B,6	;NUMBER OF BYTES
	CALL	MVDN	;MOVE IT
	PUSH	D	;SAVE ADDRESS
	XCHG		;ADDRESS TO HL
	INX	H	;GET MANTISSA LOCATION
	MVI	C,5	;NUMBER OF BYTES TO COMPLEMENT
	CALL	CMPL	;GET 10'S COMPLEMENT
	POP	H	;GET BACK THE ADDRESS
	XTHL		;PUT CORRECT NUMBER ON THE STACK
	MVI	A,0FFH	;SET ASFLAG TO INDICATE A SUBTRACT
	JC	IADD1	;DON'T INDICATE SUBTRACT IF 'TWAS A ZERO
	STA	ASFLG
IADD1	POP	H	;GET LOCATIONS 
	POP	D
	PUSH	D	;SAVE THEM AGAIN
	PUSH	H
	INX	H	;GET MANTISSA LOCATIONS
	INX	D
	LXI	B,WORK2+1	;GET LOCATION TO STORE RESULT
	MVI	A,5	;NUMBER OF BYTES
	CALL	FXAD	;ADD THE MANTISSAS
	POP	H	;CLEAN UP STACK
	POP	H	;GET REFERENCE SIGN
	XRA	M	;CHANGE THE SIGN, IF NECCESARY
	POP	H	;GET LOCATION FOR RESULT OF ADDITION
	MOV	M,A	;STORE SIGNS BYTE
	INX	H	;GET MANTISSA LOCATION
	XCHG		;SET UP FOR MOVE
	LXI	H,WORK2+1
	LXI	B,5	;NUMBER OF BYTES
	CALL	MVDN	;MOVE IT
	LDA	WORK2	;GET ANY OVERFLOW
	ANA	A	;SET FLAGS
	RZ		;NO OVERFLOW
	STA	MERR	;SET OVERFLOW BIT
	RET		;DONE
* RTN. B.20
* INTEGER MULTIPLY
* (HL)*(DE)=(BC)
IMUL	LDAX	D	;GET SIGNS BYTES
	XRA	M	;GET DIFFERENT BITS
	ORI	2	;SET ID BITS
	STAX	B	;STORE TO RESULT LOCATION
	INX	B	;GET MANTISSA STORE
	PUSH	B	;SAVE DESTINATION
	INX	D	;GET MANTISSA LOCATIONS
	INX	H
	XRA	A	;CLEAR A
	STA	MERR	;CLEAR ERROR FLAG
	PUSH	D	;SAVE MANTISSA LOCATIONS
	PUSH	H
	DCX	H	;GET ADDRESSES FOR FIRST MULTIPLY
	DCX	D
	CALL	FMUL	;MULTIPLY
	POP	H	;GET MANTISSA LOCATIONS BACK
	POP	D
	LDAX	D	;CHECK FOR NONZERO BYTES IN UPPER
	ORA	M
	JZ	IMUL1	;BOTH ZERO, SO NO MULTIPLY NEEDED
	XRA	M	;SEE IF HL WAS THE NONZERO ONE
	JNZ	IMUL2	;JUMP IF HL WAS ZERO
	XCHG		;MAKE HL THE ZERO ONE
IMUL2	MVI	B,4	;NUMBER OF BYTES TO CHECK
IMUL4	MOV	A,M	;GET A BYTE
	ANA	A	;SET FLAGS
	JNZ	IMUL3	;JUMP IF GUARANTEED OVERFLOW
	INX	H	;UPDATE INDEX
	DCR	B	;CHECK BYTES COUNTER
	JNZ	IMUL4	;LOOP FOR MORE BYTES TO CHECK
	MOV	B,M	;GET A BYTE TO MULTIPLY
	XCHG
	MOV	C,M	;GET ANOTHER BYTE
	CALL	MUL2	;MULTIPLY THEM
	LXI	H,WORK1+7	;GET ADDRESS TO ADD TO
	MOV	A,M	;GET A BYTE
	ADD	C	;ADD
	DAA		;BCD ADJUST
	MOV	M,A	;STICK IT BACK
	DCX	H	;GET ADDRESS FOR NEXT BYTE
	MOV	A,M	;GET IT
	ADC	B	;ADD
	DAA		;BCD ADJUST
	MOV	M,A	;STICK IT BACK
	DCX	H	;CHECK BYTES FOR ALL ZEROS
	ORA	M
	DCX	H
	ORA	M
	DCX	H
	ORA	M
	JZ	IMUL1	;JUMP IF ALL ZEROS (NO OVERFLOW)
IMUL3	MVI	A,1	;SET THE OVERFLOW BIT
	STA	MERR
IMUL1	POP	D	;GET DESTINATION ADDRESS
	LXI	H,WORK1+7	;GET SOURCE
	LXI	B,5	;NUMBER OF BYTES
	CALL	MVDN	;MOVE IT
	MVI	B,3	;CHECK FOR OVERFLOW
	XRA	A
IMUL8	DCX	H	;UPDATE INDEX
	ORA	M	;SET BITS
	DCR	B	;UPDATE COUNTER
	JNZ	IMUL8	;MORE BYTES TO CHECK
	ANA	A	;CHECK FOR OVERFLOW
	RZ		;IT'S OK
	MVI	A,1	;STORE OVERFLOW INDICATION
	STA	MERR
	RET		;DONE
* RTN. B.21
* INTEGER DIVIDE
* (HL)/(DE)=(BC)
IDIV	PUSH	B	;SAVE REGISTERS
	PUSH	D	
	PUSH	H
	LDAX	D	;COMPUTE NEW SIGN BYTE
	XRA	M	;GET DIFFERENT BITS
	ORI	2	;SET ID BITS
	STAX	B	;STORE TO RESULT LOCATION
	MVI	A,11	;SET UP QFLAG
	STA	QFLAG
	MVI	B,5	;GET NUMBER OF MANTISSA BYTES
	XRA	A	;CLEAR A
	XCHG		;ADDRESS TO HL
IDIV1	INX	H	;UPDATE INDEX
	ORA	M	;SEE IT BYTE IS ZERO
	JNZ	IDIV2	;JUMP IF NOT ZERO
	DCR	B	;CHECK BYTES COUNTER
	JNZ	IDIV1	;LOOP FOR MORE BYTES TO CHECK
	POP	H	;CLEAN UP STACK
	POP	H
	POP	H
	MVI	A,4	;SET ERROR FLAG FOR DIVIDED BY ZERO
	STA	MERR
	RET		;ERROR EXIT
IDIV2	XRA	A	;CLEAR A
	STA	MERR	;CLEAR ERROR FLAG
	STA	WORK2+6	;CLEAR BYTES
	MVI	A,18	;CLEAR OUT QUOTIENT REGISTER
	LXI	H,WORK3
	CALL	ZERO
	POP	H	;GET DIVIDEND ADDRESS
	LXI	D,WORK3+1	;GET DESTINATION ADDRESS
	MVI	B,5	;NUMBER OF BYTES TO UNPACK
	INX	H	;GET MANTISSA ADDRESS
	CALL	UNPK	;UNPACK
	POP	H	;GET DIVISOR ADDRESS
	INX	H	;GET MANTISSA ADDRESS
	LXI	D,WORK2+7	;GET ADDRESS TO MOVE IT TO
	LXI	B,5	;NUMBER OF BYTES TO MOVE
	CALL	MVDN	;MOVE IT IN
	CALL	PWER	;GENERATE POWERS OF TWO OF DIVISOR
	LXI	H,WORK1	;SET UP TO UNPACK INTO WORK4
	LXI	D,WORK4
	MVI	B,24
	CALL	UNPK	;UNPACK IT
	LXI	D,WORK4+38	;SET UP LOOP TO FIND MAGNITUDE OF QUOTIENT
	LXI	H,WORK5	;QUOTIENT FIRST DIGIT
	MVI	C,0	;0 TO DIGIT COUNTER
IDIV3	LDAX	D	;GET A BYTE
	ANA	A	;SET FLAGS
	JNZ	IDIV4	;AH, FOUND A SIGNIFICANT DIGIT AT LAST
	MVI	M,0	;STORE A ZERO IN QUOTIENT
	INX	D	;UPDATE INDEXES
	INX	H
	INR	C
	JMP	IDIV3	;LOOP TO CHECK NEXT DIGIT
IDIV4	PUSH	H	;SAVE QUOTIENT INDEX
	MOV	L,C	;SET UP TO MOVE POWERS BACK
	MVI	H,0
	PUSH	B	;SAVE COUNT
	LXI	D,WORK4	;POWERS ADDRESS
	DAD	D	;ADD TO GET OFFSET
	LXI	B,50	;NUMBER OF BYTES
	CALL	MVDN	;MOVE BACK
	LXI	H,WORK4+50	;SET UP TO CLEAR BYTES MOVED UP
	POP	B	;GET COUNT BACK
	MOV	B,C	;SAVE IT IN B
IDIV5	DCX	H	;UPDATE INDEX
	DCR	C	;CHECK BYTES COUNTER
	JM	IDIV6	;JUMP OUT OF LOOP WHEN DONE
	MVI	M,0	;CLEAR A BYTE
	JMP	IDIV5	;LOOP BACK
IDIV6	POP	H	;GET BACK QUOTIENT INDEX
	MOV	A,B	;COMPUTE NEW QUOTIENT INDEX
	ADD	B
	MOV	E,A
	MVI	D,0
	CALL	SUB16
	MVI	A,10
	CALL	ADHL
	LXI	D,WORK3	;GET DIVIDEND ADDRESS
	XRA	A	;CLEAR A
IDIV7	PUSH	H	;SAVE REGISTERS FOR DIVIDE LOOP
	PUSH	PSW
	MVI	C,0	;CLEAR QUOTIENT DIGIT
	LXI	H,WORK4	;GET X8 ADDRESS
	CALL	TSTR	;SEE IF IT WILL FIT
	JM	IDIV8	;NOPE
	MOV	A,C	;OR IN AN 8
	ORI	8
	MOV	C,A
IDIV8	LXI	H,WORK4+12	;GET X4 ADDRESS
	CALL	TSTR	;SEE IF IT WILL FIT
	JM	IDIV9	;NOPE
	MOV	A,C	;OR IN A 4
	ORI	4
	MOV	C,A
IDIV9	LXI	H,WORK4+24	;GET X2 ADDRESS
	CALL	TSTR	;SEE IF IT WILL FIT
	JM	IDIVA	;NOPE
	MOV	A,C	;OR IN A 2
	ORI	2
	MOV	C,A
IDIVA	LXI	H,WORK4+36	;GET X1 ADDRESS
	CALL	TSTR	;SEE IF IT WILL FIT
	JM	IDIVB	;NOPE
	MOV	A,C	;OR IN A 1
	ORI	1
	MOV	C,A
IDIVB	POP	PSW	;RESTORE REGISTERS
	POP	H
	MOV	M,C	;STORE THE QUOTIENT DIGIT
	INX	D	;UPDATE INDEXES
	INX	H
	INR	A	;UPDATE DIGIT COUNTER
	CPI	11	;ARE WE DONE??
	JNZ	IDIV7	;NO, SO LOOP FOR MORE DIGITS
	POP	D	;GET DESTINATION
	INX	D	;CORRECT FOR MANTISSA LOCATION
	LXI	H,WORK5	;GET SOURCE
	MVI	C,5	;NUMBER OF BYTES
	CALL	PACK	;PACK THE RESULT
	RET		;DONE!!
*
LINK05	LINK	A:TBASIC6
