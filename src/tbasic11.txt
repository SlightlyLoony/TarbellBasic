*
*
* TARBELL BASIC SOURCE MODULE #11
* COPYRIGHT (C) 1978 TARBELL ELECTRONICS
* LAST CHANGE ON THIS MODULE MADE 12-19-78.
*
* RTN. D.40
* UNDO POLISH STRING AND PRINT IT
* IN: HL=LAST ADDRESS OF POLISH STRING (09 CODE)
UPOS	PUSH	H	;SAVE ADDRESS
	LHLD	FARY	;SET UP UNPOLISH STRING ADDRESS
	XCHG
	LDA	RURD	;IS RUN READY?
	ANA	A
	JZ	UPOO1	;NOPE
	LHLD	PNTR	;YUP, SO USE SPACE AFTER STACK
	JMP	UPOO2	;SKIP
UPOO1	LHLD	SLIN	;SET UP STACK ADDRESS
UPOO2	MVI	B,0	;STACK COUNT TO 0
	DCX	D	;STORE END FLAG
	MVI	A,9
	STAX	D
UPOS1	XTHL		;GET POLISH STRING ADDRESS
UPOS3	DCX	H	;GET THE ONE BEFORE IT
	MOV	A,M	;AYE, AYE, SIR
	PUSH	D	;SAVE NEW STRING ADDRESS
	CALL	GTIN	;GET THE INCREMENT
	CALL	SUB16	;FIND THE BEGINNING OF THIS TOKEN
	INX	H	
	POP	D	;RESTORE NEW STRING ADDRESS
	MOV	A,M	;GET FIRST CHARACTER
	CPI	9	;IS IT THE END YET?
	JZ	UPOS2	;YUP
	CPI	6	;IS IT A LABEL, LITERAL, OR CONSTANT?
	JC	UPOS4	;YUP
	CPI	0EH	;IS IT A SEMICOLON?
	JZ	UPOSW	;YUP
	CPI	0DH	;IS IT A COMMA?
	JZ	UPOSW	;YUP
	XTHL		;MUST BE AN OPERATOR OR FUNCTION
	MOV	C,A	;STICK THE CHARACTER IN C
	CPI	40H	;IS IT A FUNCTION?
	JP	UPOSM	;YUP
	CPI	34H	;IS IT ARRAY OR FN OPERATOR?
	JP	UPOSN	;YUP
	CPI	20H	;IS IT BIGGER THAN AN OPERATOR?
	JP	DMS10	;YUP, SO NO NEED TO CHECK PRECEDENCE
	CPI	0FH	;IS IT AN OPERATOR?
	JM	DMS10	;NOPE, SO NO NEED TO CHECK PRECEDENCE
	LDAX	D	;GET BYTE FROM UNPOLISH STRING
	CPI	20H	;CHECK FOR OTHER THAN OPERATOR
	JNC	DMS48	;NOT AN OPERATOR
	DCR	A	;CHECK PRECEDENC
	CMP	C	;COMPARE
	JP	DMS11	;OOPS, NEED A PAREN OR TWO
DMS48	INR	B	;CHECK FOR EMPTY STACK
	DCR	B
	JZ	UPOS5	;SURE IS
DMS10	DCX	H	;GET TOP OF STACK
	MOV	A,M
	CPI	20H	;CHECK FOR PAREN ON STACK
	INX	H	;SET STACK BACK
	JZ	UPOS5	;NO NEED TO CHECK FURTHER
	DCR	A	;SET UP FOR COMPARE
	CMP	C	;CHECK FOR STACK HAVING PRECEDENCE
	JM	UPOS5	;STACK'S OK
DMS11	MVI	M,20H	;STORE CODE FOR "(" ON STACK
	INX	H	;UPDATE COUNTERS
	INR	B
	DCX	D	;STICK A ")" ON OUTPUT
	MVI	A,21H
	STAX	D
UPOS5	MOV	M,C	;STORE OPERATOR ON STACK
	INX	H
	INR	B	;UPDATED THE COUNTERS
	JMP	UPOS1	;LOOP FOR ANOTHER TOKEN
UPOSW	DCX	D	;NEXT BYTE OF UNPOLISH STRING
	STAX	D	;STORE THE COMMA OR SEMICOLON
	XTHL
	DCX	H
	MOV	A,M
	INX	H
	CPI	3BH
	JNZ	UP02
	DCX	H
	DCR	B
UP02	XTHL
	JMP	UPOS3	;CONTINUE PROCESSING
UPOSM	MOV	M,A	;STUFF IT ON THE STACK
	INX	H
	MVI	M,20H	;STUFF A '(' ON
	INX	H
	INR	B
	INR	B
	CPI	49H	;CHECK FOR MULTI-ARGUMENT FUNCTIONS
	JZ	UP00
	CPI	66H	;IS IT DO(X,X)?
	JZ	UP00	;YUP
	CPI	5EH	;IS IT CALL(X,X)?
	JZ	UP00	;SURE IS
	CPI	50H
	JZ	UP00
	CPI	4CH
	JZ	UP01
	CPI	5CH	;CHECK FOR A MATCH
	JZ	UP01	;SURE WAS
UPOSO	DCX	D	;STICK A ')' ON
	MVI	A,21H
	STAX	D
	JMP	UPOS1	;LOOP FOR ANOTHER ONE
UP10	XTHL
	DCX	H
	MOV	A,M
	INX	H
	XTHL
	CPI	0DH
	JZ	UPOS1
	DCX	H
	DCR	B
	JMP	UPOS6
UPOSN	MOV	M,A	;ON THE STACK
	INX	H
	INR	B
	JMP	UPOSO
UP01	MVI	M,3BH
	INX	H
	INR	B
UP00	MVI	M,3BH
	INX	H
	INR	B
	JMP	UPOSO
UPOSP	XTHL
	DCX	H
	MOV	A,M	;GET NEXT TOKEN
	INX	H
	XTHL
	INX	H	;UNPOP ARRAY OPERATOR
	INR	B
	CPI	0DH	;COMMA?
	JZ	UPOS1	;YUP
	CPI	0EH	;SEMICOLON?
	JZ	UPOS1	;YUP
	DCX	H	;POP ONE
	DCR	B
	DCX	D	;MOVE ON A'('
	MVI	A,20H
	STAX	D
	JMP	UPOS1	;AND ANOTHER ONE
UPOS4	PUSH	B	;SAVE REGISTERS
	PUSH	D
	MOV	A,M	;GET A BYTE
	CALL	GTIN	;GET INCREMENT
	XTHL		;GET STRING ADDRESS
	CALL	SUB16	;COMPUTE THE NEW ONE
	XCHG		;STICK IT IN YOUR DE
	MOV	C,L	;BC = HL
	MOV	B,H
	POP	H	;GET SOURCE ADDRESS BACK
	CALL	MOVE	;MOVE IT IN
	POP	B	;GET BACK THE COUNTER
	XTHL		;GET THE STACK RIGHT
UPOS6	INR	B	;CHECK FOR EMPTY STACK
	DCR	B	
	JZ	UPOS1	;SURE IS, SO LOOP FOR ANOTHER TOKEN
	DCX	H	;GET ONE OFF STACK
	DCR	B
	MOV	A,M
	INX	H
	INR	B
	CPI	3BH
	JZ	UP10
	DCX	H
	DCR	B
	CPI	34H	;IS IT ARRAY?
	JZ	UPOSP	;YUP
	CPI	36H	;IS IT FN?
	JZ	UPOSP	;YUP
	DCX	D	;MAKE ROOM ON STRING
	STAX	D	;STUFF IT IN
	CPI	40H	;CHECK FOR FUNCTION
	JP	UPOS6	;LOOP FOR ANOTHER ONE OFF STACK
	CPI	20H	;IS IT "("?
	JZ	UPOS6	;YUP
	CPI	1DH	;CHECK FOR UNARYS
	JZ	UPOS6
	CPI	1EH
	JZ	UPOS6
	JMP	UPOS1	;OK, WE GOT ONE
UPOS2	POP	H	;GET BACK STACK TO NORMAL
	XCHG		;TO HL
UPOS7	PUSH	H	;SAVE STRING ADDRESS
	CALL	PRIT	;PRINT THIS TOKEN
	POP	H
	MOV	A,M	;GET INCREMENT FOR THIS TOKEN
	CALL	GTIN
	DAD	D	;ADD IT
	MOV	A,M	;GET NEXT BYTE
	CPI	9	;IS IT THE END FLAG?
	JNZ	UPOS7	;NOPE
	RET		;DONE.
LOTB	DB	','+80H
	DB	';'+80H
	DB	'='+80H
* RTN. D.41
* PRINT INTERNAL FORM
* HL = ADDRESS OF TOKEN TO PRINT
PRIT	MOV	A,M	;GET A BYTE
	CPI	34H	;IS IT AN ARRAY OPERATOR?
	RZ		;YUP
	CPI	36H	;IS IT A FUNCTION OPERATOR?
	RZ		;YUP
	CPI	0A0H	;CHECK FOR NORMAL STATEMENT
	JC	PRIT8	;NOPE
	LXI	H,NOTBL	;ADDRESS OF NORMAL STATEMENT TABLE
	SUI	0A0H	;SUBTRACT OFFSET
	JMP	PRITP	;DUMP IT OUT
PRIT8	CPI	80H	;CHECK FOR AN ODDBALL STATEMENT
	JC	PRIT7	;NOPE
	LXI	H,ODTBL	;ADDRESS OF ODDBALL STATEMENT TABLE
	SUI	80H	;SUBTRACT OFFSET
	CPI	8	;CHECK FOR ON..GOSUB
	JNZ	PRITP	;NOPE
	XRA	A	;YUP
PRITP	CALL	PRIT2	;DUMP IT
	LXI	H,DRAT	;SEND A SPACE OUT
	CALL	LNOT
	RET
PRIT7	CPI	40H	;CHECK FOR AN INTRINSIC FUNCTION
	JC	PRIT1	;NOPE
	LXI	H,FUNT	;ADDRESS OF FUNCTION TABLE
	SUI	40H	;DUMP IT OUT
	JMP	PRIT2
PRIT1	CPI	2FH	;CHECK FOR AN INTERMEDIARY
	JC	PRIT3	;NOPE
	LXI	H,INTBL	;ADDRESS OF INTERMEDIARY TABLE
	SUI	2FH	;SUBTRACT OFFSET
	JMP	PRIT2
PRIT3	CPI	10H	;CHECK FOR NORMAL OPERATOR
	JC	PRIT4	;NOPE
	CPI	10H	;CHECK FOR WORD OPERATORS
	JZ	PRITW
	CPI	11H
	JZ	PRITW
	CPI	12H
	JZ	PRITW
	CPI	1EH
	JZ	PRITW
	LXI	H,OTBL	;OPERATOR TABLE ADDRESS
	SUI	10H	;SUBTRACT OFFSET
	JMP	PRIT2
PRIT4	CPI	0DH	;CHECK FOR LOW OPERATORS
	JC	PRIT5	;NOPE
	LXI	H,LOTB	;LOW OPERATORS TABLE ADDRESS
	SUI	0DH	;SUBTRACT OFFSET
	JMP	PRIT2	;DO IT
PRIT5	ANA	A	;IS IT A STRING START?
	JNZ	PRIT6	;NOPE
	INX	H	;GET FIRST CHARACTER
	PUSH	H	;SAVE ADDRESS
	LXI	H,DRAT1	;QUOTE MESSAGE
	CALL	LNOT	;SEND IT OUT
	POP	H	;GET BACK THE ADDRESS
	CALL	LNOT	;SEND IT OUT
	LXI	H,DRAT1	;ANOTHER QUOT
	JMP	PRITZ	;DO IT
PRITW	PUSH	PSW
	LXI	H,DRAT
	CALL	LNOT	;SEND A SPACE
	LXI	H,OTBL
	POP	PSW
	SUI	10H	;SUBTRACT OFFSET
	CALL	PRIT2	;SEND IT
	LXI	H,DRAT	;SEND ANOTHER SPACE
	CALL	LNOT
	RET		;DONE
PRIT6	CPI	4	;IS IT A NUMBER?
	JNZ	PRIT9	;NOPE
	XCHG		;SET UP INDEXES
	LDA	RURD	;SEE IF READY TO RUN
	ANA	A
	JZ	P0000	;NOPE
	LHLD	PNTR	;YUP
	JMP	P0001
P0000	LHLD	SLIN
P0001	XCHG
	PUSH	D	;SAVE ADDRESS FOR NUMBER
	INX	H
	CALL	NMST	;CONVERT INTO A STRING
	XCHG		;LAST ADDRESS TO HL
	DCX	H	;SET UPPER BIT
	MOV	A,M
	ORI	80H
	MOV	M,A
	POP	H	;GET ADDRESS BACK
	JMP	PRITZ	;DO IT
PRIT9	INX	H	;GET NAME NUMBER
	MOV	C,M
	INX	H
	MOV	B,M
	PUSH	B	;SAVE IT
	LHLD	STAB	;START OF SYMBOL TABLE
PRITB	DCX	B	;CHECK COUNT
	MOV	A,B
	ORA	C
	JZ	PRITA	;FOUND IT
	CALL	COUNT	;COUNT CHARACTERS
	DAD	D	;ADD TO INDEX
	JMP	PRITB	;LOOP TO TRY AGAIN
PRITA	MOV	A,M	;GET FIRST CHARACTER
	ANA	A	;SEE IF IT IS ZERO
	JNZ	PRITC	;NOPE
	INX	H	;CORRECT
PRITC	CALL	LNOT	;DUMP IT
	POP	B	;RESTORE SYMBOL NUMBER
	CALL	DFND	;GET ID BYTE
	RET		;DONE
DRAT	DB	0A0H
PRIT2	MOV	C,A	;COUNT TO C
PRITE	DCR	C	;CHECK FOR C=0
	JM	PRITZ	;YUP
	CALL	COUNT	;COUNT CHARACTERS
	DAD	D
	JMP	PRITE	;LOOP AGAIN
PRITZ	CALL	LNOT	;DUMP IT
	RET	
* RTN. D.42
* FIND END OF EXPRESSION AND DUMP IT
* IN: HL = ADDRESS OF FIRST BYTE OF SOURCE EXPRESSION
* OUT: HL = ADDRESS AFTER EXPRESSION
FEND	MOV	A,M	;GET A BYTE
	CALL	GTIN	;GET THE INCREMENT
	DAD	D	;ADD TO HL
	MOV	A,M	;GET NEXT BYTE
	CPI	9	;IS IT END OF EXPRESSION??
	JNZ	FEND	;NOPE
	PUSH	H	;SAVE THE ADDRESS
	CALL	UPOS	;DUMP THE EXPRESSION
	POP	H	;RECOVER ADDRESS
	INX	H	;GET NEXT BYTE
	RET		;DONE..
* RTN. D.43
* DUMP NAME 
DMNM	PUSH	H	;SAVE ADDRESS
	CALL	PRIT	;DUMP IT
	POP	H	;GET ADDRESS BACK
	MOV	A,M	;GET THE BYTE
	CALL	GTIN	;GET THE INCREMENT
	DAD	D	;ADD IT
	XCHG		;TO DE
	LHLD	ESRC	;CHECK FOR OVERRUN
	CALL	CMP16
	XCHG		;BACK TO HL
	RZ		;SURE IS
	MOV	A,M	;GET NEXT BYTE
	CPI	8	;CHECK FOR OFFSET
	RNZ		;NOPE
	INX	H	;YUP
	PUSH	H	;SAVE IT
	LXI	H,DMNMM	;PLUS MESSAGE
	CALL	LNOT	;SEND IT
	POP	H	;RESTORE HL
	JMP	FEND	;PROCESS IT
* RTN. D.44
* DUMP STATEMENT
* IN: HL = ADDRESS OF FIRST BYTE OF STATEMENT
LOOKAH	MOV	A,M	;GET A BYTE
	CPI	9FH	;IS IT A TAB,COLON, OR BACKSLASH?
	RNC		;CAN'T BE
	CPI	9CH
	RC		;NOPE
	INX	H	;TRY AGAIN
	JMP	LOOKAH
DMST	MOV	A,M	;GET A BYTE
	CPI	9FH	;IS IT A STATEMENT NAME???
	JZ	DMST1	;YUP
	CPI	9BH	;IS IT AN ELSE?
	JZ	DMELS	;YUP
	CPI	9CH	;IS IT A TAB?
	JZ	DMSTAB	;YUP
	PUSH	H	;SAVE IT AGAIN
	CALL	PRIT	;PRINT THE STATEMENT NAME
	POP	H	;RECOVER ADDRESS
	MOV	A,M	;GET A BYTE AGAIN
	CPI	0A0H	;IS IT A NORMAL STATEMENT
	JP	DMST2	;YUP
	SUI	80H	;SUBTRACT OFFSET
	ADD	A	;MULTIPLY BY TWO 
	XCHG		;HL TO DE
	LXI	H,DUJM	;JUMP TABLE
	CALL	ADHL	;ADD A TO HL
	MOV	C,M	;GET ADDRESS OUT
	INX	H
	MOV	B,M
	XCHG		;DE BACK TO HL
	INX	H	;NEXT TOKEN
	PUSH	B	;ADDRESS TO THE STACK
	RET		;JUMP TO PROCESSOR
DMELS	PUSH	H	;SAVE IT
	LXI	H,DMELSE	;DUMP THE MESSAGE
	CALL	LNOT
	POP	H	;RESTORE
	INX	H
	JMP	DMST
DMST1	INX	H	;GET NEXT BYTE
	CALL	DMNM	;DUMP THE NAME
	MOV	A,M	;LOOK FOR FOLLOWING TAB
	CPI	9CH
	JZ	DMST	;SURE IS
	PUSH	H	;SAVE HL
	LXI	H,WWWWW	;SPACE MESSAGE
	CALL	LNOT	;SEND IT
	POP	H	;RESTORE HL
	JMP	DMST	;DUMP THE REST OF THE STATEMENT
DMSTAB	PUSH	H
	LXI	H,DMSTBMS	;SEND THE TAB OUT
	CALL	LNOT
	POP	H
	INX	H
	JMP	DMST
DMSTBMS	DB	89H
WWWWW	DB	0A0H	;SPACE MESSAGE
DMST2	INX	H	;GET NEXT BYTE
	MOV	A,M	;CHECK FOR EXPRESSION FOLLOWING
	CPI	9
	JNZ	DMST5	;NOPE
DMST3	CALL	FEND	;DUMP THE EXPRESSION
DMST5	XCHG		;SWAP
	LHLD	ESRC
	CALL	CMP16	;CHECK FOR OVERRUN
	XCHG
	JZ	DMST6
	MOV	A,M
	CPI	35H	;IS IT A REMARKS INDICATOR?
	JNZ	DMST6	;NOPE
	PUSH	H	;SAVE ADDRESS
	LXI	H,DMSG1	;SEND A QUOTE OUT
	CALL	LNOT	;GONE
	POP	H	;GET ADDRESS BACK
DMSTC	INX	H	;GET FIRST BYTE OF REMARKS
	INX	H
DMSTD	CALL	LNOT	;SEND THEM OUT
	INX	H	;GET NEXT BYTE ADDRESS
DMST6	SHLD	FLST	;SAVE THE NEXT ADDRESS OF STATEMENT
	MOV	A,M	;CHECK FOR A COLON BYTE
	CPI	9EH
	JZ	DMS00	;SURE WAS
	CPI	9DH	;CHECK FOR BACKSLASH
	JZ	DMS65	;SURE WAS
	CALL	LOOKAH	;GET NEXT SIGNIFICANT STATEMENT
	MOV	A,M	;IS IT AN "ELSE"?
	CPI	9BH
	LHLD	FLST	;SET UP TO CONTINUE IF IT IS
	JZ	DMST	;SURE IS
	LXI	H,DMSG2	;SEND A CARRIAGE RETURN
	CALL	LNOT	;SEND IT
	RET		;DONE
DMS00	LXI	H,COLON	;SEND A COLON OUT
	CALL	LNOT
	LHLD	FLST	;GET ADDRESS BACK
	INX	H	;GET ADDRESS OF FOLLOWING STATEMENT
	SHLD	FLST
	MOV	A,M	;CHECK FOR ANOTHER COLON
	CPI	9EH
	JZ	DMS00	;SURE WAS, SO DO IT AGAIN
	JMP	DMST	;DUMP IT OUT, TOO.
DMSG9	DB	','+80H
DMSG1	DB	20H	;QUOTES MESSAGE
	DB	0A7H
DMSG2	DB	08DH	;CARRIAGE RETURN MESSAGE
DUJM	DW	DMST4	;TABLE OF JUMPS FOR SPECIAL STATEMENTS
	DW	DMST7
	DW	DMST9
	DW	DMST8
	DW	DMST7
	DW	DMSTA
	DW	DMSTC
	DW	DMST5
	DW	DMSTT
	DW	DMST8
DMST4	CALL	FEND	;DUMP EXPRESSION
	PUSH	H	;SAVE ADDRESS
	LXI	H,DMSG3	;"GOTO" MESSAGE
DMSTU	CALL	LNOT	;SEND IT
	POP	H	;RECOVER ADDRESS
	CALL	DNLS	;SEND THE LIST OF LINE DESCRIPTORS
	JMP	DMST5	;CHECK FOR REMARKS FOLLOWING
DMST7	CALL	DMNM	;PROCESS NAME
	MOV	A,M	;CHECK FOR EXPRESSION FOLLOWING
	CPI	9
	JNZ	DMST5	;NONE
	PUSH	H	;SAVE ADDRESS
	LXI	H,DMSG9	;COMMA
	CALL	LNOT	;SEND IT
	POP	H	;RECOVER ADDRESS
	JMP	DMST3	;DUMP THE EXPRESSION
	JMP	DMST3	;GET FOLLOWING EXPRESSION
DMST8	MOV	A,M	;CHECK FOR NAME THERE
	CPI	6	;LOOKING
	JNZ	DMST5	;NOPE
	CALL	DMNM	;PROCESS NAME
	JMP	DMST5	;CHECK FOR REMARKS
DMST9	CALL	FEND	;PROCESS EXPRESSION
	PUSH	H	;SAVE ADDRESS
	LXI	H,DMSG4	;DUMP A "TO"
	CALL	LNOT	;THERE YOU GO
	POP	H	;RECOVER ADDRESS
	CALL	FEND	;GET NEXT EXPRESSION
	MOV	A,M	;GET NEXT BYTE
	CPI	9	;CHECK FOR ANOTHER EXPRESSION
	JNZ	DMST5	;NOPE, SO LOOK FOR REMARKS
	PUSH	H	;SAVE ADDRESS
	LXI	H,DMSG5	;DUMP A "STEP"
	CALL	LNOT	;DUMP IT DUMMY
	POP	H	;RECOVER ADDRESS
	JMP	DMST3	;DUMP THE LAST EXPRESSION AND QUIT
DMSTA	CALL	FEND	;DUMP EXPRESSION
DMSTB	PUSH	H	;SAVE ADDRESS
	LXI	H,DMSG6	;DUMP A "THEN"
	CALL	LNOT	;SEND IT
	POP	H	;GET BACK THE ADDRESS
	CALL	DMST	;PROCESS AS ANOTHER COMPLETE STATEMEN
	RET		;DONE
DMELSE	DB	' ELSE',' '+80H
DMSG3	DB	' GOTO',0A0H
DMSG4	DB	' TO',0A0H
DMSG5	DB	' STEP',0A0H
DMSG6	DB	' THEN',0A0H
* RTN. D.45
* DUMP NAME LIST
DNLS	CALL	DMNM	;DUMP A NAME
	MOV	A,M	;GET A BYTE
	CPI	6	;IS IT A NAME?
	JZ	DNLS1	;YUP
	RET		;NOPE
DNLS1	PUSH	H	;SAVE HL
	LXI	H,LOTB	;COMMA MESSAGE
	CALL	LNOT	;SEND IT
	POP	H	;GET HL BACK
	JMP	DNLS	;DUMP THE NEXT ONE
* RTN. D.46
* FIND LINE IN SOURCE, WITH OFFSET
* IN: BC = SYMBOL NUMBER
*  DE = OFFSET (+- 32K)
LILO	PUSH	D	;SAVE OFFSET
	PUSH	B	;SAVE 'EM
	LDA	RUNF	;ARE WE RUNNING?
	ANA	A
	JNZ	LILO7	;YUP
	CALL	ASDA	;ASSIGN ALL STATEMENT NAMES
LILO7	POP	B	;GET 'EM BACK
	CALL	DFND	;GET THE POINTER
	XCHG
	LHLD	ESRC
	INX	H
	CALL	CMP16
	JC	LILOG	;TOO BIG
	LHLD	FSRC
	DCX	H
	CALL	CMP16
	JNC	LILOG	;TOO SMALL
	XCHG
	SHLD	LINE
	MOV	A,M	;CHECK FOR A STATEMENT
	CPI	9FH
	MVI	B,7	;ERROR CODE JUST IN CASE
	JNZ	ERROR
	POP	B	;GET OFFSET TO BC
LILO1	MOV	A,B	;CHECK FOR BC=0
	ORA	C
	RZ		;SURE WAS
	CALL	LILO3	;MOVE UP OR BACK ONE STATEMENT
	PUSH	D	;SAVE D
	XCHG
	LHLD	ESRC
	CALL	CMP16
	JZ	LIL82	;ERROR
	LHLD	SLIN
	CALL	CMP16
	JZ	LIL82
	XCHG
	POP	D
LILO2	INR	B	;SET FLAGS FOR B
	DCR	B
	JM	LILO4	;WE'S GOIN' BACKWARDS
	DCX	B	;ANOTHER ONE DOWN THE DRAIN
	JMP	LILO1	;SEE IF WE'RE DONE YET
LILO4	INX	B	;THE BACKWARDS MOVE
	JMP	LILO1	;CHECK FOR DONENESS
LILO3	PUSH	B	;SAVE THE OFFSET COUNT
	INR	B	;SET FLAGS FOR B
	DCR	B
	JM	LILO5	;TIME FOR A BACKSTROKE
LILOF	MOV	A,M	;GET A BYTE
	PUSH	PSW	;SAVE IT
	CALL	MFOS	;MOVE FORWARD ONE STATEMENT
	POP	PSW	;GET BYTE BACK
	CPI	9FH	;IS IT A NAME?
	JZ	LILOF	;YUP
	CPI	85H	;IS IT AN IF?
	JZ	LILOF	;YUP
	CPI	9CH	;IS IT A TAB
	JZ	LILOF	;YUP!
	MOV	A,M	;CHECK FOR COLON BYTE
	CPI	9EH
	JZ	LIL00	;SURE WAS
	CPI	9BH	;IS IT AN ELSE?
	JZ	LIL00	;YUP
	CPI	9DH
	JZ	LIL00
LILO6	POP	B	;GET BACK THE OFFSET COUNT
	RET		;DONE
LILO5	CALL	LILOBAK	;MOVE BACK
	CALL	LILOBAK	;MOVE BACK AGAIN
	MOV	A,M	;GET A BYTE
	PUSH	PSW	;SAVE IT
	CALL	MFOS	;MOVE UP
	POP	PSW	;GET BYTE BACK
	CPI	9FH	;IS IT A STATEMENT NAME?
	JZ	LILO5	;YUP
	CPI	85H	;IS IT AN IF?
	JZ	LILO5
	CPI	9EH	;CHECK FOR COLON BYTE
	JZ	LIL01	;SURE WAS
	CPI	9BH	;IS IT AN ELSE?
	JZ	LIL01	;YUP
	CPI	9DH
	JZ	LIL01
	CPI	9CH	;IS IT A TAB?
	JZ	LILO5	;YUP
	JMP	LILO6	;NOPE
LILOG	MVI	B,7	;ILLEGAL STATEMENT
	JMP	ERROR
LIL00	INX	H	;GET NEXT ADDRESS
	SHLD	LINE	;MAKE IT NEXT
	JMP	LILOF	;CONTINUE
LIL01	CALL	LILOBAK	;BACK UP, JACK
	JMP	LILO5
LILOBAK	CALL	MBOS	;BACK UP
	MOV	A,M	;CHECK FOR TAB
	CPI	9CH
	JZ	LILOBAK	;SURE IS, SO BACK UP AGAIN
	RET		;DON
DMNMM	DB	' &',0A0H
DMS65	LXI	H,DMS66	;SEND BACKSLASH/CARRIAGE RETURN
	JMP	DMS00+3	;SEND IT OUT
DMS66	DB	5CH	;BACKSLASH
	DB	8DH	;CARRIAGE RETURN
LIL82	MVI	B,7
	JMP	ERROR
DMSTT	CALL	FEND	;DUMP EXPRESSION
	PUSH	H	;SAVE ADDRESS
	LXI	H,DMGOS	;GOSUB MESSAGE
	JMP	DMSTU	;FINISH IT UP
DMGOS	DB	' GOSUB',0A0H
* RTN. D.47
* GET LINE AND OFFSET FOR COMMANDS
GLFC	CALL	USCN	;GET NEXT TOKEN
	RC		;THERE AIN'T NONE, BOSS
	LHLD	TSCN	;GET ADDRESS OF TOKEN
	CALL	SSRC	;SEE IF IT'S IN THE TABLE
	PUSH	B	;SAVE THE SYMBOL NUMBER
	MVI	B,7	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;NOT EVEN LISTED!
	ANI	3FH	;STRIP OFF UPPER TWO BITS
	CPI	1	;MAKE SURE IT'S A STATEMENT
	JNZ	ERROR	;NOT A STATEMENT!!!!!!!
	CALL	USCN	;SCAN OFF THE NEXT TOKEN
	JNC	GLFC1	;NOT THE END YET
GLFC4	LXI	D,0	;CLEAR DE
GLFC2	XRA	A	;CLEAR CARRY
	POP	B	;GET BACK SYMBOL NUMBER
	RET		;DONE.....
GLFC1	LHLD	TSCN	;ADDRESS OF TOKEN
	MOV	A,M	;GET THE TOKEN
	CPI	'+'+80H	;IS IT A PLUS SIGN?
	JZ	GLFC5	;YUP
	CPI	'-'+80H	;IS IT A MINUS SIGN?
	JNZ	GLFC3	;NOPE
GLFC5	PUSH	PSW	;SAVE IT
	CALL	USCN	;SCAN OFF YET ANOTHER TOKEN.
	MVI	B,10H	;ERROR CODE JUST IN CASE
	JC	ERROR	;RAN INTO THE END, BUMP.
	CALL	LGNM	;CONVERT TO A NUMBER
	MVI	B,10H	;ERROR CODE IN CASE A STONE IS ENTERING
	JC	ERROR	;HE WAS
	LXI	H,TMP10	;ADDRESS OF NUMBER
	CALL	BCDB	;CONVERT NUMBER TO BINARY
	POP	PSW	;GET THE TOKEN BACK
	XCHG		;HL TO DE
	CPI	'-'+80H	;WAS IT A MINUS SIGN
	JNZ	GLFC2	;NOPE
	MOV	A,D	;YES, SO 1'S COMPLEMENT TIME
	CMA
	MOV	D,A
	MOV	A,E
	CMA
	MOV	E,A
	INX	D	;CORRECT FOR 2'S COMPLEMENT
	JMP	GLFC2	;CONTINUE TOWARDS LEAVING
GLFC3	CALL	BSCN	;OOPS, BACK UP
	JMP	GLFC4	;EXIT WITHOUT ANY OFFSET
* RTN. D.48
* LIST COMMAND INTERPRETER
LIST	LHLD	FSRC	;GET FIRST ADDRESS OF SOURC
	SHLD	FLST	;MAKE THIS THE FIRST ADDRESS TO LIST
	LHLD	ESRC	;GET LAST ADDRESS OF SOURCE
	LDA	CSST	;SET CATV APPROPRIATELY
	STA	CATV
	SHLD	LLST	;MAKE THIS THE LAST ADDRESS TO LIST
	CALL	GLFC	;GET LINE
	JC	LIST1	;THIS PARAMETER NOT INPUTTED
	CALL	LILO	;FIND THE ADDRESS
	SHLD	FLST	;CHANGE THE FIRST ADDRESS TO LIST
	CALL	GLFC	;GET LINE
	JC	LIST1	;THIS PARAMETER NOT INPUTTED
	CALL	LILO	;FIND THE ADDRESS
	SHLD	LINE	;MOVE UP ONE MORE
LISTK	MOV	A,M	;GET A BYTE
	PUSH	PSW	;SAVE IT
	CALL	MFOS	;MOVE UP ONE
	POP	PSW	;CHECK FOR NAMES AND IFS
	CPI	85H
	JZ	LISTK
	CPI	9FH
	JZ	LISTK
	CPI	9EH
	JZ	LISTK
	CPI	9DH
	JZ	LISTK
	CPI	9CH
	JZ	LISTK
	CPI	9BH
	JZ	LISTK
	SHLD	LLST	;CHANGE THE LAST ADDRESS TO LIST
LIST1	XRA	A	;GET FIRST ADDRESS TO DE
LIS33	LHLD	FLST
	XCHG
	LHLD	LLST	;GET LAST ADDRESS
	CALL	CMP16	;CHECK RELATIVE SIZE
	JZ	LISTW	;DONE
	JC	SPRAT	;REVERSED PARAMETERS
LIST2	XCHG		;PUT 'EM BACK
	CALL	DMST	;DUMP THE STATEMENT OUT
	CALL	CONT	;CHECK FOR CONTROL C
	JZ	RSTRT	;IT WAS PUSHED
	JMP	LIS33	;GET THE NEXT ONE
LISTW	LDA	CSST
	ANA	A
	JZ	RSTRT
	LXI	H,DMSG2
	CALL	LNOT
	XRA	A
	STA	CSST
	STA	CATV
	STC
	INR	A	;CLEAR ZERO FLAG
	CALL	COUT
	RET		;BACK TO SAVE COMMAND
* RTN. D.49
* ENTER COMMAND INTERPRETER
ENTR	LHLD	ESRC	;GET END OF SOURCE
	XRA	A	;CLEAR RUN READY FLAG
	STA	RURD
	SHLD	INSR	;SET INSERTION POINT THERE
	CALL	GLFC	;CHECK FOR A PARAMETER
	MVI	A,0	;SET ENTER MODE
	STA	CMND
	JC	RSTRT	;NONE
	CALL	LILO	;GET THE ADDRESS
	SHLD	INSR	;SET INSERTION POINT THERE
	JMP	RSTRT	;BACK TO THE MAINSTREAM
* RTN. D.50
* DELETE COMMAND INTERPRETER
DLTE	CALL	GLFC	;CHECK FOR A PARAMETER
	PUSH	B	;SAVE BC
	MVI	B,10H	;ERROR CODE JUST IN CASE
	JC	ERROR	;NO PARAMETERS ENTERED
	POP	B	;RECOVER BC
	CALL	LILO	;GET ADDRESS
	SHLD	FLST	;SET UP FLAGS
	SHLD	LLST
	CALL	GLFC	;CHECK FOR SECOND PARAMETER
	JC	DLTE1	;NOPE
	CALL	LILO	;GET ADDRESS
	SHLD	LLST	;SAVE IT
DLTE1	MOV	A,M	;GET A BYTE
	PUSH	PSW	;SAVE IT
	CALL	MFOS	;MOVE FORWARD ONE
	POP	PSW	;RESTORE PSW
	CPI	9FH	;CHECK FOR A STATEMENT NAME
	JZ	DLTE1	;NOPW
	CPI	85H	;CHECK FOR IF
	JZ	DLTE1	;YUP
	CPI	9CH	;IS IT A TAB?
	JZ	DLTE1	;SURE IS
	MOV	A,M	;CHECK FOR COLON OR BACKSLASH
	CPI	9EH
	JZ	DLTE4	;SURE WAS
	CPI	9BH	;IS IT AN ELSE?
	JZ	DLTE4	;YUP
	CPI	9DH
	JNZ	DLTE2	;NOPE
DLTE4	CALL	MFOS	;MOVE UP TWO
	JMP	DLTE1	;TRY AGAIN
DLTE2	XCHG		;HL TO DE
	LHLD	ESRC	;END OF SOURCE
	CALL	SUB16	;GET THE DIFFERENCE
	MOV	A,H	;CHECK FOR NONE TO MOVE
	ORA	L
	JZ	DLTE3	;MUST BE LAST STATEMENT DELETED
	MOV	C,L
	MOV	B,H
	LHLD	FLST	;GET FIRST ADDRESS TO KILL
	XCHG		;SWAP
	CALL	MOVE	;MOVE 'EM DOWN
	XCHG		;FLST TO HL
	DAD	B	;ADD N
TCFLG	SHLD	ESRC	;NEW END OF SOURCE
	LDA	CFLG	;GET CHANGE FLAG.
	ANA	A	;TEST THE FLAG.
	JZ	CLER	;NOT SET, NORMAL RET.
	XRA	A	;RESET CHG FLAG.
	STA	CFLG
	LHLD	FLST	;SET UP ADR FOR
	SHLD	INSR	;ENTER COMMAND.
	STA	CMND	;SET ENTER COMMD.
* RTN. D.51
* CLEAR COMMAND PROCESSOR
CLER	CALL	ASDA	;CLEAR ALL VARIABLES
	CALL	AVAP
	XRA	A	;CLEAR RUN READY
	STA	RURD
	LDA	EDITM
	ANA	A	;ARE WE IN EDIT MODE?
	JZ	RSTRT	;NOPE
	LXI	SP,STACK+100
	XRA	A	;CLEAR EDIT MODE
	STA	EDITM
	JMP	EDITJ	;GO BACK TO EDITOR
DLTE3	LHLD	FLST	;NEW END
	JMP	TCFLG	;TEST CHANG FLAG.
*
* CHANGE COMMAND PROCESSOR.
* THANKS TO J. M. POTTER.
*
CHANG	MVI	A,1	;SET CHANGE FLAG.
	STA	CFLG
	JMP	DLTE	;GO TO DELETE.
* RTN. D.52
* RUN COMMAND PROCESSOR
PRUN	LHLD	ESRC	;MAKE SURE THERE IS A PROGRAM
	XCHG
	LHLD	FSRC
	CALL	CMP16
	JZ	RSTRT	;NONE LOADED
	CALL	CHCKA	;CHECK BASIC'S INTEGRITY.
	CALL	GLFC	;LOOK FOR A SPECIFIC LINE
	LHLD	FSRC	;PRESET DATA FLAGS
	SHLD	DATAP
	LXI	H,0
	SHLD	DATAT
	SHLD	DATAW
	LHLD	SDIR	;INITIALIZE ARRAY SPACE
	SHLD	FARY
	LHLD	FRAV	;INITIALIZE PNTR
	SHLD	PNTR
	SHLD	NPNTR
	LHLD	FSRC	;GET START OF SOURCE IN CASE THERE IS NO
* SPECIFIED LINE
	JC	PRUN2	;TWERE'NT NONE
	CALL	LILO	;FIND THE ADDRESS
PRUN2	LDA	RURD	;GET RUN READY FLAG
	ANA	A	;IS IT SET?
	JNZ	RUN	;ALREADY SET
	PUSH	H	;SAVE START ADDRESS
	CALL	ASDA	;ASSIGN STATEMENT ADDRESSES
	CALL	AVAP	;ASSIGN ARRAY POINTER AND VARIABLE SPACE
	MVI	A,0FFH	;SET RUN READY
	STA	RURD
	LHLD	FRAV	;INITIALIZE PNTR
	SHLD	PNTR
	POP	H	;GET BACK ADDRESS
	JMP	RUN	;SO GO RUN ALREADY
* RTN. D.53
* CONT COMMAND INTERPRETER
PCNT	LDA	RURD	;RUN READY?
	ANA	A	;FIND OUT
	JZ	PCNT1	;NOPE
	LHLD	LINEA	;GET CURRENT LINE ADDRESS
	XCHG		;SEE IF WE ARE DONE
	LHLD	ESRC
	XCHG
	CALL	CMP16
	JZ	PCNT1	;YUP
	JMP	RUN	;GO RUN IT
PCNT1	MVI	B,22H	;ERROR
	JMP	ERROR
*
* RTN. D.54
* NEW COMMAND PROCESSOR
*
PNEW	CALL	PNEW1	;INITIALIZE ALL THIS CRAP
	JMP	RSTRT	;DONE
PNEW1	LXI	H,1	;GET A 16 BIT ONE
	SHLD	SNUM	;NUMBER OF SYMBOLS IS ONE
	LHLD	MEND	;END OF MEMORY
	SHLD	STAB	;IS EQUAL TO THE START OF SYMBOLS
	MVI	M,80H	;AND SET THE END IN
	DCX	H	;GET MEND-3
	MVI	M,0
	DCX	H
	MVI	M,0
	DCX	H
	MVI	M,0
	SHLD	SDIR	;START OF DIRECTORY
	SHLD	FARY	;ARRAY & STRING SPACE PTR.
	XRA	A	;CLEAR A
	STA	RURD	;CLEAR THE RUN READY FLAG
	LHLD	EBSC	;GET END BASIC FLAG
	SHLD	FSRC	;STORE SOURCE FLAGS
	SHLD	ESRC
	SHLD	FRAV	;INITIALIZE FRAV
	LXI	H,C2767	;INITIALIZE SEED
	LXI	D,SEED
	LXI	B,6
	CALL	MOVE
	CALL	CHCKA	;CHECK ON THE INTERPRETER'S INTEGRITY
	RET		;DONE....
*
LINK11	LINK	B:TBASIC12
