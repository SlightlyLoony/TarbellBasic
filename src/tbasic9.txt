*
*
* TARBELL BASIC SOURCE MODULE #9
* COPYRIGHT (C) 1978, 1979 TARBELL ELECTRONICS
* LAST CHANGE MADE ON THIS MODULE 12-17-78.
*
* INPUT TRANSLATOR MODULE
* RTN. D.1
* FIND SYMBOL IN SYMBOL TABLE AND DIRECTORY
* IN: HL POINTS TO NAME TO FIND
* OUT: ZERO CLEARED, SYMBOL IS NOT IN SYMBOL TABLE
*  ZERO SET, SYMBOL IS IN THE SYMBOL TABLE, AND
* HL = SYMBOL POINTER
* DE = POINTS TO SYMBOL ID BYTE
* BC = SYMBOL NUMBER
* A = SYMBOL ID BYTE
SSRC	XCHG		;FREE HL
	LHLD	SNUM	;GET NUMBER OF SYMBOLS IN TABLE
	MOV	B,H	;PUT IT IN BC
	MOV	C,L
	LHLD	STAB	;GET START OF SYMBOL TABLE
	XCHG		;PUT 'EM IN THE RIGHT REGISTERS
	CALL	STSRH	;SEARCH THE SYMBOL TABLE
	RNZ		;NO FIND EXIT
* RTN. D.2
* FIND SYMBOL DIRECTORY ENTRY
* IN: BC = SYBMOL NUMBER
* OUT: HL = SYMBOL POINTER
*  DE = POINTS TO SYMBOL ID BYTE
*  BC = SYMBOL NUMBER
*  A = SYMBOL ID BYTE
DFND	LHLD	SDIR	;GET START OF SYMBOL DIRECTORY
	DAD	B	;HL=HL+BC*3
	DAD	B
	DAD	B
	DCX	H	;GET ADDRESS OF ID BYTE
	PUSH	H	;SAVE IT
	DCX	H	;GET ADDRESS OF POINTER MSD
	MOV	D,M	;PUT IT IN D
	DCX	H	;GET ADDRESS OF POINTER LSD
	MOV	E,M	;PUT IT IN E
	POP	H	;GET BACK ID BYTE ADDRESS
	MOV	A,M	;PUT IT IN A
	XCHG		;POINTER TO HL
	PUSH	D	;SAVE ADDRESS
	MOV	D,A	;SAVE A
	XRA	A	;SET ZERO FLAG
	MOV	A,D	;RESTORE A
	POP	D	;RESTORE ADDRESS
	RET		;DONE....
* RTN. D.3
* INSERT SYMBOL IN SYMBOL TABLE AND DIRECTORY
* IN: HL = POINTER TO SYMBOL NAME
* OUT: BC = SYMBOL NUMBER
*  HL = POINTER TO SYMBOL ID BYTE
ITAB	CALL	COUNT	;COUNT CHARACTERS IN NAME
	LDA	CMND	;CHECK FOR COMMAND MODE
	ANA	A	;SET FLAGS
	MVI	B,18H	;SET ERROR TYPE JUST IN CASE
	JNZ	ERROR	;WHOSE THE STONE THAT TRIED THIS??
	PUSH	H	;SAVE ADDRESS AND NUMBER OF CHARACTERS
	PUSH	D
	INX	D	;DE=DE+3
	INX	D
	INX	D
	LHLD	SDIR	;GET START OF DIRECTORY
	PUSH	H	;SAVE IT
	CALL	SUB16	;COMPUTE NEW START
	PUSH	H	;SAVE IT
	LHLD	SDIR	;HL=(STAB)-(SDIR)
	XCHG
	LHLD	STAB
	CALL	SUB16
	MOV	B,H	;NUMBER OF BYTES IN DIRECTORY TO BC
	MOV	C,L
	POP	D	;GET BACK DESTINATION
	POP	H	;GET BACK START OF DIRECTORY
	CALL	MOVE	;MOVE IT BACK
	XCHG		;NEW SDIR TO HL
	SHLD	SDIR	;STUFF IT IN
	LHLD	STAB	;GET START OF SYMBOL TABLE
	POP	D	;GET NUMBER OF CHARACTERS IN SYMBOL
	PUSH	D	;SAVE IT
	CALL	SUB16	;COMPUTE NEW SYMBOL TABLE START
	PUSH	H	;SAVE IT
	DAD	D	;GET STAB BACK
	XCHG		;TO DE
	LHLD	MEND	;GET END OF USEABLE MEMORY
	CALL	SUB16	;COMPUTE NUMBER OF BYTES IN SYMBOL TABLE
	INX	H	;CORRECT
	MOV	B,H	;STICK IT IN BC
	MOV	C,L
	POP	D	;GET BACK NEW START OF SYMBOL TABLE
	LHLD	STAB	;GET OLD START
	CALL	MOVE	;MOVE IT DOWN
	XCHG		;NEW START TO HL
	SHLD	STAB	;STUFF IT IN
	POP	D	;GET BACK NUMBER OF CHARACTERS
	LHLD	MEND	;END OF USEABLE MEMORY
	CALL	SUB16	;COMPUTE LOCATION OF NEW SYMBOL
	INX	H	;CORRECT
	XCHG		;TO DE
	MOV	B,H	;BC=HL
	MOV	C,L
	POP	H	;GET BACK SYMBOL LOCATION
	CALL	MOVE	;PUT IT IN THE SYMBOL TABLE
	LHLD	SNUM	;GET NUMBER OF SYMBOLS
	INX	H	;UPDATE IT
	SHLD	SNUM	;STICK IT BACK
	MOV	B,H	;BC=HL
	MOV	C,L
	LHLD	STAB	;GET FIRST ADDRESS OF SYMBOL TABLE
	DCX	H	;GET NEW SYMBOL ID BYTE
	MVI	M,0	;CLEAR IT OUT
	XRA	A	;CLEAR RURD
	STA	RURD
	RET		;DONE.
* RTN. D.4
* UPSCAN IN INPUT LINE
* UPDATES TSCN AND NSCN
* IF CARRY SET ON EXIT, THERE IS NO MORE DATA IN
* THIS INPUT LINE.
USCN	LDA	ESCN	;CHECK FOR NO MORE DATA
	CPI	2	;CHECK FOR DONENESS
	STC		;SET CARRY JUST IN CASE
	RZ		;RETURN IF END OF LINE AND NO MORE DATA
	LHLD	NSCN	;GET NEXT SCANOFF START
	SHLD	TSCN	;STUFF IT INTO THIS SCANOFF START
	CPI	1	;COMPARE
	JNZ	USCNA	;IT'S NOT
	INX	H	;UPDATE NSCN
	SHLD	NSCN
	INR	A	;IT IS
	STA	ESCN	;SET ESCN TO 2 TO INDICATE THE FACT
	RET		;DONE
USCNA	MOV	A,M	;GET A CHARACTER
	INX	H	;UPDATE INDEX
	ANA	A	;SET FLAGS
	JP	USCNA	;LOOP TO TRY AGAIN
	MVI	C,0	;CLEAR THE CHARACTER COUNTER
USCN2	MOV	A,M	;GET A CHARACTER
	ANA	A	;SET FLAGS
	SHLD	NSCN	;KEEP NSCN UP TO DATE
	JM	USCN3	;OH, OH, THIS IS THE END OF THE LINE
	CPI	20H	;IS THIS A SPACE?
	JNZ	USCN4	;NOPE
	INX	H	;GET NEXT CHARACTER AND IGNORE SPACE
	JMP	USCN2	;TRY AGAIN
USCN4	SHLD	NSCN	;SAVE THE NEXT SCANOFF START
USCN1	MOV	A,M	;GET A CHARACTER
	ANI	7FH	;STRIP OFF UPPER BIT
	CPI	'$'	;IS IT A DOLLAR SIGN?
	JZ	USCN7	;YUP
	CPI	30H	;CHECK FOR NUMERIC
	JM	USCN5	;NOPE
	CPI	7BH	;CHECK FOR LOWER CASE
	JP	USCN5	;NOPE
	CPI	61H	;CHECK AGAIN
	JP	USCN7	;YUP
	CPI	'Z'+1	;CHECK FOR ALPHABETIC
	JP	USCN5	;NOPE
	CPI	'A'	;CHECK AGAIN FOR ALPHABETIC
	JP	USCN7	;SURE IS
	CPI	'9'+1	;CHECK AGAIN FOR NUMERIC
	JP	USCN5	;MISSED OUT
USCN7	MOV	A,M	;GET THE BYTE BACK
	ANA	A	;SET FLAGS
	JM	USCN3	;END OF THE LINE, BUDDY
	INX	H
	INR	C	;UPDATE CHARACTER COUNTER
	JMP	USCN1	;LOOP FOR MORE OF THEM
USCN5	DCR	C	;C=0?
	DCX	H	;JUST IN CASE
	JP	USCN6	;NOPE
	INX	H	;BACK TO NORMAL
	MOV	A,M	;GET THE BYTE BACK
	ANA	A	;SET FLAGS
	JM	USCN3	;END OF THE LINE, FOLKS
	CALL	USCNO	;CHECK FOR POSSIBLE DOUBLE
	JNZ	USCN6	;NOT POSSIBLE
	INX	H	;CHECK FURTHER
	MOV	A,M	;GET IT
	CALL	USCNO	;CHECK IT
	JZ	USCN6	;DOUBLE
	DCX	H	;BACK TO NORMAL
USCN6	MOV	A,M	;GET THE CHARACTER
	ORI	80H	;SET THE UPPER BIT
	MOV	M,A	;STICK IT BACK
	XRA	A	;CLEAR CARRY
	RET
USCN3	MVI	A,1	;SET ESCN
	STA	ESCN
	MOV	A,M	;GET LAST BYTE
	CPI	0A0H	;CHECK FOR A SPACE
	JZ	USCNJ	;YUP
	XRA	A	;CLEAR CARRY
	RET
USCNJ	MVI	A,2	;SET ESCN TO INDICATE NO MORE
	STA	ESCN
	RET
* RTN. D.5
* BACKSCAN INPUT LINE
* SETS TSCN AND NSCN
BSCN	LDA	ESCN	;CHECK END SCAN FLAG
	ANA	A	;SET FLAGS
	JNZ	BSCN1	;DON'T CLEAR THE UPPER BIT
	LHLD	NSCN	;GET NEXT SCAN FLAG
BSCN3	MOV	A,M	;GET A CHARACTER
	ANA	A	;SET FLAGS
	JM	BSCN2	;FOUND IT
	INX	H	;GET NEXT CHARACTER LOCATION
	JMP	BSCN3	;TRY AGAIN
BSCN2	ANI	7FH	;CLEAR THE UPPER BIT
	MOV	M,A	;STUFF IT BACK
BSCN1	LHLD	TSCN	;NSCN=TSCN
	SHLD	NSCN
	MVI	C,2	;SET UP COUNTER
BSCN4	DCX	H	;GET LAST CHARACTER
	MOV	A,M	;GET A CHARACTER, STUPID.
	ANA	A	;SET FLAGS
	JP	BSCN4	;TRY AGAIN
	DCR	C	;FIND TWO YET?
	JNZ	BSCN4	;NOPE
BSCN5	INX	H	;GET NEXT CHARACTER
	MOV	A,M	;GET THE CHARACTER
	CPI	20H	;IS IT A SPACE?????
	JZ	BSCN5	;YUP, SO TRY AGAIN
	SHLD	TSCN	;STORE NEW TSCN
	LDA	ESCN	;CHECK END FLAG OUT
	RRC
	ANI	1
	STA	ESCN
	RET		;DONE..
* RTN. D.6
* GET SYMBOL NUMBER
* IN: HL = LABEL START
*  A = ID BYTE FOR TYPE DESIRED
* OUT: BC = SYMBOL NUMBER
*  CARRY SET IF ID BYTE WAS WRONG
*  A = ID BYTE
GTNM	PUSH	PSW	;SAVE PARAMETERS
	PUSH	H
	CALL	SSRC	;SEARCH THE SYMBOL TABLE
	JNZ	GTNM1	;OH, OH, WE'LL HAVE TO INSERT IT
	POP	H	;GET BACK PARAMETERS
	POP	D
	CMP	D	;SEE IF ID BYTES ARE THE SAME
	RZ		;SURE WERE
	STC		;FLAG THE FACT
	RET
GTNM1	POP	H	;GET BACK SYMBOL ADDRESS
	CALL	ITAB	;INSERT IN SYMBOL TABLE
	POP	PSW	;GET BACK ID BYTE
	MOV	M,A	;STORE IT
	DCX	H	;CLEAR THE POINTER OUT
	MVI	M,0
	DCX	H
	MVI	M,0
	ANA	A	;CLEAR CARRY
	RET		;DONE...
* RTN. D.7
* LEGAL LABEL CHECK
* CHECKS THIS SCAN OFF AS A LABEL
* IF ILLEGAL, EXITS WITH CARRY SET
* OTHERWISE, CARRY IS CLEARED
LGLB	LHLD	TSCN	;GET THIS SCAN ADDRESS
	MOV	A,M	;GET A CHARACTER
	ANI	7FH	;STRIP OFF UPPER BIT
	CPI	7BH	;IS IT BIGGER THAN LOWER CASE?
	JNC	LGLB1	;YUP
	CPI	61H	;IS IT LOWER CASE?
	JNC	LGLB2	;YUP
	CPI	'Z'+1	;IS IT BIGGER THAN ALPHABETIC?
	JP	LGLB1	;YUP
	CPI	'A'	;IS IT ALPHABETIC?
	JP	LGLB2	;YUP
	CPI	'9'+1	;IS IT BIGGER THAN NUMERIC?
	JP	LGLB1	;YUP
	CPI	'0'	;IS IT NUMERIC
	JP	LGLB2	;YUP
LGLB1	STC		;ILLEGAL EXIT
LGLB2	RET		;DONE.
* RTN. D.8
* LEGAL NUMBER CHECK
* IN: TSCN HAS LOCATION OF TRIAL NUMBER
* OUT: CARRY SET IF THIS IS NOT A NUMBER
*  TMP10 HAS THE NUMBER TRANSLATED
* NSCN IS SET TO NEXT CHARACTER AFTER NUMBER
LGNM	LHLD	TSCN	;GET START OF TRIAL NUMBER
	MOV	A,M	;GET FIRST CHARACTER
	ANI	7FH	;STRIP OFF UPPER BIT
	CPI	'.'	;IS IT A PERIOD?
	JZ	LGNM5	;YUP
	CPI	'9'+1	;IS IT BIGGER THAN A NUMBER
	STC		;SET CARRY JUST IN CASE
	RP		;RETURN IF IT'S NOT A DIGIT
	CPI	'0'	;SEE IF IT'S LESS THAN A DIGIT
	RC		;RETURN IF IT'S NOT A DIGIT
LGNM5	LXI	D,TMP10	;GET PLACE TO PUT THE NUMBER
	CALL	STNM	;CONVERT TO NUMBER (OR AT LEAST TRY)
	RC		;RETURN IF CONVERSION ERROR OCCURED
	DCX	H	;CORRECT ADDRESS TO GET LAST CHARACTER IN NUMBER
	PUSH	H	;SAVE ADDRESS
	CALL	BSCN	;GET RID OF END FLAG
	CALL	BSCN
	POP	H	;RESTORE ADDRESS
	MOV	A,M	;UPDATE END FLAG
	ANA	A	;SET FLAGS
	JM	LGNM3	;JUMP IF END IS ALREADY REACHED
	ORI	80H
	MOV	M,A
	SHLD	NSCN	;UPDATE NEXT SCAN OFF ADDRESS
	CALL	USCN	;GET ALL THE FLAGS RIGHT
	XRA	A	;CLEAR CARRY
	RET		;DONE, LET'S GET OUT OF HERE
LGNM3	CALL	USCN	;SCAN OFF TILL END
	JNC	LGNM3	;LOOP FOR ANOTHER SCAN-OFF
	XRA	A	;CLEAR CARRY
	RET		;DONE.
* RTN. D.9
* PROCESS OPERATOR
*  ZERO SET IF IT WAS VALID OPERATOR
* A = CODE FOR OPERATOR
POPR	LHLD	TSCN	;GET SCAN START ADDRESS
	LXI	D,OTBL	;OPERATOR TABLE ADDRESS
	LXI	B,22	;NUMBER OF OPERATOR TYPES
	CALL	STSRH	;SEARCH TABLE
	JZ	POPR1	;OK, WE FOUND IT
	RNZ
POPR1	MOV	A,C	;GET THE ITEM NUMBER
	CPI	22	;CHECK FOR "&"
	JZ	POPRA	;SURE WAS
	CPI	19	;CHECK FOR DUPLICATE RANGE
	JM	POPR2	;IT'S NOT
	SUI	15	;MAKE IT RIGHT (MAYBE)
	CPI	6	;SEE IF IT'S ><
	JNZ	POPR2	;NOPE
	INR	A	;YUP
	INR	A
POPR2	ADI	0FH	;ADD OPCODE OFFSET
	CPI	18H	;CHECK FOR EQUAL SIGN
	JZ	POPR5	;YUP
POPR6	MOV	B,A	;SAVE THE CODE
	XRA	A	;CLEAR CARRY, SET ZERO
	MOV	A,B	;GET THE CODE BACK
	RET		;DONE!!!!!!
POPR5	LDA	OPFLG	;CHECK FOR A "LET" STATEMENT
	CPI	0A8H	;CHECK IT
	MVI	A,18H	;GET REGULAR EQUALS SIGN BACK
	JNZ	POPR6	;FALSE ALARM
	MVI	A,0FH	;CODE FOR ASSIGNMENT OPERATOR
	JMP	POPR6	;SEND IT
POPRA	MVI	A,1AH	;GET + CODE
	RET		;DONE.
USCNO	CPI	'>'	;CHECK THESE THINGS OUT
	RZ
	CPI	'<'
	RZ
	CPI	'='
	RET		;DONE
OTBL	DB	'O'
	DB	'R'+80H
	DB	'A'
	DB	'N'
	DB	'D'+80H
	DB	'N'
	DB	'O'
	DB	'T'+80H
	DB	'>'
	DB	'='+80H
	DB	'<'
	DB	'='+80H
	DB	'>'+80H
	DB	'<'+80H
	DB	'<'
	DB	'>'+80H
	DB	'='+80H
	DB	'-'+80H
	DB	'+'+80H
	DB	'/'+80H
	DB	'*'+80H
	DB	'-'+80H
	DB	'N'
	DB	'O'
	DB	'T'+80H
	DB	0DEH
	DB	'('+80H
	DB	')'+80H
	DB	'='
	DB	'>'+80H
	DB	'='
	DB	'<'+80H
	DB	'>'
	DB	'<'+80H
	DB	'&'+80H
* RTN. D.10
* LINE DESCRIPTOR PROCESSOR
* PRODUCES STATEMENT NAME ON TRIAL DECODED STATEMENT, AND
* OPTIONALLY, THE +- OFFSET EXPRESSION
* ON RETURN, CARRY SET IF END OF LINE ENCOUNTERED
PLDS	CALL	USCN	;SCAN OFF THE LABEL
	RC
	CALL	LGLB	;CHECK LEGALITY OF LABEL
	MVI	B,7	;SET UP FOR ERROR 7
	JC	ERROR	;OH, OH, ILLEGAL LABEL
	MVI	A,1	;SET UP STATEMENT NAME ID
	LHLD	TSCN	;GET LABEL ADDRESS
	CALL	GTNM	;GET THE SYMBOL NUMBER
	PUSH	B	;SAVE 'EM
	MVI	B,9	;SET UP FOR ERROR 9
	JC	ERROR	;OH, OH, TRYING TO USE A VARIABLE FOR A STATEMENT!
	POP	B	;GET 'EM BACK
	LHLD	SLIN	;GET ADDRESS TO STORE CONVERTED CODE
	MVI	M,6	;STORE IT ALL
	INX	H
	MOV	M,C
	INX	H
	MOV	M,B
	INX	H
	MVI	M,7
	INX	H
	SHLD	SLIN	;SAVE THE NEW ADDRESS
	CALL	USCN	;SCAN OFF A TOKEN
	RC		;END OF THE LINE, INSTEAD
	CALL	POPR	;CHECK FOR AN OPERATOR FOLLOWING
	JZ	PLDS1	;AH, HA, AN OPERATOR
PLDS2	ANA	A	;CLEAR CARRY
	RET		;DONE.
PLDS1	CPI	19H	;CHECK FOR A -
	JZ	PLDS3	;YUP
	CPI	1AH	;CHECK FOR A +
	JNZ	PLDS2	;NOPE
PLDS3	CALL	BSCN	;PUT IT ALL BACK
	LHLD	SLIN	;STORE THE EXPRESSION OPCODE
	MVI	M,8	;DONE
	INX	H	;UPDATE INDEX
	SHLD	SLIN	;SAVE IT
	JMP	EVEX	;PROCESS THE EXPRESSION FOLLOWING
SPRAT	MVI	B,10H	;SYNTAX ERROR CODE
	JMP	ERROR
* RTN. D.11
* COMMA, COLON, REMARK, AND END OF LINE CHECKER FOR 
* STATEMENTS USING LISTS
* OUT: CARRY SET IF END OF LINE
*  ZERO SET IF COMMA
*  JUMPS TO EXEC3 IF COLON
*  JUMPS TO PREM IF REMARK
*  JUMPS TO ERROR 10 (SYNTAX) IF ANYTHING ELSE
CCRC	CALL	USCN	;SCAN OFF A TOKEN
	RC		;END OF LINE
	LHLD	TSCN	;GET THE CHARACTER
	MOV	A,M	;GOT IT
	CPI	','+80H	;SEE IF IT'S A COMMA
	RZ		;SURE WAS
	CPI	':'+80H	;SEE IF IT'S A COLON
	JZ	CCRC1	;YUP
	CPI	0ACH	;SEE IF IT'S A SINGLE QUOTE
	JZ	PREM	;YES, SO PROCESS REMARK
	MVI	B,10H	;GET A 10 FOR ERROR TYPE
	JMP	ERROR	;GO GET IT
CCRC1	CALL	USCN	;SCAN OFF THE FIRST TOKEN OF NEXT STATEMENT
	JMP	ENPR1	;GO PROCESS IT
* RTN. D.12
* PROCESS LINE DESCRIPTOR LIST
* RETURNS WHEN END OF LINE IS REACHED
* IF COLON ENCOUNTERED, RETURNS TO EXEC3
PLDL	CALL	PLDS	;SCAN OFF A LINE DESCRIPTOR
	RC		;END OF LINE
	CALL	BSCN	;GET BACK THE COMMA
	CALL	CCRC	;CHECK THE SEPARATOR
	RC		;END OF LINE
	JMP	PLDL	;LOOP FOR ANOTHER LINE DESCRIPTOR
* RTN. D.13
* REMARKS PROCESSOR
* PROCESSES TEXT FOLLOWING EITHER "'" OR "REM"
PREM	LHLD	NSCN	;GET FIRST SIGNIFICANT TEXT ADDRESS
	PUSH	H	;SAVE IT
	LDA	ESCN	;CHECK FOR REM ALONE
	PUSH	PSW
	CALL	BSCN	;BACK OFF, JACK
	MVI	A,35H	;"'" OPCODE
	CALL	ICBY	;INSERT IT
	POP	PSW	;GET BACK FORMER ESCN
	CPI	2	;IS IT REM ALONE?
	JNZ	PREM2	;NOPE
	POP	D	;STORE FAKEOUT SPACE
	PUSH	D
	MVI	A,0A0H
	STAX	D
PREM2	POP	D	;FIRST CHARACTER INDEX TO DE
	DCX	D	;GET ONE LESS
	LHLD	SLIN	;GET CONVERTED CODE ADDRESS
	MVI	M,0	;STORE ID BYTE FOR STRING
PREM1	INX	H	;UPDATE INDEXES
	INX	D	
	LDAX	D	;GET CHARACTER
	MOV	M,A	;STUFF IT IN MEMORY
	ANA	A	;SET FLAGS
	JP	PREM1	;LOOP FOR MORE CHARACTERS
	INX	H	;GET NEXT CODE LOCATION
	MVI	M,1	;MARK END OF STRING
	INX	H	;GET NEXT ONE
	SHLD	SLIN	;STUFF IT BACK
	RET		;DONE.
* RTN. D.14
* EVALUATE INFIX EXPRESSION INTO REVERSE POLISH EXPRESSION
* OUT: RETURNS WHEN END OF EXPRESSION DETECTED
* ERROR EXIT (SYNTAX) OCCURS IF:
* 1. AN ILLEGAL SYMBOL OR LABEL IS ENCOUNTERED
* 2. A RIGHT PAREN WITHOUT A LEFT PAREN OCCURS
* 3. TWO BINARY OPERATORS IN A ROW OCCUR
* 4. THERE ARE MORE LEFT PARENS THAN RIGHT
* 5. TWO LABELS, LITERALS, OR CONSTANTS OCCUR IN A ROW
EVEX	LHLD	SLIN	;COMPUTE PLACE TO PUT STACK
	LDA	RURD	;CHECK IF RUN READY
	ANA	A
	JNZ	EVE00	;YUP
	XCHG
	LHLD	SDIR
	CALL	SUB16
	MOV	A,H	;RIGHT SHIFT HL INTO DE
	ANA	A	;CLEAR CARRY
	RAR		;RIGHT SHIFT
	MOV	D,A
	MOV	A,L
	RAR
	MOV	E,A
	LHLD	SLIN
	DAD	D	;GOT IT
	SHLD	FARY	;SAVE IT
EVE01	XCHG		;PUT IT IN DE
	LHLD	SLIN	;GET PLACE TO PUT POLISH STRING
	LXI	B,1	;INITIALIZE THE COUNTERS
	MVI	M,9	;STORE THE EXPRESSION OPCODE
	INX	H	;UPDATE SLIN
EVEX1	PUSH	B	;SAVE ALL THIS JUNK
	PUSH	D
	PUSH	H
	CALL	USCN	;SCAN OFF A TOKEN
	JC	EVEX2	;RAN INTO END OF LINE
	CALL	POPR	;CHECK FOR NORMAL OPERATOR
	JZ	EVEX3	;SURE IS
	CALL	PFUN	;CHECK FOR INTRINSIC FUNCTION
	JZ	EVEX3	;YUP
	CALL	SCCC	;CHECK FOR SEMICOLON OR COMMA
	JZ	COMM	;IT WAS
	CALL	PINT	;CHECK FOR AN INTERMEDIARY
	JZ	EVEX2	;YUP, SO END OF EXPRESSION
	LHLD	TSCN	;GET THIS ADDRESS THEY'RE TALKIN' ABOUT
	MOV	A,M	;GET THE CHARACTER
	CPI	'"'+80H	;SEE IF IT'S A STRING LITERAL
	JZ	EVEX4	;SURE IS
	CALL	LGNM	;IS IT A NUMBER?
	JNC	EVEX5	;YUP
	CALL	LGLB	;IS IT A LABEL?
	JNC	EVEX6	;'PEARS TO BE..
	MVI	B,11H	;SET UP ERROR 11
	JMP	ERROR	;ILLEGAL VARIABLE NAME
COMM	CPI	0DH	;COMMA?
	JNZ	COMM1	;NOPE
	LDA	OPFLG	;GET OPCODE
	CPI	80H	;ON....GOTO?
	MVI	A,0DH	;GET COMMA BACK
	JNZ	COMM1	;NOPE
	POP	H	;GET 'EM ALL BACK
	POP	D
	POP	B
	PUSH	B	;BACK DOWN, GUYS
	PUSH	D
	PUSH	H
	INR	B	;CHECK FOR EMPTY STACK
	DCR	B
	JNZ	COMM1	;MORE TO DO, CAN'T BE ON..GOTO COMMA
	CALL	BSCN	;SCAN BACK ONE
	JMP	EVEX2	;DONE
COMM1	POP	H	;POP 'EM ALL
	POP	D
	POP	B
	PUSH	PSW	;SAVE THE CODE
COMM3	INR	B	;STACK EMPTY?
	DCR	B
	JZ	COMM2	;YUP
	LDAX	D	;GET TOP OF STACK
	CPI	20H	;IS IT "("?
	JZ	COMM2	;YUP
	MOV	M,A	;STORE IT
	INX	D	;BUMP UP INDEXES
	INX	H
	DCR	B
	JMP	COMM3	;TRY FOR ANOTHER ONE
EVE00	LHLD	FARY
	JMP	EVE01
COMM2	POP	PSW	;GET CODE BACK
	MOV	M,A	;STUFF IT IN
	INX	H	;BUMP UP INDEX
	MVI	C,1	;SET OPERATOR LAST
	JMP	EVEX1
EVEXQ	POP	H	;GET REGISTERS BACK
	POP	D
	POP	B
	MVI	A,36H	;FUNCTION OPERATOR OPCODE
	DCX	D	;PUSH ONTO STACK
	INR	B
	STAX	D
	PUSH	B	;SAVE 'EM
	PUSH	D
	PUSH	H
	LHLD	TSCN	;RESTORE INDEX
	MVI	A,4	;FUNCTION ID BYTE
	JMP	EVEXY	;CONTINUE PROCESSING
EVEX6	POP	H	;GET 'EM BACK
	POP	D
	POP	B
	CALL	EVEXG	;CHECK FOR TWO LABELS IN A ROW
	PUSH	B	;SAVE 'EM ALL AGAIN
	PUSH	D
	PUSH	H
	LHLD	TSCN	;GET ADDRESS OF THIS LABEL
	MOV	A,M	;GET A CHARACTER
	CPI	'F'	;CHECK FOR AN F
	JNZ	EVEXX	;NOPE
	INX	H	;GET NEXT CHARACTER
	MOV	A,M	;GET IT
	CPI	'N'	;CHECK FOR AN N
	DCX	H	;RESTORE INDEX
	JZ	EVEXQ	;YUP, WE'VE GOT AN FN(XXX)
EVEXX	CALL	USCN	;CHECK FOR "(" ON NEXT TOKEN
	JC	EVEXZ	;OOPS, RAN INTO THE END
	CALL	BSCN	;SCAN BACK
	LHLD	NSCN	;GET ADDRESS OF NEXT TOKEN
	MOV	A,M	;GET IT
	CPI	'('+80H	;CHECK IT
	JNZ	EVEXZ	;NOPE
	LHLD	TSCN	;TIME TO CHANGE THE FIRST CHARACTER
	DCX	H	;GET ONE BACK
	MVI	M,0	;CLEAR IT
	SHLD	TSCN	;SAVE THE ADDRESS
	MVI	A,16	;ARRAY CODE
	JMP	EVEXY	;SKIP
EVEXZ	LHLD	TSCN	;GET IT AGAIN
	MVI	A,2	;VARIABLE ID BYTE
EVEXY	CALL	GTNM	;GET SYMBOL NUMBER
	PUSH	B	;SAVE BC
	MVI	B,17H	;ERROR TYPE
	JC	ERROR	;CAN'T USE A STATEMENT FOR A VARIABLE, DUMMY.
	POP	B	;RESTORE BC
	POP	H	;GET SLIN BACK
	MVI	M,2	;STORE OPCODES AND SYMBOL NUMBER
	INX	H
	MOV	M,C
	INX	H
	MOV	M,B
	INX	H
	MVI	M,3
	INX	H
	POP	D	;GET EVERY THING ELSE BACK
	POP	B
EVEX7	MVI	C,2	;SET C TO "LABEL LAST"
	JMP	EVEX1	;LOOP FOR ANOTHER TOKEN
EVEX5	POP	H	;GET IT ALL BACK
	POP	D
	POP	B
	CALL	EVEXG	;CHECK FOR TWO LABELS IN A ROW
	PUSH	B	;STUFF IT ALL BACK
	PUSH	D
	MVI	M,4	;STORE OPCODES AND NUMBER
	LXI	D,TMP10	;LOCATION OF TRANSLATED NUMBER
	XCHG		;GET IT TO THE RIGHT PLACE
	INX	D	;UPDATE SLIN
	LXI	B,6	;NUMBER OF BYTES
	CALL	MOVE	;MOVE IT IN
	XCHG		;GET SLIN BACK TO HL
	DAD	B	;ADD 6
	MVI	M,5	;OPCODE
	INX	H	;UPDATE SLIN
	JMP	EVEX7-2	;POP THE REST AND LOOP
EVEXG	MOV	A,B	;SAVE STACK COUNT
	MVI	B,15H	;ERROR
	DCR	C	;CHECK FOR C=2
	DCR	C
	JZ	ERROR	;TWO IN A ROW, STUPID
	MOV	B,A	;PUT STACK BACK
	RET		;DONE
EVEX4	POP	H	;GET 'EM ALL BACK
	POP	D
	POP	B
	CALL	EVEXG	;CHECK FOR C=2
	PUSH	B	;SAVE SOME
	PUSH	D
	PUSH	H
	CALL	BSCN	;SCAN BACK, JACK
	LHLD	NSCN	;GET QUOTE ADDRESS
	PUSH	H	;SAVE ADDRESS
	CALL	BSCN
	POP	H	;RESTORE ADDRESS
	POP	D	;GET SLIN BACK
	XCHG		;PUT IN THE RIGHT PLACE
	MVI	M,0	;STORE START STRING CODE
EVEXH	INX	H	;UPDATE
	INX	D
	LDAX	D	;GET A CHARACTER
	ANI	7FH	;STRIP OFF UPPER BIT
	CPI	'"'	;IS IT A QUOTE?
	JZ	EVEXI	;YUP
EVEXH00	LDAX	D	;IS IT THE LAST ONE?
	ANA	A	;SET FLAGS
	MOV	M,A	;STUFF IT IN MEMORY
	JP	EVEXH	;IT'S OKAY, GET ANOTHER ONE
	INX	H	;CORRECTION FACTOR
EVEXI	INX	D	;GET NEXT CHARACTER
	LDAX	D
	CPI	'"'	;IS IT A QUOTE?
	JZ	EVEXH00	;SURE IS
	DCX	D
	DCX	H	;GET LAST CHARACTER
	MOV	A,M	;GOT IT
	ANA	A
	JNZ	EV00
	INX	H
	MVI	A,0H
EV00	ORI	80H	;SET UPPER BIT
	MOV	M,A	;SET IT BACK
	INX	H	;GET NEXT ADDRESS
	MVI	M,1	;END OF STRING MARKER
	INX	H	;NEXT SLIN
	XCHG		;GET QUOTE ADDRESS TO HL
	SHLD	NSCN	;SET NSCN
	MOV	A,M	;GET A BYTE
	ANA	A	;SET FLAGS
	JP	EVEXN	;WASN'T THE END
	MVI	A,1	;SET ESCN IF THE END HAS STRUCK
	STA	ESCN
EVEXN	MVI	M,'"'+80H	;SET UPPER BIT
	PUSH	D	;SAVE IT
	CALL	USCN	;SCAN UP ONE TO PUT THINGS RIGHT
	POP	D
	XCHG		;PUT THINGS RIGHT
	JMP	EVEX7-2	;LOOP FOR MORE CHARACTERS
EVEX3	POP	H	;GET 'EM ALL BACK
	POP	D
	POP	B
	CPI	20H	;CHECK FOR "("
	JZ	EVEX8	;IT WAS, INDEED
	CPI	21H	;CHECK FOR ")"
	JZ	EVEX9	;THERE YOU GO
	DCR	C	;CHECK FOR C=1
	JNZ	EVEXW	;IT WASN'T
	CPI	12H	;IS IT "NOT"?
	JNZ	EVEXJ	;NOPE
	INR	C	;INDICATE IT
	MVI	A,1EH	;UNARY NOT
EVEXJ	CPI	19H	;IS IT "-"?
	JNZ	EVEXK	;NOPE
	INR	C	;INDICATE IT
	MVI	A,1DH	;CONVERT TO UNARY MINUS
EVEXK	CPI	40H	;SEE IF IT IS A FUNCTION
	JM	EVEXM	;NOPE
	INR	C	;INDICATE IT
EVEXM	DCR	C	;SEE IF C=0
	JM	EVEXB	;SURE WAS
EVEXW	MOV	C,A	;SAVE THE CHARACTER
EVEXA	DCR	B	;CHECK FOR STACK EMPTY
	INR	B
	JZ	EVEXC	;SURE WAS
	LDAX	D	;GET TOP OF STACK
	CPI	20H	;SEE IF IT'S A "("
	JZ	EVEXC	;YUP
	CPI	1EH	;CHECK FOR UNARY NOT
	JNZ	QQQQ1	;NOPE
	DCR	A	;CHANGE PRECEDENCE
QQQQ1	CPI	19H	;CHECK FOR A MINUS SIGN
	JNZ	QQQQ	;NOPE
	INR	A	;YES, SO CHANGE PRECEDENCE CODE
	INR	A
	JMP	QQQQF
QQQQ	CPI	1BH
	JNZ	QQQQF
	DCR	C
	CMP	C
	INR	C
	JMP	QQQQG	;LOOP AROUND
QQQQF	DCR	A
	CMP	C	;CHECK PRECEDENCE
QQQQG	JC	EVEXC	;NEW ONE IS HIGHER
	LDAX	D	;GET TOP OF STACK
	MOV	M,A	;STORE THE CHARACTER
	DCR	B	;UPDATE STACK POINTERS
	INX	D
	INX	H	;UPDATE SLIN
	JMP	EVEXA	;LOOP TO TRY AGAIN
EVEXB	CPI	1AH	;IS IT A '+'?
	JZ	EVEXE	;YUP, SO IGNORE IT
	MVI	B,14H	;UH, OH, ERROR
	JMP	ERROR
EVEXC	MOV	A,C	;CHARACTER TO A
	DCX	D	;UPDATE STACK POINTERS
	INR	B
	STAX	D	;PUSH ONTO STACK
EVEXE	MVI	C,1	;SET OPERATOR LAST
	JMP	EVEX1	;LOOP FOR ANOTHER TOKEN
EVEX8	DCR	C	;CHECK FOR C=2
	DCR	C
	JNZ	EVEXD	;NOPE
	LDAX	D	;GET TOP OF STACK
	CPI	36H	;IS IT FUNCTION OPERATOR?
	JZ	EVEXD	;YUP
	MVI	A,34H	;ARRAY OPERATOR
	DCX	D	;UPDATE STACK POINTERS
	INR	B	;ONE MORE ON STACK
	STAX	D	;STUFF IT ON
EVEXD	MVI	A,20H	;GET CODE FOR "("
	DCX	D	;UPDATE STACK POINTERS
	INR	B
	STAX	D	;STUFF IT ON THE STACK
	JMP	EVEXE	;LOOP FOR ANOTHER TOKEN
EVEX9	INR	B	;CHECK FOR EMPTY STACK
	DCR	B
	PUSH	B	;SAVE 'EM
	MVI	B,12H	;ERROR TYPE
	JZ	ERROR	;WE SEEM TO HAVE NOT ENOUGH LEFT PARENS
	POP	B	;GET 'EM BACK
	LDAX	D	;GET OPERATOR ON TOP OF STACK
	INX	D	;UPDATE STACK POINTERS
	DCR	B
	CPI	20H	;IS IT A "("
	JZ	EVEX7	;YUP, SO LOOP FOR ANOTHER TOKEN
	MOV	M,A	;NOPE, SO STICK IT ON THE POLISH STRING
	INX	H	;UPDATE SLIN
	JMP	EVEX9	;LOOP TO CHECK NEXT TOP OF STACK
EVEX2	POP	H	;RESTORE ALL
	POP	D
	POP	B
EVEXU	INR	B	;CHECK FOR EMPTY STACK
	DCR	B	
	JZ	EVEXF	;ALL DONE!!
	LDAX	D	;GET TOP OF STACK
	INX	D	;UPDATE POINTERS
	DCR	B
	CPI	20H	;IS IT "("?
	PUSH	B	;SAVE 'EM
	MVI	B,13H	;ERROR TYPE
	JZ	ERROR	;TOO MANY LEFT PARENS
	POP	B	;GET 'EM BACK
	MOV	M,A	;STICK IT ON THE POLISH STRING
	INX	H	;UPDATE SLIN
	JMP	EVEXU	;TRY NEXT CHARACTER
EVEXF	MVI	M,9	;STORE END OF EXPRESSION CHARACTER
	DCX	H	;CHECK FOR NO EXPRESSION
	MOV	A,M	;GET A BYTE
	CPI	9	;CHECK FOR BEGINNING OF EXPRESSION
	SHLD	SLIN	;SAVE SLIN
	RZ		;DONE
	INX	H
	INX	H	;UPDATE SLIN
	SHLD	SLIN	;SAVE IT
	RET		;DONE..
COJMP	DW	CLER	;CLEAR COMMAND.
	DW	PCNT	;CONTINUE COMMAND.
	DW	DLTE	;DELETE COMMAND.
	DW	ENTR	;ENTER COMMAND.
	DW	LIST	;LIST COMMAND.
	DW	PNEW	;NEW COMMAND.
	DW	PRUN	;RUN COMMAND.
	DW	EDIT	;EDIT COMMAND.
	DW	PRSY	;SYMBOL COMMAND.
	DW	0	;BYE COMMAND.
	DW	CHANG	;CHANGE COMMAND.
COJMPE	DB	0	;END OF JMP TABLE.
ETBLE	DB	03	;POWERS OF E (1)
	DB	0
	DB	27H
	DB	18H
	DB	28H
	DB	18H
	DB	3	; (2)
	DB	0
	DB	73H
	DB	89H
	DB	05H
	DB	61H
	DB	3	; (4)
	DB	01H
	DB	54H
	DB	59H
	DB	81H
	DB	50H
	DB	3	; (8)
	DB	03H
	DB	29H
	DB	80H
	DB	95H
	DB	80H
	DB	3	; (16)
	DB	06H
	DB	88H
	DB	86H
	DB	11H
	DB	05H
	DB	3	; (32)
	DB	13H
	DB	78H
	DB	96H
	DB	29H
	DB	60H
	DB	3	; (64)
	DB	27H
	DB	62H
	DB	35H
	DB	14H
	DB	91H
	DB	3	; (128)
	DB	55H
	DB	38H
	DB	87H
	DB	70H
	DB	84H
* RTN. B.49
* E RAISED TO THE X'TH POWER
* (HL) = X, (DE) IS WHERE ANSWER GOES
* ANY X SUCH THAT -K<X<K, WHERE
* K IS LN(9.9999999E 99)
ETOX	PUSH	D	;SAVE DESTINATION ADDRESS
	LXI	D,TMP1	;SET UP TO MOVE INTO TMP1
	PUSH	D	;SAVE LOCATIONS
	PUSH	H	
	CALL	ABSLT	;ABSOLUTE VALUE TO TMP1
	POP	H	;RESTORE LOCATIONS
	POP	D
	MOV	A,M	;GET STARTING ID BYTE
	ANI	80H	;STRIP OFF MANTISSA SIGN BIT
	STA	SIGNF	;SAVE IT
	XCHG		;GET TMP1 ADDRESS TO HL
	CALL	BCDB	;CONVERT TO BINARY
	LXI	D,231	;CHECK SIZE OF EXPONENT
	CALL	CMP16	;COMPARE
	JNC	ETOX1	;OVERFLOW ERROR
	PUSH	H	;SAVE THE NUMBER
	LXI	H,ONE11	;INITIALIZE TMP8 TO A 1
	LXI	D,TMP8
	LXI	B,6
	CALL	MVDN
	POP	B	;GET THE NUMBER BACK IN BC
	MVI	B,1	;SET MASK
	LXI	H,ETBLE	;SET HL TO BEGINNING OF POWERS OF E
ETOX3	MOV	A,B	;A=B AND C
	ANA	C
	JZ	ETOX2	;SKIP IF BIT WAS A ZERO
	PUSH	B	;SAVE MASK AND NUMBER
	PUSH	H	;SAVE INDEX
	LXI	D,TMP8	;TMP8=TMP8*E TO THE 2 TO THE N'TH
	MOV	B,D
	MOV	C,E
	CALL	MULER	;MULTIPLY
	POP	H	;RESTORE INDEX
	POP	B	;AND MASK, AND NUMBER
ETOX2	MVI	A,6	;HL=HL+6
	CALL	ADHL
	MOV	A,B	;LEFT SHIFT THE MASK
	RLC
	MOV	B,A
	JNC	ETOX3	;LOOP FOR MORE INTEGER PORTION
	LXI	H,TMP1	;TMP1=TMP1-TMP9
	LXI	D,TMP9
	MOV	B,H
	MOV	C,L
	PUSH	H	;SAVE ADDRESSES
	PUSH	D
	CALL	SUBER	;SUBTRACT
	POP	D	;RESTORE ADDRESSES
	POP	H
	LXI	B,6	;NUMBER OF BYTES
	CALL	MVDN	;TMP9=TMP1
	LXI	H,ONE11	;TMP2=TMP3=TMP5=1
	LXI	D,TMP2
	CALL	MVDN
	LXI	D,TMP5
	CALL	MVDN
	LXI	D,TMP3
	LXI	H,CON99
	CALL	MVDN
ETOX4	LXI	H,TMP1	;TMP6=TMP1/TMP3
	LXI	D,TMP3
	LXI	B,TMP6
	CALL	DIVER	;DIVIDE
	CALL	TRMN1	;CHECK FOR DONENESS
	JC	ETOX5	;OK, WE'RE DONE
	CALL	FCTRL	;COMPUTE NEXT FACTORIAL TERM
	LXI	H,TMP9	;TMP1=TMP1*TMP9
	LXI	D,TMP1
	MOV	B,D
	MOV	C,E
	CALL	MULER	;MULTIPLY
	LXI	H,TMP6	;TMP5=TMP5+TMP6
	LXI	D,TMP5
	MOV	B,D
	MOV	C,E
	CALL	ADDER	;ADD
	JMP	ETOX4	;LOOP FOR ANOTHER TERM
ETOX5	LXI	H,TMP5	;TMP5=TMP5*TMP8
	LXI	D,TMP8
	MOV	B,H
	MOV	C,L
	CALL	MULER	;MULTIPLY
	LDA	SIGNF	;CHECK FOR MINUS
	ANA	A	;SET FLAGS
	POP	B	;RESTORE DESTINATION
	LXI	H,ONE11	;(BC)=1/TMP8 OR TMP8/1
	LXI	D,TMP5
	JNZ	ETOX6	;SKIP IF IT WAS NEGATIVE
	XCHG		;SWAP ADDRESSES
ETOX6	CALL	DIVER	;DIVIDE
	RET		;DONE..
ETOX1	MVI	B,4	;EXPONENT TOO LARGE ((((ERROR))))
	JMP	ERROR
* RTN. B.50
* LN(HL) TO (DE)
* NEGATIVE (HL) WILL PRODUCE AN ERROR
LOGX	PUSH	D	;SAVE DESTINATION
	PUSH	H	;SAVE SOURCE
	LXI	D,ZERO0	;COMPARE WITH ZERO
	CALL	CMPR
	POP	H	;RESTORE SOURCE
	MVI	B,2	;ERROR TYPE JUST IN CASE
	JZ	ERROR	;SURE WAS!!
	LXI	D,TMP1	;TMP1=(HL)
	LXI	B,6
	CALL	MVDN
	LDAX	D	;GET ID BYTES
	ANI	80H	;STRIP OFF MANTISSA SIGN BIT
	JNZ	LOGX3	;OH, OH, WE'VE GOT AN ERROR
	MVI	B,80H	;SET UP MASK
	MVI	C,0	;CLEAR INTEGER PORTION OF LOG
	LXI	D,ETBLE+42	;SET UP INDEX
LOGX1	LXI	H,TMP1	;SET UP FOR COMPARE
	PUSH	H	;SAVE ALL THESE SILLY REGISTERS
	PUSH	B
	PUSH	D
	CALL	CMPR	;COMPARE
	POP	D	;RESTORE ALL VALUES
	POP	B
	POP	H
	JC	LOGX2	;SKIP IF IT DON'T FIT
	PUSH	D	;SAVE 'EM AGAIN
	PUSH	B
	MOV	B,H
	MOV	C,L
	CALL	DIVER	;DIVIDE
	POP	B	;RESTORE THE REGISTERS, PLEASE
	POP	D
	MOV	A,C	;C=B OR C
	ORA	B
	MOV	C,A
LOGX2	XCHG		;HL=DE
	LXI	D,6	;SET UP FOR
	CALL	SUB16	;SUBTRACT
	XCHG		;DE=HL
	MOV	A,B	;GET THE MASK
	RRC		;RIGHT SHIFT IT
	MOV	B,A
	JNC	LOGX1	;LOOP IF THERE ARE MORE BITS TO DO
	MOV	L,C	;CONVERT C TO A NUMBER
	MVI	H,0
	LXI	D,TMP7
	CALL	BBCD	;CONVERT
	LXI	H,ZERO0	;TMP5=0
	LXI	D,TMP5
	LXI	B,6
	CALL	MVDN
	LXI	H,TMP1	;TMP9=TMP1-1
	LXI	D,ONE11	
	LXI	B,TMP9
	PUSH	H	;SAVE SOME
	PUSH	D
	CALL	SUBER	;SUBTRACT
	POP	D	;GET 'EM BACK
	POP	H
	MOV	B,H	;TMP1=TMP1+1
	MOV	C,L
	PUSH	H	;SAVE AGAIN
	CALL	ADDER	;ADD
	POP	H	;GET TMP1 ADDRESS
	MOV	B,H
	MOV	C,L
	LXI	D,TMP9	;TMP1=TMP9/TMP1
	XCHG		;GET ADDRESSES RIGHT PLACE
	PUSH	B	;SAVE TMP1 ADDRESS
	CALL	DIVER	;DIVIDE
	POP	H	;GET TMP1 ADDRESS
	MOV	D,H
	MOV	E,L
	LXI	B,TMP4	;TMP4=TMP1*TMP1
	CALL	MULER	;MULTIPLY
	LXI	H,ONE11	;TMP2=1
	LXI	D,TMP2
	LXI	B,6
	CALL	MVDN
LOGX4	LXI	H,TMP1	;TMP6=TMP1/TMP2
	LXI	D,TMP2
	LXI	B,TMP6
	CALL	DIVER	;DIVIDE
	CALL	TRMN1	;CHECK FOR DONENESS
	JC	LOGX5	;OK, WE'RE DONE
	LXI	H,TWO22	;TMP2=TMP2+2
	LXI	D,TMP2
	MOV	B,D
	MOV	C,E
	CALL	ADDER	;ADD
	LXI	H,TMP1	;TMP1=TMP1*TMP4
	LXI	D,TMP4
	MOV	B,H
	MOV	C,L
	CALL	MULER	;MULTIPLY
	LXI	H,TMP5	;TMP5=TMP5+TMP6
	LXI	D,TMP6
	MOV	B,H
	MOV	C,L
	CALL	ADDER	;ADD
	JMP	LOGX4	;LOOP FOR ANOTHER TERM
LOGX5	LXI	H,TWO22	;TMP5=TMP5*2
	LXI	D,TMP5
	MOV	B,D
	MOV	C,E
	CALL	MULER	;MULTIPLY
	LXI	H,TMP7	;(BC)=TMP7+TMP5
	LXI	D,TMP5
	POP	B
	CALL	ADDER	;ADD
	RET		;DONE,DONE,DONE
LOGX3	MVI	B,6	;ERROR TYPE 6
	JMP	ERROR	;GO GET IT
* RTN. B.51
* SQUARE ROOT FUNCTION
* (DE)=SQR(HL)
* RTN. B.52
* POWERS
* (BC) = (HL) TO THE (DE) POWER
* (HL) CANNOT BE NEGATIVE
PWRS	PUSH	B	;SAVE DESTINATION
	PUSH	D	;SAVE EXPONENT
	PUSH	H	;SAVE SOURCE
	LXI	D,ZERO0	;CHECK FOR ZERO
	CALL	CMPR
	POP	H	;RESTORE SOURCE
	JZ	PWRSM	;IT'S A ZERO
	XTHL		;GET EXPONENT TO HL
	PUSH	H	;SAVE SOURCE AGAIN
	LXI	D,HNDRD	;CHECK FOR LESS THAN A HUNDRED
	CALL	CMPR	;COMPARE
	POP	H	;RESTORE THE SOURCE
	XTHL		;GET SOURCE BACK TO HL
	JC	PWRS1	;LESS THAN ONE HUNDRED
PWRS2	LXI	D,TMP10	;TMP10=LN(HL)
	CALL	LOGX
	POP	D	;GET BACK EXPONENT
	LXI	H,TMP10	;TMP10=TMP10*(DE)
	MOV	B,H
	MOV	C,L
	CALL	MULER	;MULTIPLY
	POP	D	;GET DESTINATION BACK
	LXI	H,TMP10	;(DE)=ETOX(TMP10)
	CALL	ETOX
	RET		;DONE....
* RTN. B.30
* MATCHER - CONVERTS (HL) AND (DE) TO THE SAME
* FORM, FLOATING POINT OR INTEGER, FOR LATER MATH
* FUNCTIONS. IF THEY ARE BOTH FLOATING POINT, 
* CARRY IS SET ON EXIT.
MATCH	LDAX	D	;GET ONE ID BYTE
	XRA	M	;GET BITS DIFFERENT IN THE TWO
	ANI	1	;STRIP ALL BUT FLOATING/INTEGER BIT
	MOV	A,M	;GET AN ID BYTE
	JNZ	MTCH1	;SKIP IF THEY ARE DIFFERENT
	RRC		;SET CARRY ACCORDING TO FORM
	RET		;NON-CONVERSION EXIT
MTCH1	ANI	1	;WHAT IS (HL)'S FORM?
	STC		;SET CARRY FOR LATER
	PUSH	PSW	;SAVE STATUS ON STACK
	JZ	MTCH2	;SKIP IF (HL) IS ALREADY THE INTEGER
	XCHG		;MAKE (HL) THE INTEGER
MTCH2	PUSH	D	;SAVE REGISTERS
	PUSH	B
	LXI	D,TMP11	;GET WORKING REGISTER ADDRESS
	CALL	INFL	;CONVERT INTEGER TO FLOATING POINT
	POP	B	;RESTORE REGISTERS
	POP	D
	LXI	H,TMP11
	POP	PSW	;GET STATUS BACK
	RZ		;RETURN IF NO SWAP WAS MADE
	XCHG		;PUT EVERYTHING BACK TO NORMAL
	RET		;DONE
* RTN. B.31
* MATH ERROR PROCESSOR
* CHECK TO SEE IF MERR IS SET, IF NOT, RETURNS
* IF IT IS, JUMPS TO ERROR WITH THE APPROPRIATE
* ERROR NUMBER IN B
MCHK	LDA	MERR	;GET MERR TO A
	ANI	07H	;CHECK FOR A BIT SET
	RZ		;RETURN IF NONE
	MVI	B,1	;PRESET COUNTER
MCHK1	RRC		;LSB TO CARRY
	JC	ERROR	;FOUND THE BIT
	INR	B	;UPDATE COUNTER
	JMP	MCHK1	;LOOP FOR NEXT BIT
* RTN. B.32
* ERROR PROCESSOR
* ASSUMES ERROR TYPE NUMBER TO BE IN "B"
ERROR	LXI	H,EMSG	;GET ADDRESS OF ERROR MESSAGE
	MOV	A,B	;CHECK FOR CASSETTE LOAD ERROR
	CPI	23H
	JZ	ERROR1	;NOPE
	LDA	CSST	;CASSETTE MODE?
	ANA	A
	JZ	ERROR1	;NOPE
	LDA	CMND	;ENTER MODE?
	ANA	A
	JNZ	ERROR1	;NOPE
	LHLD	FRAV	;SET UP TO TURN IT INTO A REMARK
	SHLD	SLIN	;RESET CODED LINE
	MVI	A,86H	;STORE AS REMARK OPCODE
	CALL	ICBY
	MVI	A,35H	;SEND SINGLE QUOTE CODE
	CALL	ICBY	;SEND IT
ERROR2	LHLD	NSCN	;BACK UP TO START
	XCHG
	LHLD	CASER
	CALL	CMP16
	JZ	ERROR3
	CALL	BSCN
	JMP	ERROR2
ERROR3	CALL	BSCN
	LXI	SP,STACK+100	;RESET THE STACK
	LXI	H,EXEC3+3	;SET RETURN ADDRES
	PUSH	H
	XRA	A	;CLEAR STFLAG
	STA	STFLG
	LHLD	CASER	;SET UP TO DECODE THIS MESS
	XCHG
	JMP	PREM2+1	;DO IT TO IT!!
ERROR1	XRA	A	;CLEAR ANY CASSETTE MODE
	STA	BFLAG
	STA	CSST
	STA	CATV
	STA	EDITM	;CLEAR ANY EDIT MODE
	LXI	H,0	;CLEAR ANY DUMP MEMORY MODE
	SHLD	DMPMM
	MOV	A,B	;CONVERT TO BINARY
	CALL	BCDBN
	LXI	H,ERMST	;START OF MESSAGE TABLE
	DCR	A	;CORRECT THE COUNT
ERROA	ANA	A	;CHECK FOR DONENESS
	JZ	ERROB	;SURE IS
	CALL	COUNT	;GET NEXT MESSAGE
	DAD	D
	DCR	A	;UPDATE COUNT
	JMP	ERROA
ERROB	PUSH	H
	CALL	CRLF
	POP	H
	CALL	MSGER	;SEND IT OUT
	LXI	H,EMSG	;SEND REST OF IT
	CALL	MSGER
	CALL	LNDSC	;SEND THE LINE DESCRIPTOR
	XRA	A	;CLEAR RUN MODE
	STA	RUNF
	JMP	EDI96	;CHECK FOR POSSIBLE EDIT RE-ENTRY.
* RTN. B.33
* ADDER 
* (BC) = (HL) + (DE)
ADDER	CALL	MATCH	;CHECK FORM
	PUSH	PSW	;SAVE CARRY
	CC	FPADD	;FLOATING POINT ADDITION
	POP	PSW	;RESTORE CARRY
	CNC	IADD	;INTEGER ADDITION
	JMP	MCHK	;LOOK FOR ERRORS
* RTN. B.34
* SUBTRACTER
* (BC) = (HL) - (DE)
SUBER	CALL	MATCH	;CHECK FORM
	PUSH	PSW	;SAVE CARRY
	CC	FPSUB	;FLOATING POINT SUBTRACTION
	POP	PSW	;RESTORE CARRY
	CNC	ISUB	;INTEGER SUBTRACTION
	JMP	MCHK	;LOOK FOR ERRORS
* RTN. B.35
* MULTIPLIER
* (BC) = (HL) TIMES (DE)
MULER	CALL	MATCH	;CHECK FORM
	PUSH	PSW	;SAVE CARRY
	CC	FLML	;FLOATING POINT MULTIPLICATION
	POP	PSW	;RESTORE CARRY
	CNC	IMUL	;INTEGER MULTIPLICATION
	JMP	MCHK	;LOOK FOR ERRORS
* RTN. B.36
* DIVIDER
* (BC) = (HL) DIVIDED BY (DE)
DIVER	CALL	MATCH	;CHECK FORM
	PUSH	PSW	;SAVE CARRY
	CC	DIV2A	;FLOATING POINT DIVISION
	POP	PSW	;RESTORE CARRY
	CNC	IDIV	;INTEGER DIVISION
	JMP	MCHK	;LOOK FOR ERRORS
EMSG	DB	' ERROR IN',' '+80H
ERMST	DB	'OVRFL','W'+80H
	DB	'UNDRFL','W'+80H
	DB	'/','0'+80H
	DB	'EX >','>'+80H
	DB	'BIN CON >','>'+80H
	DB	'-LO','G'+80H
	DB	'STATE N','M'+80H
	DB	'COM','M'+80H
	DB	'VRBL AS STAT','E'+80H
	DB	'SYNTA','X'+80H
	DB	'VRBL N','M'+80H
	DB	'>> ',')'+80H
	DB	'>> ','('+80H
	DB	'2 OPER','S'+80H
	DB	'2 OPAND','S'+80H
	DB	'ILGL FUN','C'+80H
	DB	'STATE AS VRB','L'+80H
	DB	'NEW SYM','B'+80H
	DB	'NO T','O'+80H
	DB	'E'+80H
	DB	'F'+80H
	DB	'CAN',27H,'T CON','T'+80H
	DB	'REA','D'+80H
	DB	'STRIN','G'+80H
	DB	'COMM','A'+80H
	DB	'OPRN','D'+80H
	DB	'<*MEM*','>'+80H
	DB	'UNDI','M'+80H
	DB	'SUBSCPT >','>'+80H
	DB	'SUBSCPT OVFL','W'+80H
	DB	'ASSIG','N'+80H
	DB	'STR AS NU','M'+80H
	DB	'NUM AS ST','R'+80H
	DB	'CNTRL STC','K'+80H
	DB	'ON GOT','O'+80H
	DB	'<< DAT','A'+80H
	DB	'RCV DAT','A'+80H
	DB	8DH
	DB	'- SQ','R'+80H
	DB	'LOGICA','L'+80H
PWRSM	POP	D	;GET RID OF EXPONENT
	POP	D	;GET THE DESTINATION
	LXI	B,6	;SET UP TO MOVE IN THE ZERO
	CALL	MOVE	;DO IT TO IT
	RET		;ALL DONE
PWRS1	POP	B	;GET EXPONENT
	POP	D	;GET DESTINATION
	PUSH	H	;SWAP BC AND HL
	PUSH	B
	POP	H
	POP	B
	PUSH	B
	PUSH	D
	PUSH	H
	LXI	D,TMP11	;PLACE TO PUT IT
	CALL	INTG	;GET THE INTEGER OF BASE
	POP	H	;GET THE NUMBERS AGAIN
	LXI	D,TMP11	;WHERE IT'S AT
	PUSH	H
	CALL	CMPR	;SEE IF THEY ARE THE SAME
	POP	D
	POP	H
	XTHL
	PUSH	D
	JNZ	PWRS2	;NOT AN INTEGER, PROCESS WITH LOGS
	PUSH	H	;SAVE BASE
	LXI	H,ONEEE	;PRESET TMP1
	LXI	D,TMP1
	LXI	B,6
	CALL	MOVE	;MOVE IN A ONE (INTEGER FORM)
	POP	H	;PRESET TMP2 TO COUNT
	XTHL
	LXI	D,TMP2
	CALL	MOVE
PWRS3	LXI	H,TMP2	;CHECK FOR DONENESS
	LXI	D,ZERO0
	CALL	CMPR
	JZ	PWRS5	;SURE IS
	POP	D	;GET BASE
	PUSH	D	;SAVE IT
	LXI	H,TMP1	;GET CURRENT RESULT
	MOV	B,H
	MOV	C,L
	CALL	MULER	;ANOTHER ITERATION
	LXI	H,TMP2	;UPDATE THE COUNT
	LXI	D,ONEEE
	MOV	C,L
	MOV	B,H
	CALL	SUBER
	JMP	PWRS3	;CHECK AGAIN FOR DONENESS
PWRS5	POP	D	;CLEAN UP THE STACK
	POP	D	;GET THE DESTINATION
	LXI	H,TMP1	;GET THE SOURCE
	LXI	B,6	;THE NUMBER OF BYTES
	JMP	MOVE	;MOVE IT IN AND RETURN
SPRGSH	PUSH	D	;SAVE IT
	LXI	D,1	;PRESET
SPRGSH1	MOV	A,H	;CHECK FOR DONE
	ORA	L
	JZ	SPRGSH2	;YUP
	XCHG		;SWAP
	DAD	H
	XCHG
	DCX	H
	JMP	SPRGSH1
SPRGSH2	XCHG
	POP	D
	RET		;DONE
*
LINK09	LINK	B:TBASIC10
