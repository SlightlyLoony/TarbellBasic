*
*
* TARBELL BASIC SOURCE MODULE #14
* COPYRIGHT (C) 1978, 1979 TARBELL ELECTRONICS
* LAST CHANGE ON THIS MODULE MADE 12-16-78.
*
* RTN. E.36
* GET NUMERICAL OPERAND ADDRESS
FPR10	CALL	FNOP	;GET ADDRESS
	MVI	B,26H	;ERROR CODE
	JC	ERROR	;CAN'T HAVE A STRING, TURKEY!
FPR11	XCHG		;TO DE
	LHLD	PNTR	;GET PNTR
	MVI	M,0	;STORE BEGINNING OF POINTER NUMBER
	INX	H	;INCREMENT
	XCHG		;EVERYTHING BACK TO NORMAL
	RET		;ALL DONE
* RTN. E.37
* GET STRING OPERAND ADDRESS
FPR20	CALL	FNOP	;GET ADDRESS
	MVI	B,26H	;ERROR CODE
	JNC	ERROR	;CAN'T HAVE A NUMBER, ROCK.
	JMP	FPR11	;FINISH UP
* RTN. E.38
	STA	CATV
* GET NUMERICAL OPERAND AND CHECK FOR COMMA
FPR30	CALL	FPR10	;GET OPERAND ADDRESS
	PUSH	H	;SAVE PARAMETERS
	PUSH	D
	CALL	POPS	;POP ANOTHER ONE
	MOV	A,M	;GET FIRST BYTE
	CPI	0DH	;IS IT A COMMA?
	MVI	B,10H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;IT WASN'T A COMMA
	POP	D	;RESTORE PARAMETERS
	POP	H
	DCX	D	;CORRECT FOR PNTR+1
	RET		;DONE
* RTN. E.39
* GET NUMERICAL OPERAND TO BINARY
FPR40	CALL	FPR10	;GET BCD OPERAND
	PUSH	D	;SAVE PNTR+1
	CALL	BCDB	;CONVERT TO BINARY
	POP	D	;RESTORE PNTR+
	RET		;DONE
* RTN. E.40
* STRING FINISHER
FPR50	INX	H	;GET NEXT CHARACTER
	MVI	M,1	;STORE END OF STRING CHARACTER
	INX	H	;GET NEXT ADDRESS
	SHLD	PNTR	;UPDATE PNTR
	RET		;DONE
* RTN. E.41
* ABS PROCESSOR
FPRA	CALL	FPR10	;GET OPERAND
	CALL	ABSLT	;GET ABSOLUTE VALUE
	JMP	OPR30	;FINISH
* RTN. E.42
* ASC PROCESSOR
FPRB	CALL	FPR20	;GET OPERAND
	MOV	A,M	;GET FIRST BYTE
	ANI	7FH	;STRIP OFF UPPER BIT
	MOV	L,A	;TO HL
	MVI	H,0	;CLEAR H
* RTN. E.43
* BINARY FINISHER
FPR60	CALL	BBCD	;CONVERT TO BCD
	JMP	OPR30	;FINISH
* RTN. E.44
* ATN PROCESSOR
FPRC	CALL	FPR10	;GET OPERAND
	CALL	ATAN	;COMPUTE ARCTANGENT
	JMP	OPR30	;FINISH
* RTN. E.45
* CHR$ PROCESSOR
FPRD	CALL	FPR40	;GET OPERAND
	INR	H	;CHECK FOR TOO BIG
	DCR	H
	MVI	B,26H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;SURE WAS
	MOV	A,L	;CODE TO A
	STAX	D	;STUFF IT IN
	JMP	FPRU2	;FINISH
* RTN. E.46
* COS PROCESSOR
FPRE	CALL	FPR10	;GET OPERAND
	CALL	COSN	;COMPUTE COSINE
	JMP	OPR30	;FINISH
* RTN. E.47
* EXP PROCESSOR
FPRF	CALL	FPR10	;GET OPERAND
	CALL	ETOX	;COMPUTE E TO THE XTH POWER
	JMP	OPR30
* RTN. E.48
* FRE PROCESSOR
FPRG	CALL	POPS	;GET RID OF OPERAND
	LHLD	PNTR	;COMPUTE FREE SPACE LEFT
	XCHG
	LHLD	FARY
	CALL	SUB16
	INX	D	;UPDATE PNTR
	PUSH	D	;SAVE IT
	LXI	D,900	;SUBTRACT STACK ROOM
	CALL	SUB16	;SUBTRACT IT
	JC	FPRG1	;IT'S OKAY
	LXI	H,0	;ALL OUT
FPRG1	POP	D	;RESTORE POINTER
	JMP	FPR60	;FINISH
Q0000	LXI	H,SPRMS	;CARRIAGE RETURN MESSAGE
	JMP	SPRAA	;DUMP IT OUT
RU000	INX	H
	JMP	RUN	;TRY AGAIN ON NEXT STATEMENT
RUN4A	LHLD	PNTRA	;RESTORE PNTR
	SHLD	PNTR
	XRA	A
	JMP	RUN4TES
* RTN. E.49
* INP PROCESSOR
FPRH	CALL	FPR40	;GET OPERAND
	MOV	A,H	;TOO BIG?
	ANA	A
	MVI	B,26H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;SURE WAS
	MOV	H,L	;STORE PORT NUMBER AND INSTRUCTION
	MVI	L,0DBH	;INPUT INSTRUCTION
	SHLD	IOST	;STORE IT
	CALL	IOST	;DO IT
	MOV	L,A	;TO HL
	MVI	H,0
	JMP	FPR60	;FINISH
* RTN. E.50
* INT PROCESSOR
FPRI	CALL	FPR10	;GET OPERAND
	CALL	INTG	;CONVERT TO INTEGER
	JMP	OPR30	;FINISH
* RTN. E.51
* LEFT$ PROCESSOR
FPRJ	CALL	FPR40	;GET OPERAND
	PUSH	H	;SAVE IT
	CALL	POPS	;POP OFF A COMMA
	MOV	A,M	;CHECK IT
	CPI	0DH
	MVI	B,10H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;WASN'T A COMMA
	CALL	FPR20	;GET OPERAND TWO
FPRJ1	POP	B	;GET COUNT BACK
FPRJ2	MOV	A,M	;GET A CHARACTER
	STAX	D	;STORE IT
	ANA	A	;SEE IF IT WAS END OF STRING
	JM	FPRJ3	;IT WAS
	DCX	B	;IT WASN'T
	INX	H	;UPDATE INDICES
	INX	D
	MOV	A,B	;SEE IF COUNT IS EXHAUSTED
	ORA	C
	JNZ	FPRJ2	;NOPE
	DCX	D	;GET LAST CHARACTER ADDRESS
FPRJ3	LDAX	D	;GET UPPER BIT SET
	ORI	80H
	STAX	D	;STUFF IT BACK
	JMP	FPRU2	;FINISH
* RTN. E.52
* LEN PROCESSOR
FPRK	CALL	FPR20	;GET OPERAND
	PUSH	D	;SAVE PNTR
	CALL	COUNT	;COUNT CHARACTERS
	XCHG		;COUNT TO HL
	POP	D	;GET BACK PNTR
	JMP	FPR60	;FINISH
* RTN. E.53
* LOG PROCESSOR
FPRL	CALL	FPR10	;GET OPERAND
	CALL	LOGX	;COMPUTE LOG BASE E
	JMP	OPR30	;FINSIH
* RTN. E.54
* MID$ PROCESSOR
FPRM	CALL	FPR30	;GET OPERAND
	CALL	BCDB	;CONVERT TO BINARY
	PUSH	H	;SAVE IT
	CALL	FNOP	;GET ANOTHER OPERAND
	JC	FPRM1	;STRING ALREADY
	CALL	BCDB	;CONVERT TO BINARY
	PUSH	H	;SAVE IT
	CALL	POPS	;GET THE COMMA OFF
	MOV	A,M	;CHECK IT OUT
	CPI	0DH
	MVI	B,10H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;NO COMMA
	CALL	FPR20	;GET THE STRING OFF
FPRM2	POP	B	;GET FIRST COUNT BACK
FPRM4	DCX	B	;CHECK FOR DONENESS
	MOV	A,B
	ORA	C
	JZ	FPRJ1	;GOT IT
	MOV	A,M	;CHECK FOR RUNNING INTO END
	ANA	A
	JM	FPRM3	;WE DID
	INX	H	;UPDATE INDEX
	JMP	FPRM4	;LOOP FOR ANOTHER ONE
	DCR	B
FPRM1	LXI	D,0FFFFH	 ;GET ALL ONES TO DE
	POP	B	;COUNT BACK
	PUSH	D	;PUSH 'EM BACK
	PUSH	B
	PUSH	H
	LHLD	PNTR	;GET PNTR+1 BACK
	MVI	M,0	;STORE STRING START
	INX	H
	XCHG		;TO DE
	POP	H	;RESTORE ADDRESS
	JMP	FPRM2	;CONTINUE
FPRM3	POP	B	;GET STACK RIGHT
	MVI	A,0A0H	;GET BLANKS CODE
	STAX	D	;STUFF IT IN
	JMP	FPRU2	;FINISH
* RTN. E.55
* OCT$ PROCESSOR
FPRN	CALL	FPR40	;GET OPERAND
	DCX	D
	MVI	C,1	;SET UP FOR LOOP
	MVI	B,0
	JMP	FPRN1	;TO MIDDLE OF LOOP
FPRN6	MVI	C,3	;TRIPLE SHIFT
FPRN1	XRA	A	;CLEAR A
FPRN2	DAD	H	;LEFT SHIFT HL
	RAL		;BIT TO A
	DCR	C	;UPDATE SHIFT COUNT
	JNZ	FPRN2	;MORE SHIFTS
	INR	B	;UPDATE COUNT
	ANA	A	;CHECK FOR A ZERO
	JNZ	FPRN3	;NOT ZERO
	DCR	B	;CHECK FOR B=MINUS
	INR	B	;CHECK FOR B=MINUS
	JP	FPRN4	;IT'S NOT
FPRN3	INX	D	;STORE THE CHARACTER
	ORI	30H	;MAKE IT ASCII
	STAX	D	;STUFF IT
	MOV	A,B	;MAKE B MINUS
	ORI	80H	;INDICATING NO MORE ZERO SKIPPING
	MOV	B,A
FPRN4	MOV	A,B	;CHECK FOR DONENESS
	ANI	7FH	;STRIP OFF UPPER BIT
	CPI	6
	JNZ	FPRN6	;NOT DONE YET
	XCHG		;ADDRESS TO HL
	MOV	A,B	;CHECK FOR NOTHING PRINTED
	CPI	6
	JNZ	FPRN7	;ALL IS WELL
	INX	H	;STORE A ZERO
	MVI	A,30H
	MOV	M,A
FPRN7	MOV	A,M	;SET UPPER BIT
	ORI	80H
	MOV	M,A
	JMP	FPR50	;DONE
* RTN. E.56
* PEEK PROCESSOR
FPRO	CALL	FPR40	;GET OPERAND
	MOV	L,M	;GET BYTE OUT
	MVI	H,0	;CLEAR H
	JMP	FPR60	;FINISH
* RTN. E.57
* POS PROCESSOR
FPRP	CALL	POPS	;DUMP ONE OFF STACK
	LDA	POSIT	;GET POSITION
	LHLD	PNTR	;POINTER TO DE
	XCHG
	INX	D
	MOV	L,A	;TO HL
	MVI	H,0
	JMP	FPR60	;FINISH
* RTN. E.58
* RIGHT$ PROCESSOR
FPRQ	CALL	FPR40	;GET OPERAND
	PUSH	H	;SAVE IT
	CALL	POPS	;GET THE COMMA OFF
	MOV	A,M	;CHECK IT OUT
	MVI	B,10H	;ERROR CODE JUST IN CASE
	CPI	0DH
	JNZ	ERROR	;IT WASN'T
	CALL	FPR20	;GET THE OTHER OPERAND
	PUSH	D	;SAVE PNTR
	CALL	COUNT	;FIND END OF STRING
	DAD	D
	DCX	H	;CORRECTION
	POP	D	;GET BACK PNTR
	POP	B	;GET BACK COUNT
FPRQ2	MOV	A,M	;GET A CHARACTER
	ANA	A	;CHECK FOR START CODE
	JZ	FPRQ1	;IT WAS
	DCX	B	;CHECK COUNT
	MOV	A,C
	ORA	B
	DCX	H
	JNZ	FPRQ2	;MORE TO GOT
FPRQ1	INX	H	;FIRST CHARACTER TO USE
	LXI	B,0FFFFH	 ;ALL ONES
	JMP	FPRJ2	;FINISH IT
* RTN. E.59
* RND PROCESSOR
FPRR	CALL	FPR10	;GET OPERAND
	PUSH	D	;SAVE PNTR
	MOV	A,M	;GET SIGN
	ANA	A	;SEE IF IT'S MINUS
	JM	FPRR1	;YUP, SO NEW SEED
	LXI	D,ZERO0	;COMPARE WITH ZERO
	CALL	CMPR
	JZ	FPRR2	;GET LAST NUMBER
FPRR3	LXI	D,SEED	 ;GET OPERANDS FOR MODULO 10E 08 MULTIPLY
	LXI	H,A7579
	CALL	FMUL	;DO IT
	LXI	H,WORK1+8	 ;ANSWER
	LXI	D,SEED+2	 ;DESTINATION
	LXI	B,4	;NUMBER OF BYTES
	CALL	MOVE	;MOVE IT IN
FPRR2	POP	B	;GET PLACE FOR RANDOM NUMBER
	LXI	D,TENT8	;CONSTANT
	LXI	H,SEED
	CALL	DIVER	;COMPUTE NUMBER BETWEEN 0 AND 1
	JMP	OPR30	;FINISH
FPRR1	LXI	D,SEED	;GET ABSOLUTE VALUE OF NEW SEED
	CALL	ABSLT
	LXI	H,SEED	;GET INTEGER OF SEED
	LXI	D,SEED
	CALL	INTG
	JMP	FPRR3	;COMPUTE RANDOM NUMBER
* RTN. E.60
* SGN PROCESSOR
FPRS	CALL	FPR10	;GET OPERAND
	CALL	SIGN	;GET EQUIVALENT SIGN
	JMP	OPR30	;FINISH
* RTN. E.61
* SIN PROCESSOR
FPRT	CALL	FPR10	;GET OPERAND
	CALL	SINE	;COMPUTE SINE
	JMP	OPR30
* RTN. E.62
* SPACE$ PROCESSOR
FPRU	CALL	FPR40	;GET OPERAND
	DCX	D
FPRU1	MOV	A,H	;HL=0?
	ORA	L
	JZ	FPRU2	;FINISH UP
	INX	D	;GET ADDRESS FOR SPACE
	MVI	A,20H	;STORE IT
	STAX	D
	DCX	H	;UPDATE COUNT
	JMP	FPRU1	;LOOP FOR ANOTHER ONE
FPRU2	XCHG		;ADDRESS TO HL
	MOV	A,M	;SET UPPER BIT ON LAST ONE
	ORI	80H
	MOV	M,A
	JMP	FPR50	;FINISH
* RTN. E.63
* SPC PROCESSOR
FPRV	CALL	FPR40	;GET OPERAND
	XCHG		;TO DE
	LHLD	PNTR	;GET POINTER
	MVI	M,6	;STORE SPECIAL OPERATOR CODE BLOCK
	INX	H
	MVI	M,1	;SPC CODE
SPCO0	INX	H
	MOV	M,E	;STORE NUMBER OF SPACES
	INX	H
	MVI	M,7	;END OF BLOCK CODE
	INX	H
	SHLD	PNTR	;UPDATE POINTER
	RET		;DONE.......
A7579	DB	2,0,0,0,75H,79H	;7579 CONSTANT
TENT8	DB	3,8,10H,0,0,0	;TEN TO THE EIGHTH CONST
* RTN. E.64
* SQR PROCESSOR
FPRW	CALL	FPR10	;GET OPERAND
	CALL	SQUR	;COMPUTE SQUARE ROOT
	JMP	OPR30	;FINISH
* RTN. E.65
* STR$ PROCESSOR
FPRX	CALL	FPR10	;GET OPERAND
	CALL	NMST	;DUMP STRING OUT
	DCX	D	;SET BIT OF LAST CHARACTER
	XCHG
	MOV	A,M
	ORI	80H
	MOV	M,A
	JMP	FPR50	;FINISH
* RTN. E.66
* TAB PROCESSOR
FPRY	CALL	FPR40	;GET OPERAND
	MOV	A,H	;TOO BIG?
	ANA	A
	MVI	B,26H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;SURE WAS
	XCHG		;TO DE
	LHLD	PNTR	;GET POINTER
	MVI	M,6	;STORE SPECIAL OPERATOR CODE BLOCK
	INX	H
	MVI	M,0	;TAB CODE
	JMP	SPCO0	;CONTINUE
* RTN. E.67
* TAN PROCESSOR
FPRZ	CALL	FPR10	;GET OPERAND
	CALL	TANG	;COMPUTE TANGENT
	JMP	OPR30	;FINISH
* RTN. E.68
* USR PROCESSOR
FPRAA	CALL	FPR40	;GET OPERAND
	XCHG		;TO DE
	PUSH	H	;SAVE PNTR
	LHLD	USER	;GET ADDRESS OF USER ROUTINE
	CALL	FPRAA1	;DO IT
	XCHG		;NUMBER TO HL
	POP	D	;RESTORE PNTR
	JMP	FPR60	;FINISH
FPRAA1	PCHL
* RTN. E.69
* VAL PROCESSOR
FPRAB	CALL	FPR20	;GET OPERAND
	PUSH	D	;SAVE PNTR
FPRAB2	MOV	A,M	;IS IT A SPACE?
	CPI	20H
	JNZ	FPRAB1	;NOPE
	INX	H
	JMP	FPRAB2
FPRAB1	CALL	STNM	;CONVERT STRING TO NUBMER
	POP	D	;RESTORE PNTR
	JNC	OPR30	;GOOD CONVERSION
	LXI	H,ZERO0	;MOVE A ZERO IN
	LXI	B,6	
	CALL	MOVE
	JMP	OPR30	;FINISH
FPHEX	CALL	FPR40	;GET OPERAND
	XRA	A	;CLEAR LEADING ZERO FLAG
	STA	TEMP2
	MVI	B,4	;SET UP FOR 4 DIGITS
FPHEX1	XRA	A	;CLEAR A
	MVI	C,4	;SET UP FOR 4 BITS
FPHEX2	DAD	H	;SHIFT
	RAL
	DCR	C	;UPDATE BIT COUNT
	JNZ	FPHEX2	;MORE TO SHIFT
	ANA	A	;SEE IF IT'S ZERO
	JZ	FPHEX5	;SURE IS
FPHEX6	ADI	30H	;ADD ASCII OFFSET
	STA	TEMP2	;SET THE LEADING ZERO FLAG
	CPI	3AH	;SEE IF IT'S A HEX A THRU F
	JC	FPHEX3	;NOPE
	ADI	7
FPHEX3	STAX	D	;STUFF IT
	INX	D	;UPDATE INDEX
FPHEX7	DCR	B	;UPDATE DIGIT COUNT
	JNZ	FPHEX1	;MORE TO GO
	XCHG		;ADDRESS TO HL
	DCX	H	;SET LAST BIT
	MOV	A,M
	ORI	80H
	MOV	M,A
	JMP	FPR50	;DO IT
FPHEX5	LDA	TEMP2	;CHECK OUT THE LEADING ZERO FLAG
	ANA	A
	MVI	A,0
	JNZ	FPHEX6	;IT'S OK, PUT THIS ONE IN ANYWAY
	MOV	A,B	;CHECK OUT THE COUNT
	CPI	1	;IS IT THE LAST ONE?
	MVI	A,0
	JZ	FPHEX6	;YUP, SO DUMP A SINGLE ZERO
	JMP	FPHEX7	;TRY AGAIN
FPHXR	CALL	FNOP	;GET STRING TO CONVERT
	JNC	SPRAT	;NOT A STRING, STUPID!
	LXI	D,0	;INITIALIZE CONVERSION LOOP
	PUSH	D	;TO THE STACK
FPHXR1	MOV	A,M	;GET A CHARACTER
	ANI	7FH	;STRIP ANY STROBE OFF
	SUI	30H	;CONVERT NUMERIC
	JC	SPRAT	;OOPS, TOO SMALL
	CPI	0AH	;MAYBE IT'S A LETTER
	JC	FPHXR2	;NOPE, IT'S OK
	SUI	7	;CONVERT THE LETTER
	CPI	10H	;IS IT TOO BIG?
	JNC	SPRAT	;YUP
FPHXR2	XTHL		;GET THE NUMBER
	DAD	H	;SHIFT LEFT 4 BITS
	DAD	H
	DAD	H
	DAD	H
	ORA	L	;SET IN THE NEW LSN (LEAST SIGN. NIBBLE)
	MOV	L,A
	XTHL		;BACK TO THE STACK
	MOV	A,M	;ARE WE DONE?
	ANA	A
	INX	H
	JP	FPHXR1	;NOPE
	POP	H	;GET THE NUMBER
	XCHG		;GET PLACE TO CONVERT TO
	LHLD	PNTR
	XCHG
	INX	D
	CALL	BBCD	;CONVERT TO INTERNAL FORM
	JMP	OPR30	;FINISH OFF THE NUMBER
FPRCS	DW	FPRA	;ABS
	DW	FPRB	;ASC
	DW	FPRC	;ATN
	DW	FPRD	;CHR$
	DW	FPRE	;COS
	DW	FPRF	;EXP
	DW	FPRG	;FRE
	DW	FPRH	;INP
	DW	FPRI	;INT
	DW	FPRJ	;LEFT$
	DW	FPRK	;LEN
	DW	FPRL	;LOG
	DW	FPRM	;MID$
	DW	FPRN	;OCT$
	DW	FPRO	;PEEK
	DW	FPRP	;POS
	DW	FPRQ	;RIGHT$
	DW	FPRR	;RND
	DW	FPRS	;SGN
	DW	FPRT	;SIN
	DW	FPRU	;SPACE$
	DW	FPRV	;SPC
	DW	FPRW	;SQR
	DW	FPRX	;STR$
	DW	FPRY	;TAB
	DW	FPRZ	;TAN
	DW	FPRAA	;USR
	DW	FPRAB	;VAL
	DW	FPMAT	;MATCH
	DW	FPHEX	;HEX
	DW	FPRCAL	;CALL
	DW	FPRLOC	;LOC
	DW	FPHXR	;HEX
	DW	FPROCT	;OCT
	DW	FPREOF	;EOF
	DW	FPRREC	;RECORD
	DW	FPRTYP	;TYPE
	DW	FPRFIL	;FILE
	DW	FPRDO	;DO
	DW	FPRDIS	;DISK
	DW	FPRSEA	;SEARCH
	DW	FPRFLX	;FILEXISTS
*
* SEARCH FUNCTION PROCESSOR
*
FPRSEA	LHLD	PTSEA	;GET ADDRESS OF SUBROUTINE
	JMP	FPRFLX1	;SKIP SOM
*
* FILEXISTS FUNCTION PROCESSOR
*
FPRFLX	LHLD	PTFLX	;GET ADDRESS OF SUBROUTINE
FPRFLX1	LXI	D,FPRFLX2	;RETURN ADDRESS
	PUSH	D	;ONTO STACK
	PUSH	H	;ADDRESS OF SUBROUTINE ONTO STACK
	CALL	FPR20	;RECOVER ADDRESS OF STRING OPERAND
	XCHG		;TO DE
	RET		;JUMP TO SUBROUTINE
FPRFLX2	XCHG		;PUT RETURN VALUE INTO DE
	JMP	FPR60	;FINISH IT ALL OFF
*
* CALL FUNCTION PROCESSOR
*
FPRCAL	CALL	FPR40	;GET FIRST OPERAND
	PUSH	H	;SAVE IT
	CALL	POPS	;LOOK FOR A COMMA
	MOV	A,M
	CPI	0DH	;IS IT?
	JNZ	SPRAT	;NOPE
	CALL	FPR40	;GET SECOND OPERAND
	XCHG		;TO DE
	XTHL		;GET FIRST ONE BACK
	XCHG		;FIX IT UP
	LXI	B,FPRCAL1	;PUSH THE RETURN ADDRESS
	PUSH	B
	PCHL		;DO IT TO IT
FPRCAL1	POP	H	;RETURN THE PNTR LOCATION
	XCHG		;TO DE
	CALL	BBCD	;CONVERT TO NUMBER
	JMP	OPR30	;EXIT
FPRLOC	CALL	FNOP	;GET LOCATION OF OPERAND
	XCHG
	LHLD	PNTR	;GET PLACE TO PUT IT
	XCHG
	INX	D
	CALL	BBCD	;CONVERT TO NUMBER
	JMP	OPR30	;DONE.......
FPMAT	CALL	FPR30	;GET OPERAND
	CALL	BCDB	;CONVERT TO BINARY
	PUSH	H	;SAVE START NUMBER
	CALL	FNOP	;GET SEARCH STRING
	JNC	SPRAT	;SHOULD BE A STRING
	PUSH	H	;SAVE LOCATION	
	CALL	POPS	;GET THE COMMA OFF
	MOV	A,M
	CPI	0DH	;IS IT A COMMA?
	JNZ	SPRAT	;NOPE, SO ERROR
	CALL	FNOP	;GET PATTERN STRING
	JNC	SPRAT	;SHOULD BE A STRING, DUMMY!
	CALL	TRANS	;TRANSFORM INTO PATTERN
	POP	D	;GET SEARCH STRING
	XTHL		;GET THE START
	MOV	A,H	;CHECK FOR0
	ORA	L
	JZ	SPRAT	;CAN'T BE
	PUSH	H	;BACK TO THE STACK
	XCHG		;SEARCH STRING TO HL
	CALL	COUNT	;HOW MANY CHARACTERS?
	XTHL		;START BACK TO HL
	INX	D	;CHECK FOR IMPOSSIBLE SITUATION
	CALL	CMP16
	JNC	SPRAT	;CAN'T START AFTER THE STRING!
	PUSH	H
	POP	B
	POP	H
	DCX	B
	DAD	B
	INX	B
	POP	D	;GET THE PATTERN
FPMAT1	CALL	OMATCH	;CHECK IT OUT
	JZ	FPMAT3	;WE FOUND IT
	MOV	A,M	;DID WE HIT THE END OF THE SEARCH STRING?
	ANA	A
	JM	FPMAT2	;YUP
	INX	B	;UPDATE AND TRY AGAIN
	INX	H
	JMP	FPMAT1
FPMAT2	LHLD	PNTR	;PLACE TO STORE TO
	XCHG
	LXI	H,ZERO0	;WHAT TO STORE
	INX	D
	LXI	B,6	;HOW MANY TO STORE
	CALL	MOVE
	JMP	OPR30	;FINISH IT OFF
FPMAT3	MOV	L,C	;BC TO HL
	MOV	H,B
	XCHG		;GET PLACE TO PUT IT
	LHLD	PNTR
	INX	H
	XCHG
	CALL	BBCD	;CONVERT TO BCD
	JMP	OPR30	;FINISH IT OFF
TRANS	XCHG		;GET PLACE TO PUT IT
	LHLD	FARY
	DCR	H
	DCR	H
	MVI	C,0	;CLEAR FLAG
	PUSH	H	;SAVE ADDRESS
TRANS1	LDAX	D	;GET A CHARACTER
	ANI	7FH	;STRIP END BIT
	CPI	'\'	;IS IT A BACKSLASH?
	JZ	TRANS4	;YUP
	CPI	'?'	;IS IT A QUESTION MARK?
	JZ	TRANS5	;YUP
	CPI	'!'	;IS IT AN EXCLAMATION POINT?
	JZ	TRANS5	;YUP
	CPI	'#'	;IS IT A POUND SIGN?
	JZ	TRANS5	;YUP
TRANS2	MOV	M,A	;STORE IT
	MVI	C,0	;CLEAR SLASH SIGN
	LDAX	D	;CHECK FOR ENCOUNTER OF THE END KIND
	ANA	A
	JM	TRANS3	;DONE
	INX	H	;UPDATE
	INX	D
	JMP	TRANS1	;DO IT AGAIN
TRANS3	MOV	A,M	;SET LAST INDICATOR
	ORI	80H
	MOV	M,A
	POP	H	;RESTORE ADDRESS
	RET		;DONE
TRANS4	INR	C	;SET SLASH FLAG
	LDAX	D	;CHECK FOR END
	ANA	A
	JM	TRANS3
	INX	D	;GET NEXT CHARACTER
	JMP	TRANS1	;TRY AGAIN
TRANS5	INR	C	;CHECK FOR C=0
	DCR	C
	JNZ	TRANS2	;NOPE, SO INSERT THE CHARACTER
	ANI	0FH	;TURN INTO CONTROL TYPE
	JMP	TRANS2	;STORE IT
OMATCH	PUSH	H	;SAVE THE WORLD
	PUSH	D
	PUSH	B
MATCH1	MOV	A,M	;GET A CHARACTER FROM SEARCH STRING
	ANI	7FH	;STRIP IT
	MOV	B,A	;TO B
	LDAX	D	;GET A CHARACTER FROM PATTERN STRING
	ANI	7FH	;STRIP IT
	CPI	10H	;IS IT A SPECIAL CHARACTER?
	JC	MATCH4	;YUP
MATCH2	CMP	B	;A=B?
	JNZ	MATCH7	;NOPE
MATCH3	LDAX	D	;CHECK FOR END OF PATTERN
	ANA	A
	JM	MATCH8	;FIND
	MOV	A,M	;CHECK FOR END OF SEARCH STRING
	ANA	A
	JM	MATCH7	;NO FIND
	INX	H	;TRY AGAIN
	INX	D
	JMP	MATCH1
MATCH4	CPI	1	;IS IT ALPHA FLAG?
	JZ	MATCH6	;YUP
	CPI	3	;IS IT NUMERIC FLAG?
	JZ	MATCH5	;YUP
	CPI	0FH	;IS IT ANY CHARACTER?
	JNZ	MATCH2	;NO, SO TREAT AS NORMAL CHARACTER
	JMP	MATCH3	;ASSUME A MATCH
MATCH5	MOV	A,B	;CHECK FOR NUMBER
	CPI	3AH	;IS IT TOO BIG?
	JNC	MATCH7	;YUP
	CPI	30H	;IS IT TOO SMALL?
	JC	MATCH7	;YUP
	JMP	MATCH3	;IT'S OKAY
MATCH6	MOV	A,B	;CHECK FOR ALPHABETIC
	CPI	7BH	;IS IT TOO BIG?
	JNC	MATCH7	;YUP
	CPI	61H	;IS IT LOWER CASE
	JNC	MATCH3	;YUP, SO IT'S OKAY
	CPI	5BH	;IS IT TOO BIG?
	JNC	MATCH7	;YUP
	CPI	41H	;IS IT UPPER CASE?
	JNC	MATCH3	;YUP, SO IT'S OKAY
MATCH7	MVI	A,1	;CLEAR THE ZERO FLAG
	ANA	A
	JMP	MATCH9	;RETURN
MATCH8	XRA	A	;SET THE ZERO FLAG
MATCH9	POP	B	;RESTORE THE WORLD
	POP	D
	POP	H
	RET		;DONE.......
EVPEJ	INX	H	;GET SYMBOL NUMBER OUT
	MOV	C,M
	INX	H
	MOV	B,M
	PUSH	H	;SAVE ADDRESS
	CALL	DFND	;CHECK FOR FNXX LABEL
	CPI	4
	POP	H	;RESTORE ADDRESS
	DCX	H
	DCX	H
	JZ	EVPEP	;IT WAS, SO ONTO THE STACK WITH IT
	LHLD	FNONE	;GET FIRST LIST
	LXI	D,0	;CLEAR COUNTR
EVPEM	MOV	A,M	;GET BYTE
	CPI	2	;LABEL?
	JNZ	SPRAT	;ERROR
	INX	H
	MOV	A,M	;GET A BYTE
	INX	H	;GET ADDRESS OF NEXT ONE
	CMP	C	;GOOD SO FAR?
	JNZ	EVPEK	;NOPE
	MOV	A,M	;GET ANOTHER ONE
	CMP	B	;GOOD?
	JZ	EVPEL	;YUP
EVPEK	INX	H	;GET COMMA
	INX	H
	MOV	A,M	;CHECK IT
	CPI	0DH
	JNZ	SPRAT	;ERROR
	INX	H
	INX	D	;UPDATE COUNT
	JMP	EVPEM	;LOOP FOR ANOTHER
EVPEL	LHLD	FNTWO	;GET SECOND LIST
EVPEN	MOV	A,D	;DE=0?
	ORA	E
	JZ	EVPEO	;YUP, SO WE FOUND IT
	PUSH	D
	MOV	A,M	;GET A BYTE
	CALL	GTIN	;GET INCREMENT
	DAD	D	;ADD IT
	MOV	A,M	;CHECK FOR COMMA
	CPI	0DH
	JNZ	SPRAT	;ERROR
	INX	H	;GET NEXT ITEM
	POP	D	;UPDATE COUNTER
	DCX	D
	JMP	EVPEN	;LOOP FOR ANOTHER
EVPEO	CALL	PUSZ	;PUSH THIS ITEM ON THE STACK
	JMP	EVPE6	;PROCESS AS NORMAL
NSPRC	DW	SPRY
	DW	SPRX
	DW	SPRG
	DW	SPRB
	DW	SPRB
	DW	SPRB
	DW	SPRH
	DW	SPRF
	DW	SPRB
	DW	SPRC
	DW	SPRL
	DW	SPRO
	DW	SPRP
	DW	SPRA
	DW	SPRQ
	DW	SPRR
	DW	SPRT
	DW	SANA
	DW	SPRU
	DW	SPRV
	DW	SPRW
	DW	SPRZ
	DW	SANB
	DW	SANC
	DW	SAND
	DW	STOPE
	DW	STCLO
	DW	STLOA
	DW	STSAV
	DW	STAPP
	DW	STCHK
	DW	SPDI
	DW	SPREN
	DW	SPERA
	DW	SPRES
	DW	SPST
	DW	SPEN
	DW	SPWID
	DW	SPKI
OSPRC	DW	SPRN
	DW	SPRI
	DW	SPRJ
	DW	SPRD
	DW	SPRI
	DW	SPRE
	DW	SPRB
	DW	SPR1
	DW	SPRN
	DW	SPRS
STCHK	MVI A,0FFH	;SET CHECK (VERIFY) FLAG
	STA	CHKEN	;DO IT
	RET		;BACK TO THE EXEC
INPTA	LDA	OPFLG	;SEE IF WE ARE IN AN INPUT INSTRUCTION
	CPI	0A7H
	JNZ	ERROR	;NOPE
	LDA	CSST	;CHECK FOR CASSETTE MODE
	ANA	A
	JNZ	ERROR	;YUP
	POP	H	;CLEAN UP THE STACK
	LXI	H,INPTM	;ERROR MESSAGE
	CALL	MSGER
	JMP	SPRF1	;RETRY INPUT
INPTM	DB	0DH,'INPUT ERROR',8DH
RUNG	CALL	MFOS	;GET NEXT STATEMENT ADDRESS
	PUSH	H	;ONTO THE STACK
	JMP	RUN8	;CONTINUE
SP000	PUSH	H	;SAVE ADDRESS
	INX	H	;GET NEXT BYTE
	MOV	A,M
	ANA	A	;SEE IF IT'S A TAB
	JNZ	SP001	;NOPE, SO MUST BE A SPC
	INX	H	;GET POSITION DESIRED
	MOV	B,M
	LDA	POSIT	;SEE WHERE WE'RE AT NOW
	DCR	A	
	CMP	B	;CHECK FOR SIZE
	JC	SP002	;IT'S OKAY
	PUSH	B	;SAVE POSIT
	CALL	CRLF	;NEXT LINE
	POP	B	;RESTORE COUNT
SP002	LDA	POSIT	;COMPUTE NUMBER OF SPACES NEEDED
	SUB	B	;SUBTRACT
	CMA
	INR	A
SP003	DCR	A	;CHECK FOR DONENESS
	JM	SPRA4	;ALL DONE
	LXI	H,BLANK	;SEND OUT A SPACE
	PUSH	PSW	;SAVE COUNT
	CALL	LNOT
	POP	PSW	;RESTORE COUNT
	JMP	SP003	;TRY FOR ANOTHER ONE
SP001	INX	H	;GET NUMBER OF SPACES OUT
	MOV	A,M
	JMP	SP003	;PUT 'EM OUT
BLANK	DB	0A0H
* RTN. E.70
* DIMENSION AND LET STATEMENT DUMMY
SPRB	RET		;DONE
* RTN. E.71
* END PROCESSOR
SPRC	XRA	A	;CLEAR RUN FLAG
	STA	RUNF
	LHLD	LINE
	SHLD	LINEA
	JMP	RSTRT	;TO EXEC
* RTN. E.72
* GOTO PROCESSOR
SPRD	LHLD	LINE	;GET CURRENT LOCATION
	INX	H	;GET LABEL NUMBER OUT
	INX	H
	MOV	C,M
	INX	H
	MOV	B,M
	PUSH	B	;ONTO THE STACK
	INX	H	;CHECK FOR A OFFSET
	INX	H
	XCHG		;TO DE
	LHLD	ESRC	;CHECK FOR END OF SOURCE COLLISION
	XCHG
	CALL	CMP16
	LXI	D,0	;SET OFFSET TO ZERO
	JZ	SPRD2	;YUP, SO NO OFFSET
	MOV	A,M
	CPI	8	;EIGHT IF IT IS
	JNZ	SPRD2	;NO OFFSET
	INX	H	;GET BEGINNING OF EXPRESSION
	CALL	EVPE	;EVALUATE THE EXPRESSION
	CALL	SPRD1	;GET BINARY OFFSET
SPRD2	POP	B	;GET BACK SYMBOL NUMBER
	CALL	LILO	;FIND ADDRESS
	XCHG		;SWAP 'EM
	POP	H	;RETURN ADDRESS TO HL
	PUSH	D	;NEW PROGRAM ADDRESS TO THE STACK
	PCHL		;RETURN
SPRD1	SHLD	PNTR	;RESET PNTR
	CALL	FNOPO	;GET OPERAND
	MVI	B,26H	;ERROR CODE JUST IN CASE
	JC	ERROR	;CAN'T HAVE A STRING FOR AN OFFSET
	MOV	A,M	;GET SIGNS BYTE
	ANA	A
	PUSH	PSW	;SAVE IT
	CALL	BCDB	;CONVERT IT TO BINARY
	POP	PSW	;GET SIGN BACK
	XCHG		;TO DE
	RET		;DONE.......
* RTN. E.73
* IF PROCESSOR
SPRE	LHLD	LINE	;GET CURRENT LINE
	INX	H	;GET EXPRESSION ADDRESS
	CALL	EVPE	;EVALUATE IT
	CALL	FNOPO	;GET EVALUATED VALUE
	MVI	B,40H	;ERROR CODE JUST IN CASE
	JC	ERROR	;SOMETHING'S WRONG WITH A STRING RESULT!
	CALL	BCDB	;CONVERT TO BINARY
	LXI	D,0FFFFH	;SEE IF IT'S A -ONE
	CALL	CMP16
	JZ	SPRE1	;SURE WAS
	MOV	A,H	;SEE IF IT'S A ZERO
	ORA	L
	MVI	B,40H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;NOT A LOGICAL EXPRESSION
SPRE2	CALL	MFOS	;MOVE UP ONE
	MOV	A,M	;CHECK FOR IF OR TAB
	CPI	9CH	;TAB?
	JZ	SPRE2	;SURE IS
	CPI	85H	;IF?
	JZ	SPRE2	;YUP
	CALL	MFOS	;AND AGAIN
	MOV	A,M	;CHECK FOR COLON OR BACKSLASH
	CPI	9DH
	JZ	SPRE2	;YUP
	CPI	9EH	
	JZ	SPRE2
	CPI	9BH	;IS IT AN ELSE?
	JNZ	SPRE21	;NOPE
	CALL	MFOS	;MOVE UP ANOTHER ONE
SPRE21	XTHL		;SET UP THE STACK
	PCHL		;RETURN
SPRE1	CALL	MFOS	;MOVE UP ONE
	XTHL		;SET UP THE STACK
	PCHL
* RTN. E.74
* INPUT PROCESSOR
SPRF	MVI	A,0	;SET KEYBOARD MODE
	STA	CATV
	STA	CSST
SPRFZ	MVI	B,10H	;IN CASE OF ERROR
	JNC	ERROR	;NO EXPRESSION FOLLOWING
	XCHG		;SWAP
	SHLD	TMP1	;SAVE EXPRESSION START
	LHLD	PNTR	;PRESET NN
	SHLD	TMP2
	XRA	A	;CLEAR PROMPT FLAG
	STA	STFLG
SPRF1	LHLD	TMP1	;INITIALIZE
	SHLD	FLST
	LHLD	TMP2
	SHLD	PNTR
	SHLD	LLST
SPRF2	LHLD	FLST	;GET CURRENT TOKEN
	MOV	A,M
	ANA	A	;CHECK FOR LITERAL
	JZ	SPRF6	;IT WAS
	CPI	0DH	;CHECK FOR COMMA
	JZ	SPRF7	;IT WAS
	CPI	0EH	;IS IT A ";"?
	JZ	SPRF7	;YUP
	CPI	09H	;CHECK FOR END CODE
	JZ	SPRFFB	;IT WAS, AND WE'RE DONE
	CPI	2	;CHECK FOR A LABEL
	JZ	SPRFP	;YUP
SPRFL	LHLD	LLST	;SEE IF ANY INPUT IS AVAILABLE
	XCHG
	LHLD	PNTR
	CALL	CMP16
	JNZ	SPRF5	;SURE IS
	LDA	STFLG	;GET PROMPT FLAG
	ANA	A	;IS IT SET?
	JNZ	SPRF8	;YUP
	LDA	BFLAG	;BINARY MODE?
	ANA	A
	JNZ	SPRF8	;YUP
SPRFQ	LXI	H,SPRFM	;NO, SO SEND A ?
	LDA	CSST	;CHECK FOR CASSETTE MODE
	ANA	A
	JNZ	SPRF8	;SURE IS, SO NO PROMPT
	CALL	MSGER
SPRF8	LHLD	PNTR	;INPUT A LINE
	LDA	BFLAG	;CHECK FOR BINARY MODE
	ANA	A
	JNZ	SPRFBIN	;SURE IS
	LXI	D,100
	DAD	D
	SHLD	TMP11+2
	PUSH	H	;SAVE ADDRESS
	CALL	LIIN	;INPUT FROM KEYBOARD
	POP	H
	JC	SPF10
SPF20	XRA	A	;CLEAR STFLG
	STA	STFLG
SPRF3	PUSH	H	;SAVE THE ADDRESS
	XCHG
	LHLD	PNTR
	INX	H
	XCHG
	CALL	STNM	;TRY TO CONVERT IT
	JC	SPRF4	;NO GOOD
SP99A	XTHL		;NEW ADDRESS TO STACK
	CALL	OPR30	;COMPLETE NUMBER BLOCK
	POP	H	;GET ADDRESS BACK
	DCX	H	;CHECK FOR END OF LINE
	MOV	A,M
	ANA	A
	JM	SPRF2	;IT WAS
	INX	H	;CHECK FOR COMMA SEPARATOR
	MOV	A,M
	CPI	','
	INX	H	;GET NEXT ADDRESS
	JZ	SPRF3	;IT WAS
	JMP	SPRF2	;IGNORE EXTRA INPUT
SPRFFB	XRA	A	;CHECK CLEAR
	STA	CHKEN
	JMP	SPRFF
SPRF4	POP	H	;GET BACK ADDRESS
	CALL	COUNT	;HOW MANY CHARACTERS?
	MOV	C,E	;TO BC
	MOV	B,D
	XCHG		;TO DE
	LHLD	PNTR	;STORE THE THING
	MVI	M,0	;STRING INDICATOR
	INX	H
	XCHG		;BACK TO HL
	CALL	MOVE	;MOVE IT DOWN
	XCHG		;BACK TO HL
	DAD	B
	MVI	M,1	;END OF STRING CODE
	INX	H
	SHLD	PNTR	;UPDATE PNTR
	JMP	SPRF2	;BACK TO SCANNER
SPRFBIN	PUSH	H	;SAVE ADDRESS
	CALL	OBINPOR	;GET A BYTE
	ANA	A	;IS IT A STRING?
	POP	H	;RESTORE ADDRESS
	JZ	SPRFBA	;YUP
	MVI	M,4	;STORE NUMBER BLOCK
	INX	H	;NEXT ADDRESS
	MOV	M,A	;STORE THE FIRST BYTE OF NUMBER
	MVI	B,5	;BYTES LEFT
	INX	H	;FIRST ADDRESS FOR THAT
SPRFBB1	PUSH	H	;SAVE
	PUSH	B
	CALL	OBINPOR	;GET A BYTE
	POP	B
	POP	H
	MOV	M,A	;STORE IT
	INX	H
	DCR	B	;DONE?
	JNZ	SPRFBB1	;NOPE
	MVI	M,05H	;YUP{
	INX	H
	SHLD	PNTR	;UPDATE STACK
	JMP	SPRF2	;CONTINUE
SPRFBA	MOV	M,A	;STORE THE BYTE
	INX	H	;UPDATE THE INDEX
SPRFBA1	PUSH	H	;SAVE ADDRESS
	CALL	OBINPOR	;GET ANOTHER BYTE
	POP	H	;RESTORE ADDRESS
	MOV	M,A	;STORE IT
	INX	H	;UPDATE
	ANA	A	;END?
	JP	SPRFBA1	;NOPE
	MVI	M,01	;END
	INX	H
	SHLD	PNTR
	JMP	SPRF2	;CONTINUE
SPRF5	LHLD	FLST	;PUSH RECEIVING VARIABLE
	CALL	PUSZ
	MOV	A,M	;GET INCREMENT
	CALL	GTIN
	DAD	D	;ADD IT
	SHLD	FLST	;UPDATE
	LHLD	LLST	;PUSH CONSTANT
	CALL	PUSZ
	MOV	A,M	;GET INCREMENT
	CALL	GTIN
	DAD	D
	SHLD	LLST	;UPDATE
	LDA	CHKEN	;SEE IF THIS IS CHECKING
	ANA	A
	JNZ	SPRF2	;YUP, SO BACK TO SCANNER
	CALL	OPRQ	;ASSIGN
	JMP	SPRF2	;TO SCANNER
SPRF6	INX	H	;PRINT LITERAL
	LDA	CSST	;CHECK FOR CASSETTE MODE
	ANA	A
	JNZ	SPRF7	;YUP, SO SKIPTHE PROMPT
	CALL	MSGER
	MVI	A,0FFH	;SET THE PROMPT FLAG
	STA	STFLG
SPRF7	LHLD	FLST	;UPDATE FLST
	MOV	A,M
	CALL	GTIN
	DAD	D
	SHLD	FLST
	JMP	SPRF2	;BACK TO THE SCANNER
SPRFM	DB	'?'+80H
*
LINK14	LINK	B:TBASIC15
