*
* TARBELL BASIC SOURCE MODULE #10
* COPYRIGHT (C) 1978 TARBELL ELECTRONICS
* LAST CHANGE ON THIS MODULE MADE 12-17-78.
*
* RTN. D.15
* INSERT CODED LINE INTO SOURCE CODE FILE
* USES ESRC, INSR, AND SLIN
ICLS	LHLD	ESRC	;CHECK FOR INSERTION AT END
	XCHG		;TO DE
	LHLD	FRAV	;GET FFRAV
	CALL	CMP16	;SAME?
	JNZ	ICLS2	;NOPE
ICLS3	LHLD	ESRC
	XCHG		;TO DE
	LHLD	INSR
	CALL	CMP16	;COMPARE THE ADDRESSES
	JZ	ICLS1	;SAME, SO NO MOVES REQUIRED
	LHLD	SLIN	;COMPUTE "TO" ADDRESS
	CALL	SUB16	;HL=SLIN-ESRC
	PUSH	H	;SAVE IT
	PUSH	H	;AND AGAIN
	LHLD	INSR	;COMPUTE NUMBER OF BYTES TO MOVE
	XCHG		;TO DE
	LHLD	SLIN
	CALL	SUB16	;HL=SLIN-INSR
	MOV	C,L	;BC=HL
	MOV	B,H
	POP	D	;FINISH COMPUTING "TO" ADDRESS
	LHLD	INSR
	XCHG		;DE<>HL
	DAD	D	;HL=INSR+SLIN-ESRC
	XCHG		;TO DE
	CALL	MOVE	;MOVE THAT STUFF UP
	POP	B	;GET SLIN-ESRC
	PUSH	B	;SAVE IT AGAIN
	LHLD	INSR	;GET "TO" ADDRESS
	XCHG		;TO DE
	LHLD	SLIN	;GET "FROM" ADDRESS
	CALL	MOVE	;MOVE IT
	SHLD	ESRC	;SET NEW END OF SOURCE
	MVI	M,80H	;STORE END CODE
	SHLD	FRAV	;UPDATE FRAV
	LHLD	INSR	;GET OLD INSERTION ADDRESS
	POP	D	;GET SLIN-ESRC
	DAD	D	;ADD THEM
	SHLD	INSR	;SAVE IT
	RET		;DONE....
ICLS2	LHLD	FRAV	;MOVE LINE DOWN
	XCHG
	LHLD	SLIN
	CALL	SUB16
	MOV	C,L
	MOV	B,H
	LHLD	ESRC
	XCHG
	CALL	MOVE
	XCHG
	DAD	B
	SHLD	SLIN	;UPDATE SLIN
	JMP	ICLS3
ICLS1	LHLD	SLIN	;GET NEW INSERTION ADDRESS
	SHLD	ESRC	;SET ALL THESE CRAZY FLAGS
	MVI	M,80H	;STORE END CODE
	SHLD	FRAV	;UPDATE FRAV
	SHLD	INSR
	RET		;DONE..
* RTN. D.16
* PROCESS CODED LINE
CLPR	LDA	CMND	;CHECK IT WE'RE IN COMMAND MODE
	ANA	A	;SET FLAGS
	JNZ	CLPR1	;SEEM TO BE
	CALL	ICLS	;INSERT THE LINE IF WE'RE NOT
	LDA	EDITM	;CHECK FOR EDIT MODE
	ANA	A
	JNZ	EDIT2	;SURE WAS
	JMP	RSTRR	;LOOP FOR ANOTHER LINE
CLPR1	CALL	SUBS	;GET ADDRESS
	PUSH	H
	LHLD	PNTR
	SHLD	PNTRA
	LHLD	SLIN	;SET UP NEW PNTR
	SHLD	PNTR
	SHLD	NPNTR
	LHLD	SDIR	;SET UP FARY IF RUN NOT READY
	LDA	RURD
	ANA	A
	JNZ	CLPR9	;IT'S OKAY ALREADY
	SHLD	FARY	;SET IT UP
CLPR9	POP	H	;FIRST ADDRESS TO EXECUTE
	JMP	RUN	;RUN IT
* THE FOLLOWING IS A TABLE OF ALL INTRINSIC FUNCTIONS
* RECOGNIZED BY TARBELL BASIC.  THEY ARE IN OPCODE ORDER
FUNT	DB	'AB','S'+80H
	DB	'AS','C'+80H
	DB	'AT','N'+80H
	DB	'CHR','$'+80H
	DB	'CO','S'+80H
	DB	'EX','P'+80H
	DB	'FR','E'+80H
	DB	'IN','P'+80H
	DB	'IN','T'+80H
	DB	'LEFT','$'+80H
	DB	'LE','N'+80H
	DB	'LO','G'+80H
	DB	'MID','$'+80H
	DB	'OCT','$'+80H
	DB	'PEE','K'+80H
	DB	'PO','S'+80H
	DB	'RIGHT','$'+80H
	DB	'RN','D'+80H
	DB	'SG','N'+80H
	DB	'SI','N'+80H
	DB	'SPACE','$'+80H
	DB	'SP','C'+80H
	DB	'SQ','R'+80H
	DB	'STR','$'+80H
	DB	'TA','B'+80H
	DB	'TA','N'+80H
	DB	'US','R'+80H
	DB	'VA','L'+80H
	DB	'MATC','H'+80H
	DB	'HEX','$'+80H
	DB	'CAL','L'+80H
	DB	'LO','C'+80H
	DB	'HE','X'+80H
	DB	'OC','T'+80H
	DB	'EO','F'+80H
	DB	'RECOR','D'+80H
	DB	'TYP','E'+80H
	DB	'FIL','E'+80H
	DB	'D','O'+80H
	DB	'DIS','K'+80H
	DB	'SEARC','H'+80H
	DB	'FILEXIST','S'+80H
* RTN. D.17
* PROCESS INTRINSIC FUNCTIONS
* CHECKS TO SEE IF TOKEN AT TSCN IS A VALID
* INTRINSIC FUNCTION. IF IT IS, EXIT IS WITH ZERO AND
* THE OPCODE IN A.  IF IT IS NOT, EXIT IS NOT ZERO.
PFUN	LHLD	TSCN	;GET TOKEN ADDRESS
	LXI	D,FUNT	;TABLE ADDRESS
	LXI	B,42	;NUMBER OF ITEMS ON TABLE
	CALL	STSRH	;SEARCH THE TABLE
	RNZ		;NO FIND
	PUSH	B	;SAVE OFFSET
	CALL	USCN	;SCAN OFF NEXT TOKEN
	JC	SPRAT	;SYNTAX ERROR IF NONE
	LHLD	TSCN	;GET THE ADDRESS
	MOV	A,M	;GET IT
	CPI	'('+80H	;SEE IF IT'S RIGHT
	JNZ	SPRAT	;NOPE!!
	CALL	BSCN	;SCAN BACK TO LAST TOKEN
	POP	B	;RESTORE OFFSET
	MVI	A,3FH	;OPCODE OFFSET
	ADD	C	;FORM THE CODE
	MVI	C,1	;SET THE ZERO FLAG
	DCR	C
	RET		;DONE.
* RTN. D.18
* CHECK FOR SEMICOLON OR COMMA
* IF IT IS, EXITS WITH ZERO SET AND OPCODE IN
* A.  IF NOT, ZERO IS CLEARED.
SCCC	LHLD	TSCN	;GET TOKEN ADDRESS
	MOV	A,M	;GET THE CHARACTER
	CPI	';'+80H	;CHECK FOR SEMICOLON
	JZ	SCCC1	;IT IS
	CPI	','+80H	;CHECK FOR COMMA
	RNZ		;IT WASN'T
	MVI	A,0DH	;SET OPCODE
	RET		;DONE
SCCC1	MVI	A,0EH	;GET OPCODE
	RET		;DONE.
* RTN. D.19
* INSERT CODE BYTE
* A = CODE BYTE
ICBY	LHLD	SLIN	;GET ADDRESS TO PUT THE THING
	MOV	M,A	;STUFF IT IN
	INX	H	;UPDATE INDEX
	SHLD	SLIN	;SAVE IT
	RET		;DONE
* RTN. D.20
* NORMAL STATEMENT PROCESSOR
* A = NORMAL INDEX
NSPR	ADI	09FH	;ADD OFFSET TO FORM OPCODE
	STA	OPFLG	;SAVE IT
	CALL	ICBY	;INSERT IN STRING
	CALL	USCN	;CHECK FOR ANY EXPRESSION FOLLOWING
	JC	ENPR	;RETURN IF NOTHING FOLLOWS
	CALL	BSCN	;SCAN BACK TO WHENCE WE STARTED
NSPR1	CALL	EVEX	;PROCESS THIS EXPRESSION
	JMP	ENPR	;PROCESS END OF EXPRESSION
INTBL	DB	':'+80H
	DB	'GOT','O'+80H
	DB	'T','O'+80H
	DB	'STE','P'+80H
	DB	'THE','N'+80H
	DB	0A7H
	DB	0DCH	;BACKSLASH
	DB	'GOSU','B'+80H
	DB	'ELS','E'+80H
	DB	89H
* RTN. D.22
* PROCESS INTERMEDIARIES
PINT	LHLD	TSCN	;GET ADDRESS OF TOKEN
	LXI	D,INTBL	;GET ADDRESS OF TABLE OF INTERMEDIARYS
	LXI	B,10	;NUMBER OF ITEMS TO LOOK FOR
	CALL	STSRH
	MOV	A,C	;FIND # TO C
	RET		;DONE.
* RTN. D.21
* END OF STATEMENT PROCESSOR
* RETURNS IF END IS OK, GOES TO EXEC3 IF A COLON, 
* SYNTAX ERROR (10) OTHERWISE
ENPR	LDA	ESCN	;END OF LINE?
	CPI	2
	RZ		;YUP
ENPR2	CALL	PINT	;CHECK INTERMEDIATE CODE
	JNZ	EXEC3	;PROCESS AS STATEMENT
	CPI	2	;GOTO?
	JZ	EXEC3	;YUP
	CPI	8	;GOSUB?
	JZ	EXEC3	;YUP
	CPI	1	;COLON?
	MVI	B,9EH	;JUST IN CASE
	JZ	ENPR1	;YUP
	CPI	6	;REMARK
	JZ	PREM	;YUP
	CPI	7	;BACKSLASH?
	MVI	B,9DH	;JUST IN CASE
	JZ	ENPR1	;YUP
	CPI	10	;IS IT A TAB?
	MVI	B,9CH	;JUST IN CASE
	JZ	ENPR1	;YUP
	CPI	9	;ELSE?
	MVI	B,9BH	;JUST IN CASE
	JZ	ENPR1	;YUP
	JMP	SPRAT	;MUST BE ILLEGAL
ENPR1	MOV	A,B
	CALL	ICBY	;INSERT IT
	CALL	USCN	;GET THE NEXT TOKEN
	JC	SPRAT	;OUT OF DATA
	JMP	ENPR2	;TRY AGAIN
INTB	DW	INON
	DW	INGO
	DW	INFO
	DW	INGT
	DW	INGS
	DW	INIF
	DW	INRE
	DW	INCH
	DW	INON
	DW	INRT
* RTN. D.23
INRT	LDA	ESCN	;ARE WE NEAR THE END?
	CPI	2
	JZ	ENPR	;YUP
	CALL	INSN	;PROCESS THE STATEMENT NAME
	JMP	ENPR	;DONE
* PROCESS ODDBALL STATEMENTS
* IN: A = STATEMENT CODE
PROS	CPI	11	;IS IT REMARK?
	JNZ	PROS1	;NOPE
	MVI	A,7	;CORRECT
PROS1	PUSH	PSW	;SAVE THE CODE
	ADI	7FH	;ADD OFFSET
	STA	OPFLG
	CALL	ICBY	;INSERT IN CODE STRING
	POP	PSW	;RESTORE THE CODE
	MOV	E,A	;SET IN DE
	MVI	D,0
	LXI	H,INTB	;SET UP TO LOOKUP ADDRESS OF PROCESSOR
	CALL	TABLE	;LOOK IT UP
	MOV	L,C	;MOVE THE RESULT TO HL
	MOV	H,B
	PCHL		;JUMP TO THE PROCESSOR
ODTBL	DB	'O','N'+80H
	DB	'GOPRO','C'+80H
	DB	'FO','R'+80H
	DB	'GOT','O'+80H
	DB	'GOSU','B'+80H
	DB	'I','F'+80H
	DB	'RE','M'+80H
	DB	'CHANNE','L'+80H
	DB	'O','N'+80H
	DB	'RESTOR','E'+80H
	DB	'REMAR','K'+80H
NOTBL	DB	'GE','T'+80H
	DB	'PU','T'+80H
	DB	'ASSIG','N'+80H
	DB	'DAT','A'+80H
	DB	'DE','F'+80H
	DB	'DI','M'+80H
	DB	'DRO','P'+80H
	DB	'INPU','T'+80H
	DB	'LE','T'+80H
	DB	'EN','D'+80H
	DB	'NEX','T'+80H
	DB	'OU','T'+80H
	DB	'POK','E'+80H
	DB	'PRIN','T'+80H
	DB	'PROCEDUR','E'+80H
	DB	'REA','D'+80H
	DB	'RECEIV','E'+80H
	DB	'BSAV','E'+80H
	DB	'RETUR','N'+80H
	DB	'STO','P'+80H
	DB	'WAI','T'+80H
	DB	'CLEA','R'+80H
	DB	'BLOA','D'+80H
	DB	'BPU','T'+80H
	DB	'BGE','T'+80H
	DB	'OPE','N'+80H
	DB	'CLOS','E'+80H
	DB	'LOA','D'+80H
	DB	'SAV','E'+80H
	DB	'APPEN','D'+80H
	DB	'CHEC','K'+80H
	DB	'DI','R'+80H
	DB	'RENAM','E'+80H
	DB	'ERAS','E'+80H
	DB	'RESE','T'+80H
	DB	'MOVEBO','F'+80H
	DB	'MOVEEO','F'+80H
	DB	'WIDT','H'+80H
	DB	'KIL','L'+80H
*
CHCKA	CALL	CHCK	;CHECK INTEGRITY
	MOV	B,A	;SAVE TO B
	LDA	CHECK	;GET THE CHECK BYTE
	CMP	B	;COMPARE IT
	RZ		;IT'S OKAY, BASIC LIVES!
	LXI	H,CKMSG	;OOPS, A DESTROYED BIT OR TWO SOMEWHERE
	CALL	MSGER	;TELL THE OPERATOR
CHCKBC	JMP	CHCKBC	;DO IT AGAIN
CKMSG	DB	'BASIC IS CRASHED',8DH
*
* IF NOT READY TO RUN, GET END OF SOURCE IN H&L.
* IF READY TO RUN, GET END OF CTL STACK IN H&L.
*
SUBS	LDA	RURD	;IS RUN READY?
	ANA	A	;SET FLAGS
	LHLD	FRAV	;JUST IN CASE
	RZ		;NOPE
	LHLD	PNTR	;YUP
	RET		;DONE.
*
* RTN. D.24
* CHECK FOR STATEMENT
* JUMPS TO PROCESSOR IF IT IS A STATEMENT
CHST	LHLD	TSCN	;SET UP CASER
	SHLD	CASER
	LHLD	TSCN	;GET ADDRESS OF TOKEN
	XRA	A	;CLEAR A
	STA	STFLG	;CLEAR NOT STATEMENT FLAG
	MOV	A,M	;CHECK FOR ? FOR PRINT
	CPI	'?'+80H
	MVI	A,14	;PRINT ITEM NUMBER
	JZ	NSPR	;SURE WAS
	LXI	D,NOTBL	;GET ADDRESS OF TABLE OF NORMAL STATEMENTS
	LXI	B,39	;NUMBER OF NORMAL STATEMENTS
	CALL	STSRH	;SEARCH
	MOV	A,C	;CODE TO A
	JZ	NSPR	;FOUND
	LHLD	TSCN	;GET ADDRESS OF TOKEN
	LXI	D,ODTBL	;GET ADDRESS OF TABLE OF ODDBALL STATEMENTS
	LXI	B,11	;NUMBER OF ODDBALL STATEMENT TYPES
	CALL	STSRH	;SEARCH IT
	MOV	A,C	;GET CODE FOUND IF ANY
	JZ	PROS	;JUMP TO PROCESS ODDBALL STATEMENT
	MVI	A,0FFH	;SET NOT STATEMENT FLAG
	STA	STFLG	;SET IT
	RET		;NOT A STATEMENT
NCOMM	EQU	11	;NO. OF COMMANDS.
COTBL	DB	'CLEA','R'+80H
	DB	'CON','T'+80H
	DB	'DELET','E'+80H
	DB	'ENTE','R'+80H
	DB	'LIS','T'+80H
	DB	'NE','W'+80H
	DB	'RU','N'+80H
	DB	'EDI','T'+80H
	DB	'SYMBO','L'+80H
	DB	'BY','E'+80H
	DB	'CHANG','E'+80H
* RTN. D.25
* EXECUTIVE
RSTRT	LDA	CSST	;CHECK FOR CASSETTE MODE
	ANA	A	;SET FLAGS
	JNZ	EXCE1	;CASSETTE MODE
	CALL	CRLF	;PRINT HEAD TO THE LEFT
RSTRR	LXI	SP,STACK+100	 ;SET UP THE STACK POINTER
	LDA	CSST	;CHECK FOR CASSETTE MODE
	ANA	A
	JNZ	EXCE1	;CASSETTE MODE
	LDA	CMND	;CHECK FOR COMMAND MODE
	ANA	A	;SET FLAGS
	JZ	EXECA	;NOPE
	MVI	A,'>'	;COMMAND MODE PROMPT
	JMP	EXECB	;SKIP THE NEXT
EXECA	MVI	A,':'	;ENTER MODE PROMPT
EXECB	CALL	TOUT	;OUTPUT IT
EXCE1	CALL	SUBS	;GET END OF SOURCE
	LXI	D,100	;ADD 100 TO IT
	DAD	D
	MVI	M,80H	;CLEAR OUT A BYTE
	INX	H	;GET NEXT ADDRESS
	MVI	M,80H	;AND ANOTHER ONE
	INX	H	;UPDATE
	LDA	CSST	;CHECK FOR CASSETTE MODE
	STA	CATV	;STORE AS CASSETTE/TV MODE
	CALL	LIIN	;INPUT A LINE FROM THE KEYBOARD
	JNC	EXEC1	;SOMETHING WAS INPUTTED
	MVI	A,0FFH	;SET COMMAND MODE
	STA	CMND	;DONE
	LDA	CSST	;CHECK FOR CASSETTE MODE
	ANA	A
	JZ	RSTRT	;NOT CASSETTE MODE
	STC		;STOP MOTORS
	CALL	CAIN
EXCYY	XRA	A	;CLEAR CSST MODE
	STA	CSST
	STA	CATV
	STA	CHKEN	;CCLEAR ANY CHECK ENABLES
	JMP	STLOA2	;TRY AGAIN
EXEC1	LDA	CSST	;CHECK FOR CASSETTE MODE AND CHECK
	MOV	B,A	;SAVE IT
	LDA	CHKEN	;GET CHECK FLAG
	ANA	B	;LOGICAL AND
	JNZ	RSTRR	;SURE IS, SO GO GET ANOTHER LINE
	XRA	A	;CLEAR A
	STA	ESCN	;CLEAR END OF SCAN FLAG
	CALL	SUBS	;SET UP NEXT SCAN AND SOURCE LINE FLAGS
	LXI	D,101
	SHLD	SLIN	;SOURCE LINE FLAG
	DAD	D
EXE77	SHLD	NSCN	;NEXT SCAN FLAG
	CALL	USCN	;UPSCAN TWICE TO GET FIRST TOKEN
	CALL	USCN	;AGAIN
	LHLD	TSCN	;GET ADDRESS OF THIS TOKEN
	MOV	A,M	;CHECK FOR COLON
	CPI	':'+80H
	LXI	B,4	;CHECK FIND NUMBER JUST IN CAST
	JZ	EXE80	;SURE WAS
	LXI	D,COTBL	;TABLE OF COMMANDS
	LXI	B,NCOMM	;NUMBER OF COMMANDS TO DECODE
	CALL	STSRH	;SEARCH THE COMMAND TABLE
	JNZ	EXEC3	;WASN'T A COMMAND
EXE80	LXI	H,COJMP	;TABLE OF COMMAND PROCESSING ENTRANCES
	MOV	D,B	;MOVE BC TO DE
	MOV	E,C
EXE88	CALL	TABLE	;GET ADDRESS
	MOV	H,B	;MOVE BC TO HL
	MOV	L,C
	MVI	A,0FFH	;SET COMMAND MODE
	STA	CMND
	PCHL		;JUMP TO PROCESS COMMAND 
EXEC3	CALL	CHST	;CHECK TO SEE IF THIS TOKEN IS A STATEMENT
	LDA	STFLG	;GET STATEMENT FLAG
	ANA	A	;SET FLAGS
	JNZ	EXEC4	;WASN'T A STATEMENT
	JMP	CLPR	;PROCESS THE CODED LINE
EXEC4	LHLD	TSCN	;GET ADDRESS
	MOV	A,M	;GET CHARACTER
	CPI	89H	;IS IT A TAB?
	JZ	EXECTAB	;YUP
	CALL	BSCN	;SCAN BACK
	LHLD	NSCN	;CHECK FOR = SIGN
EX000	MOV	A,M	;GET A BYTE
	ANA	A	;CHECK FOR END REACHED
	JNZ	EX000Z	;NOPE
	MVI	M,80H	;STUFF AN 80H
	JZ	EXEC5	;YUP
EX000Z	CPI	09H	;TAB?
	JZ	EX0001	;YUP
	CPI	20H
	JNZ	EXXZZ	;NOT A SPACE
EX0001	INX	H	;CHECK FOR = NEXT
	MOV	A,M	;GET A BYTE
	ANI	7FH	;STRIP END BIT
	CPI	'='
	JNZ	EXEC5	;NOT A "LET" STATEMENT
	DCX	H
EXXZZ	INX	H	;NEXT BYTE
	CPI	'='	;CHECK FOR THE EQUALS SIGN
	JNZ	EX000	;TRY AGAIN
INIF4	MVI	A,0A8H	;CODE FOR "LET" STATEMENT
	LXI	H,EXEC3+3	 ;RETURN ADDRESS
	PUSH	H	;ONTO THE STACK
	LXI	H,STFLG	;CLEAR OUT THE STATEMENT FLAG
	MVI	M,0
	STA	OPFLG	;STORE CODE
	CALL	ICBY	;INSERT IN LINE
	JMP	NSPR1	;PROCESS THE LET STATEMENT
EXEC5	LDA	CMND	;CHECK FOR MODE
	ANA	A	;SET FLAGS
	MVI	B,8	;POSSIBLE ERROR
	JNZ	ERROR	;NO LABELS IN COMMAND MODE!
	CALL	USCN	;GET EVERYTHING BACK TO NORMAL
	CALL	LGLB	;CHECK FOR LABEL LEGALITY
	MVI	B,7	;POSSIBLE ERROR
	JC	ERROR	;ILLEGAL LABEL
	MVI	A,9FH	;GET STATEMENT OPCODE
	CALL	ICBY	;INSERT IT
	MVI	A,6	;START OF STATEMENT NAME CODE
	CALL	ICBY	;INSERT IT
	LHLD	TSCN	;GET TOKEN ADDRESS
	MVI	A,1	;STATEMENT NAME CODE
	CALL	GTNM	;GET THE SYMBOL NUMBER
	PUSH	B
	MVI	B,7	;POSSIBLE ERROR
	JC	ERROR	;STATEMENT NAME USED AS VARIABLE NAME
	POP	B
	MOV	A,C	;MOVE SYMBOL NUMBER INTO CODE LINE
	MOV	L,C
	MOV	H,B
	SHLD	EDITS
	LXI	H,0
	SHLD	EDITO	;CLEAR THE OFFSET OUT TOO.
	CALL	ICBY
	MOV	A,B
	CALL	ICBY
	MVI	A,7
	CALL	ICBY
	CALL	USCN	;GET NEXT TOKEN
	JC	SPRAT	;ERROR IF ONLY A LABEL
	JMP	EXEC3	;GET REST OF STATEMENT
EXECTAB	MVI	A,9CH	;STORE THE OPCODE
	CALL	ICBY
	CALL	USCN	;GET NEXT TOKEN
	JMP	EXEC3	;DO IT
PRSY	LXI	H,PRSYMSG1	;DUMP THE TITLE OUT
	CALL	MSGER
	LDA	RURD	;SEE IF WE ARE ALREADY SET UP
	ANA	A
	JNZ	PRSYSKIP	;YUP
	CALL	ASDA	;SET IT ALL UP
	CALL	AVAP
PRSYSKIP	LHLD	SNUM	;GET NUMBER OF SYMBOLS
	MOV	B,H	;TO BC
	MOV	C,L
	LHLD	SDIR	;GET START OF DIRECTORY
	PUSH	H	;TO THE STACK
	LHLD	STAB	;GET START OF THE SYMBOL TABLE
PRSY1	CALL	COUNT	;ADVANCE ONE SYMBOL
	DAD	D
	MOV	A,M	;GET A BYTE
	ANA	A
	JNZ	PRSY1A	;NOT AN ARRAY NAME
	INX	H
PRSY1A	XTHL		;ADVANCE THE DIRECTORY
	INX	H
	INX	H
	INX	H
	XTHL		;DID THAT
	DCX	B	;UPDATE SYMBOL COUNT
	MOV	A,B	;CHECK FOR DONENESS
	ORA	C
	JZ	RSTRT	;ALL DONE PEOPLE
	PUSH	H
	PUSH	D
	PUSH	B
	CALL	CONT	;CHECK FOR CONTROL C PUSHED
	POP	B
	POP	D
	POP	H
	JZ	RSTRT	;ABORT
	PUSH	B	;SAVE EM
	PUSH	H
	CALL	MSGER	;DUMP THE LABEL NAME
PRSY2	LDA	POSIT	;SEE IF WE'RE AT THE COLUMN YET
	CPI	32
	JZ	PRSY3	;YUP
	MVI	A,20H
	CALL	TOUT	;NO, SO DUMP A SPACE
	JMP	PRSY2	;TRY AGAIN
PRSY3	POP	H	;RESTORE
	POP	B
	XTHL		;GET DIRECTORY
	INX	H
	INX	H
	PUSH	H	;SAVE IT
	PUSH	B
	MOV	A,M	;GET ID BYTE
	ANI	4	;CHECK FOR FUNCTION
	JNZ	PRSY3AA	;SURE WAS
	MOV	A,M
	ANI	1	;IS IT LABEL?
	JNZ	PRSY3A	;YUP
	MOV	A,M
	ANI	2	;IS IT A VARIABLE?
	JNZ	PRSY3B	;YUP
	LXI	H,PRSYMSG2
	JMP	PRSY3C
PRSY3AA	LXI	H,PRSYMSG5
	JMP	PRSY3C
PRSY3A	LXI	H,PRSYMSG3
	JMP	PRSY3C
PRSY3B	LXI	H,PRSYMSG4
PRSY3C	CALL	MSGER
	POP	B
	POP	H	;GET BACK LOCATION
	DCX	H
	MOV	D,M	;FISH OUT THE POINTER
	DCX	H
	MOV	E,M
	PUSH	H	;SAVE IT
	XCHG
	PUSH	B
	LXI	D,TMP1	;CONVERSION PLACE
	CALL	BBCD	;CONVERT TO BINARY
	LHLD	FRAV	;GET PLACE TO CONVERT TO
	XCHG
	LXI	H,TMP1
	CALL	NMST	;CONVERT TO NUMBER
	XCHG
	DCX	H
	MOV	A,M	;SET LAST BIT
	ORI	80H
	MOV	M,A
	LHLD	FRAV
	CALL	MSGER	;DUMP IT OUT
	CALL	CRLF	;SEND A CARRIAGE RETURN
	POP	B
	POP	H	;RESTORE ADDRESS
	XTHL		;TRADE
	JMP	PRSY1	;DO IT AGAIN
* RTN. D.26
* ON STATEMENT PROCESSOR
INON	LHLD	SLIN	;SAVE ADDRESS OF OPCODE
	PUSH	H
	CALL	EVEX	;PROCESS EXPRESSION
	CALL	PINT	;CHECK FOR "GOTO"
	CPI	2
	JZ	INON1	;IT'S A GOTO
	CPI	8	;CHECK FOR A GOSUB
	JNZ	SPRAT	;NOPE, SO ERROR
	POP	H	;CHANGE OPCODE
	DCX	H
	MVI	M,88H	;STORE THE NEW ONE
	PUSH	H	;SET STACK UP
INON1	POP	H	;CLEAN UP THE STACK
	CALL	PLDL	;PROCESS LINE DESCRIPTOR LIST
	JMP	ENPR	;END OF LINE PROCESSING
* RTN. D.27 
* GOPROC STATEMENT PROCESSOR
INGO	CALL	INSN	;PROCESS THE STATEMENT NAME
	JC	ENPR	;NO TRANSFER LIST
	LHLD	TSCN	;CHECK FOR COLON FOLLOWING
	MOV	A,M
	CPI	':'+80H	;IT WILL HAVE END BIT SET
	JZ	ENPR	;SURE WAS
	CALL	SCCC	;CHECK FOR COMMA
	CPI	0DH	;COMPARE
	MVI	B,10H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;SYNTAX ERROR
	CALL	EVEX	;PROCESS EXPRESSION
	JMP	ENPR	;END PROCESSOR
* RTN. D.28
* INSERT STATEMENT NAME
INSN	JMP	PLDS	;USE PROCESS LINE DESCRIPTOR ROUTINE
* RTN. D.29
* FOR STATEMENT PROCESSOR
INFO	MVI	A,0A8H	;GET CODE FOR "LET" STATEMENT
	STA	OPFLG	;SET ASSIGNMENT MODE FOR =
	CALL	EVEX	;EVALUATE THE EXPRESSION
	CALL	PINT	;CHECK FOR "TO"
	CPI	3	;CHECK IT
	MVI	B,19H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;NO "TO"
	CALL	EVEX	;GET THE NEXT PART
	CALL	PINT	;SEE IF THERE IS A "STEP"
	CPI	4	;COMPARE CODES
	JNZ	ENPR	;NOPE, WE MUST BE DONE
	CALL	EVEX	;GET THE STEP INTERVAL
	JMP	ENPR	;DONE
* RTN. D.30
* GOTO STATEMENT PROCESSOR
INGT	CALL	INSN	;GET STATEMENT NAME
	JMP	ENPR	;DONE
* RTN. D.31
* GOSUB STATEMENT PROCESSOR
INGS	JMP	INGO	;SAME AS GOTO
* RTN. D.31
* IF STATEMENT PROCESSOR
INIF	CALL	EVEX	;GET EXPRESSION
	CALL	PINT	;GET CODE FOR INTERMEDIARY
	CPI	2	;IS IT A "GOTO"?
	JZ	EXEC3	;SO GET THE NAME
	CPI	5	;IS IT A "THEN"?
	JNZ	SPRAT	;SYNTAX ERROR
	CALL	USCN	;SCAN OFF ANOTHER TOKEN
	JC	SPRAT	;NOTHING FOLLOWING, SYNTAX ERROR
	CALL	CHST	;CHECK TO SEE IF THE TOKEN IS A STATEMENT
	LDA	STFLG	;CHECK IT OUT
	ANA	A
	JZ	CLPR	;IT WAS A STATEMENT, SO PROCESS IT
	CALL	BSCN	;CHECK FOR "=" SIGN
	LHLD	NSCN
INIF1	MOV	A,M	;GET A BYTE
	ANA	A	;CHECK FOR END REACHED
	JNZ	INIF133	;NOPE
	MVI	M,80H	;STUFF AN 80
	JZ	INIF2	;YUP
INIF133	CPI	9	;TAB?
	JZ	INIF100	;YUP
	CPI	20H	;CHECK FOR SPACE
	JNZ	INIF3	;NOPE
INIF100	INX	H	;CHECK FOR "=" NEXT
	MOV	A,M	;GET IT
	ANI	7FH	;STRIP END BIT
	CPI	'='	;CHECK IT OUT
	JNZ	INIF2	;NOT A LET STATEMENT
	DCX	H	;CORRECT INDEX
INIF3	INX	H
	CPI	'='	;CHECK FOR = SIGN
	JNZ	INIF1	;TRY AGAIN
	JMP	INIF4	;PUT IN THE LET STATEMENT
INIF2	CALL	USCN	;CORRECT IT
	MVI	A,83H	;SET IN THE GOTO CODE
	CALL	ICBY	;INSERT THE CODE BYTE
	CALL	BSCN	;BACK OFF, JACK
	XRA	A	;CLEAR THE STATEMENT FLAG
	STA	STFLG
	JMP	INGT	;PROCESS AS GOTO
* RTN. D.33
* REMARKS PROCESSOR
INRE	JMP	PREM	;DO IT THIS WAY
* RTN. D.34
* CHANNEL PROCESSOR
INCH	CALL	EVEX	;PROCESS EXPRESSION
	JMP	ENPR	;DONE
*
* RTN. D.35
* GET INCREMENT
* DETERMINE HOW MANY BYTES IN ITEM AT H&L.
* RETURN WITHH NO. OF BYTES IN D&E.
*
GTIN	LXI	D,1	;PRESET INCREMENT TO MINIMUM
	MOV	A,M	;GET THE BYTE
	CPI	8	;IS A>=8?
	RNC		;YUP
	PUSH	H	;SAVE ADDRESS
	ANA	A	;IS A=0?
	JZ	GTIN2	;YUP
	DCR	A	;IS A=1?
	JZ	GTIN3	;YUP
	CPI	3	;IS A=4?
	JZ	GTIN4	;YUP
	CPI	4	;IS A=4?
	JZ	GTIN4	;YUP
	LXI	D,4	;LABEL NUMBER
	POP	H	;RESTORE ADDRESS
	RET		;DONE
GTIN4	LXI	D,8	;NUMBER
	POP	H	;RESTORE ADDRESS
	RET		;DONE
GTIN3	DCX	H	;UPDATE INDEX
	INX	D	;UPDATE COUNTER
	MOV	A,M	;GET A BYTE
	ANA	A	;IS IT A ZERO?
	JNZ	GTIN3	;NOPE
	POP	H	;RESTORE ADDRESS
	RET		;DONE
GTIN2	INX	H	;UPDATE INDEX
	INX	D	;UPDATE COUNTER
	MOV	A,M	;GET A BYTE
	CPI	1	;IS IT A ONE?
	JNZ	GTIN2	;NOPE
	POP	H	;RESTORE ADDRESS
	RET		;DONE
* RTN. D.36
* MOVE FORWARD ONE STATEMENT IN SOURCE
* TSCN CONTAINS ADDRESS OF CURRENT STATEMENT
MFOS	LHLD	LINE	;GET CURRENT STATEMENT
	INX	H	;GET NEXT BYTE
MFOS2	XCHG		;TO DE
	LHLD	ESRC	;CHECK FOR RUNOVER
	CALL	CMP16	;COMPARE
	JZ	MFOS1	;YUP
	LHLD	SLIN	;DIRECT MODE
	CALL	CMP16
	JZ	MFOS1	;YUP
	XCHG		;BACK TO HL
	MOV	A,M	;CHECK FOR A STATEMENT HERE
	ANA	A	;IS IT ANOTHER STATEMENT
	JM	MFOS1	;YUP
MFOS1A	CALL	GTIN	;NOPE
	DAD	D	;ADD INCREMENT
	JMP	MFOS2	;LOOP TO TRY AGAIN
MFOS1	SHLD	LINE	;SAVE IT
	XCHG		;TO DE
	LHLD	FSRC	;SEE IF WE'RE WITHIN THE PROGRAM
	DCX	H	;CORRECT
	CALL	CMP16	;CHECK IT OUT
	JNC	MFOS3	;NO GOOD
	LHLD	ESRC	;CHECK FOR WITHIN STORED PROGRAM
	CALL	CMP16	;CHECK IT OUT
	XCHG		;GET LINE BACK TO HL
	RNC		;GOOD FOR SURE
	XCHG		;BACK TO DE
	LHLD	FRAV	;CHECK FOR DIRECT MODE LEAP
	DCX	H	;CORRECT
	CALL	CMP16	;CHECK IT OUT
	JNC	MFOS3	;NO GOOD
	LHLD	SLIN	;AGAIN
	CALL	CMP16	;CHECK IT OUT
	XCHG		;TO HL
	RNC		;IT'S GOOD FOR SURE
MFOS3	MVI	B,7	;ERROR TYPE
	LHLD	ESRC	;RESET LINE
	SHLD	LINE
	JMP	ERROR	;GO DO IT
* RTN. D.37
* MOVE BACKWARDS ONE STATEMENT IN SOURCE
MBOS	LHLD	LINE	;GET CURRENT STATEMENT
	DCX	H	;GET LAST ONE
MBOS1	MOV	A,M	;GET A BYTE
	ANA	A	;SET FLAGS
	JM	MFOS1	;FOUND THE LAST STATEMENT
MBOS1A	CALL	GTIN	;GET THE INCREMENT
	CALL	SUB16	;HL=HL-DE
	JMP	MBOS1	;LOOP TO TRY AGAIN
* RTN. D.38
* ASSIGN STATEMENT AND DEF ADDRESSES
ASDA	LHLD	ESRC	;STORE THE FAKE END
	MVI	M,0FFH	
	LHLD	SNUM	;NUMBER OF SYMBOLS
	XCHG		;TO DE
	LHLD	SDIR	;SYMBOL DIRECTORY
ASD00	INX	H	;GET ID BYTE
	INX	H
	MVI	A,5	;CHECK FOR DEF OR STATEMENT
	ANA	M
	JZ	ASD01	;NOPE
	DCX	H	;STORE A 0
	MVI	M,0
	DCX	H
	MVI	M,0
	INX	H
	INX	H
ASD01	INX	H	;GET NEXT ONE
	DCX	D	;CHECK FOR DONENESS
	MOV	A,D
	ORA	E
	JNZ	ASD00	;NOT YET
	LHLD	FSRC	;SET UP LIN FLAG
	SHLD	LINE
ASDA1	MOV	A,M	;GET STATEMENT BYTE
	CPI	9FH	;IS THIS A STATEMENT NAME?
	JZ	ASDA3	;YUP
	CPI	0A4H	;IS THIS A DEF FNXXX STATEMENT?
	JZ	ASDA2	;YUP
ASDA4	XCHG		;HL TO DE
	LHLD	ESRC	;GET END OF SOURCE ADDRESS
	CALL	CMP16	;SEE IF WE ARE DONE YET
	RZ		;YUP
ASDAQ	CALL	MFOS	;GET NEXT STATEMENT
	JMP	ASDA1	;LOOP TO PROCESS IT
ASDA3	INX	H	;GET ADDRESS OF STATEMENT NAME NUMBER
	INX	H
	MOV	C,M	;GET NUMBER TO BC
	INX	H
	MOV	B,M
	CALL	DFND	;GET THE ADDRESS OF POINTER
	MOV	A,H	;CHECK FOR POINTER = 0
	ORA	L
	JNZ	ASD20	;DUPLICATE NAME ERROR
ASDAM	LXI	H,LINE	;ADDRESS OF LINE POINTER
	LXI	B,2	;NUMBER OF BYTES
	DCX	D
	DCX	D
	CALL	MOVE	;MOVE THE NUMBER IN
	JMP	ASDAQ	;LOOP FOR NEXT STATEMENT
ASDA2	INX	H	;GET ADDRESS OF SYMBOL LABEL
	INX	H
	MOV	A,M	;GET THE ID BYTE
	CPI	2	;CHECK IT
	MVI	B,10H	;ERROR CODE JUST IN CASE
	JNZ	ERROR	;SYNTAX ERROR
	INX	H	;GET NUMBER ADDRESS
	MOV	C,M	;GET THE NUMBER
	INX	H	
	MOV	B,M
	CALL	DFND	;FIND THE POINTER ADDRESS
	MOV	A,H	;CHECK FOR POINTER = 0
	ORA	L
	JNZ	ASD10	;DUPLICATE FNXX ERROR
	JMP	ASDAM	;CONTINUE PROCESSING
* RTN. D.39
* ASSIGN VARIABLE AND ARRAY POINTER SPACE
AVAP	LXI	B,1	;SET UP FOR FIRST SYMBOL
	LHLD	SDIR	;SET UP FARY
	SHLD	FARY
	LHLD	ESRC	;GET FIRST ADDRESS FOR VARIABLES
AVAP3	PUSH	H	;SAVE IT
AVAP1	CALL	DFND	;FIND THE POINTER
	CPI	2	;IS IT A VARIABLE?
	JZ	AVAP4	;YUP
	CPI	16	;IS IT AN ARRAY?
	JZ	AVAP2	;YUP
AVAPD	MOV	D,B	;BC TO DE
	MOV	E,C
	LHLD	SNUM	;SEE IF WE ARE DONE YET
	INX	B	;UPDATE SYMBOL NUMBER
	CALL	CMP16	;CHECK
	JNZ	AVAP1	;NOPE
	POP	H	;GET ADDRESS BACK
	SHLD	FRAV	;SAVE NEXT AVAILABLE
	RET		;DONE
AVAP4	PUSH	D
	PUSH	B
	LHLD	STAB	;GET START OF SYMBOL TABLE
AVAP41	CALL	COUNT
	DAD	D
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	AVAP41	;LOOP TILL WE FIND IT
	DCX	H
	MOV	A,M
	CPI	'$'+80H	;SEE IF IT'S A DOLLAR SIGN
	POP	B
	POP	D
	JNZ	AVAP2	;REGULAR VARIABLE
	POP	H	;RESTORE
	PUSH	B	;SAVE
	PUSH	D	;SAVE
	PUSH	H	;SAVE
	XCHG		;STORE THE POINTER
	DCX	H
	MOV	M,D
	DCX	H
	MOV	M,E
	XCHG
	MVI	A,81H	;ID BYTE
	INX	H
	INX	H
	INX	H	;BACKPOINTER ADDRESS
	XCHG
	LXI	H,1
	CALL	AMBL	;ASSIGN MEMORY BLOCK FOR STRING
	MVI	M,80H	;STORE A NULL
	XCHG		;ADDRESS TO DE
	POP	H	;RESTORE BLOCK ADDRESS
	MVI	M,8	;STORE BLOCK ID
	INX	H	;UPDATE
	INX	H
	INX	H
	MOV	M,E	;STORE POINTER
	INX	H
	MOV	M,D
	INX	H
	INX	H	;CORRECT NEXT ADDRESS
	POP	D	;RESTORE
	POP	B
	PUSH	H	;SAVE
	JMP	AVAPD
AVAP2	POP	H	;GET ADDRESS BACK
	XCHG		;FREE HL
	DCX	H	;GET POINTER ADDRESS
	MOV	M,D	;STORE THE ADDRESS
	DCX	H
	MOV	M,E
	XCHG		;GET HL BACK
	MVI	A,6	;ZERO OUT 6 BYTES
AVAPA	MVI	M,0FFH	;STORE A FILLER
	INX	H	;UPDATE
	DCR	A
	JNZ	AVAPA
	PUSH	H	;STUFF IT ON THE STACK
	JMP	AVAPD	;LOOP FOR THE NEXT ONE
ASD20	CALL	ASD30	;PRINT THE SYMBOL
	MVI	B,20H	;DUPLICATE STATEMENT ERROR
	LXI	H,ASD40	;PRINT DUP STATEMENT MESSAGE
	CALL	MSGER
	JMP	ASDAQ	;GET NEXT SYMBOL
ASD10	CALL	ASD30	;PRINT THE SYMBOL
	MVI	B,21H	;DUPLICATE FNXX ERROR
	LXI	H,ASD50	;PRINT DUP DEF MESSAGE
	CALL	MSGER
	JMP	ASDAQ	;GET NEXT SYMBOL
ASD30	PUSH	B	;SAVE SYMBOL NUMBER
	MVI	A,0DH	;SEND A CARRIAGE RETURN
	CALL	TOUT
	POP	B	;RESTORE SYMBOL NUMBER
	LXI	H,TMP9	;STORE AS A TOKEN
	MVI	M,2
	INX	H
	MOV	M,C
	INX	H
	MOV	M,B
	LXI	H,TMP9	;DUMP IT
	CALL	PRIT
	RET
ASD40	DB	' DUP STATE N','M'+80H
ASD50	DB	' DUP DE','F'+80H
COLON	DB	':'+80H
*
LINK10	LINK	B:TBASIC11
