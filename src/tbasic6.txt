*
*
* TARBELL BASIC SOURCE MODULE #6
* COPYRIGHT (C) 1978 TARBELL ELECTRONICS
*
* MATH MODULE
* RTN. B.22 
* CONVERT INTEGER TO FLOATING POINT
* (HL) TO (DE)
*
INFL	PUSH	D	;SAVE LOCATIONS
	PUSH	H
	LXI	D,WORK1	;GET ADDRESS TO UNPACK INTO
	MVI	B,5	;NUMBER OF BYTES TO UNPACK
	INX	H	;GET THE MANTISSA LOCATION
	CALL	UNPK	;UNPACK THE INTEGER
	MVI	A,10	;SET UP TO CLEAR SOME MEMORY
	XCHG		;GET ADDRESS TO HL
	CALL	ZERO	;CLEAR 10 BYTES AFTER UNPACKED NUMBER
	LXI	H,WORK1	;GET ADDRESS OF FIRST UNPACKED DIGIT
	MVI	B,9H	;A BCD 9 TO B
INFL1	MOV	A,M	;GET A BYTE
	ANA	A	;SET FLAGS
	JNZ	INFL2	;AH, A SIGNIFICANT DIGIT!!
	MVI	A,99H	;SUBTRACT 1 FROM B, IN BCD
	ADD	B
	DAA		;BCD ADJUST
	MOV	B,A	;STUFF IT BACK
	INX	H	;UPDATE INDEX
	JC	INFL1	;LOOP IF B IS NOT 0 YET
	MVI	B,0	;SEND A REAL 0 TO B
INFL2	POP	D	;GET INTEGER LOCATION
	LDAX	D	;GET SIGNS BYTE
	ORI	1	;SET LSB FOR FLOATING POINT ID
	POP	D	;GET RESULT DESTINATION
	STAX	D	;STORE ID BYTE
	INX	D	;GET LOCATION FOR EXPONENT
	MOV	A,B	;EXPONENT TO B
	STAX	D	;STORE IT
	INX	D	;LOCATION FOR MANTISSA
	MVI	C,4	;NUMBER OF BYTES
	CALL	PACK	;PACK IN THE MANTISSA
	RET		;DONE
* RTN. B.23
* CONVERT FLOATING POINT TO INTEGER
* (HL) TO (DE)
FLIN	PUSH	D	;SAVE DESTINATION
	LXI	D,TMP11	;MOVE THE NUMBER DOWN
	LXI	B,6	;NUMBER OF BYTES
	CALL	MOVE
	XCHG		;NEW SOURCE TO HL
	POP	D	;GET DESTINATION BACK
	MOV	A,M	;GET SIGNS BYTE
	ANI	0BEH	;CONVERT TO INTEGER FORMAT
	STAX	D	;STORE IT
	MOV	A,M	;GET SIGNS BYTE AGAIN
	ANI	40H	;STRIP OFF EXPONENT SIGN BIT
	JNZ	FLIN1	;JUMP IF IT IS
	INX	H	;GET EXPONENT ADDRESS
	MOV	A,M	;GET IT
	CPI	10H	;SEE IF IT'S GREATER THAN 9 BCD
	JNC	FLIN2	;YUP, SO OVERFLOW
	MOV	B,A	;SAVE IT TO B
	MVI	A,9	;SET UP SUBTRACT
	PUSH	D	;SAVE DESTINATION
	SUB	B	;SUBTRACT FOR AMOUNT TO SHIFT
	PUSH	PSW	;SAVE IT
	INX	H	;GET MANTISSA LOCATION
	LXI	D,WORK1+8	;SET UP TO MOVE MANTISSA
	LXI	B,4	;NUMBER OF BYTES TO MOVE
	CALL	MVDN	;MOVE IT
	XCHG		;GET ADDRESS TO HL
	POP	PSW	;GET NUMBER OF PLACES TO SHIFT
	CALL	SHFT	;SHIFT
	POP	D	;GET DESTINATION BACK
	INX	D	;GET MANTISSA LOCATION
	LXI	B,5	;NUMBER OF BYTES TO MOVE
	CALL	MVDN	;MOVE THEM IN
FLIN4	LDA	TMP11	;CHECK FOR NEGATIVE INPUT
	ANA	A
	RP		;NOPE
	DCX	D
	LXI	H,ONEEE	;GET CONSTANT
	XCHG	
	MOV	C,L
	MOV	B,H
	CALL	SUBER	;SUBTRACT
	RET
FLIN1	XCHG		;GET DESTINATION ADDRESS TO HL
	INX	H	;GET MANTISSA LOCATION
	PUSH	H	;SAVE MANTISSA DESTINATION
	MVI	A,5	;NUMBER OF BYTES
	CALL	ZERO	;CLEAR THEM OUT
	POP	D	;GET DESTINATION BACK
	JMP	FLIN4
FLIN2	MVI	A,1	;SET OVERFLOW FLAG
	STA	MERR
	RET		;DONE
* RTN. B.24
* CONVERT BCD EXPONENT TO BINARY
* TWO DIGIT BCD NUMBER IN "A" IS CONVERTED TO BINARY
* IN "A". NO OTHER REGISTERS DISTURBED
* METHOD CONTRIBUTED BY SAM SINGER
BCDBN	PUSH	B	;SAVE BC
	MOV	B,A	;SAVE THE DIGITS
	ANI	0F0H	;MASK OUT THE MSD
	RAR		;EQUIVALENT TO DIGIT * 8
	MOV	C,A	;SAVE IT
	RAR		;RIGHT SHIFT TO DIVIDE
	RAR		;BY 4
	ADD	C	;DIGIT*8+DIGIT*2=DIGIT*10
	MOV	C,A	;SAVE IT
	MOV	A,B	;GET ORIGINAL DIGITS
	ANI	0FH	;MASK OUT THE LSB
	ADD	C	;ADD MSB*10
	POP	B	;RESTORE BC
	RET		;DONE.
* THANKS, SAM
* RTN. B.25
* CONVERT NUMBER TO EQUIVALENT SIGN
* (HL) TO (DE)
* IF (HL)>0, (DE) WILL BE +1
* IF (HL)=0, (DE) WILL BE  0
* IF (HL)<0, (DE) WILL BE -1
SIGN	MOV	A,M	;GET THE ID BYTE
	PUSH	D	;SAVE DESTINATION ADDRESS
	LXI	D,TMP11	;CONVERSION REGISTER
	ANI	0BEH	;STRIP OFF FLOATING POINT BITS
	STAX	D	;STORE TO NEW LOCATION
	MVI	B,4	;SET UP BYTE COUNTER
SIGN1	INX	H	;UPDATE INDEXES
	INX	D
	MOV	A,M	;GET A BYTE
	ANA	A	;SET FLAGS
	JNZ	SIGN2	;JUMP OUT OF LOOP IF NONZERO
	STAX	D	;STORE A ZERO BYTE
	DCR	B	;CHECK BYTE COUNTER
	JP	SIGN1	;LOOP IF NOT DONE YET
	JMP	SIGN9	;DONE IF 'TWAS ALL ZEROES
SIGN2	DCR	B	;SEE IF WE ARE ON THE LAST BYTE YET
	JM	SIGN3	;YUP, SO GO STORE A ONE
	XRA	A	;CLEAR A
	STAX	D	;STORE THE ZERO
	JMP	SIGN1+1	;LOOP FOR ANOTHER BYTE
SIGN3	MVI	A,1	;SET UP FOR STORING LAST BYTE
	STAX	D	;DO IT
SIGN9	POP	D	;MOVE NUMBER TO DESTINATION
	LXI	H,TMP11
	LXI	B,6
	CALL	MOVE
	RET		;DONE.
* RTN. B.26
* INTEGER FUNCTION
* INT(HL) TO (DE)
INTG	MOV	A,M	;CHECK TO SEE IF (HL) IS INTEGER ALREADY
	ANI	1	;STRIP OFF THE INTEGER/FLOATING BIT
	JZ	INTG1	;LEAP IF (HL) IS ALREADY AN INTEGER
	CALL	FLIN	;CONVERT TO INTEGER
	RET		;DONE
INTG1	LXI	B,6	;NUMBER OF BYTES
	CALL	MVDN	;MOVE THE INTEGER TO NEW LOCATION
	RET		;AH, FINI.
* RTN. B.27
* ABSOLUTE VALUE FUNCTION
* ABS(HL) TO (DE)
ABSLT	MOV	A,M	;GET ID BYTE
	ANI	7FH	;STRIP OFF MANTISSA SIGN BIT
	STAX	D	;STORE IT TO NEW LOCATION
	INX	D	;GET MANTISSA LOCATIONS
	INX	H
	LXI	B,5	;NUMBER OF BYTES
	CALL	MVDN	;MOVE MANTISSA (AND) EXPONENT IN
	RET		;DONE. (WHY CAN'T THEY ALL BE THIS EASY??)
* RTN. B.28
* CONVERT ASCII STRING AT (HL) TO NUMBER AT (DE)
* CARRY SET ON EXIT IF ERROR OCCURED
* ON EXIT HL IS ADDRESS OF NEXT STRING ELEMENT
STNM	MOV	A,M	;CHECK IT OUT
	ANI	7FH
	CPI	2DH	;CHECK FOR MINUS SIGN
	JZ	P1	;YUP
	CPI	'.'
	JZ	P1
	CPI	3AH
	STC
	RP
	CPI	30H
	RC
P1	PUSH	H	;SAVE LOCATIONS
	PUSH	D
	MVI	A,0FFH	;PRESET COUNTERS
	STA	CNVR1
	STA	CNVR2
	MVI	A,11	;NUMBER OF BYTES
	PUSH	H	;SAVE AGAIN
	LXI	H,WORK1	;ADDRESS OF BUFFER
	CALL	ZERO	;CLEAR IT
	POP	H	;GET ADDRESS BACK
	STA	CNVR3	;CLEAR ZERO COUNTER
	LXI	D,WORK1	;GET BUFFER ADDRESS
	LXI	B,02H	;PRESET DIGIT COUNTER AND SIGNS
STNM5	MOV	A,M	;GET AN ASCII BYTE
	ANI	7FH	;STRIP UPPER BIT
	CPI	'-'	;SEE IF IT'S A MINUS SIGN
	JZ	STNM1	;SURE WAS
	CPI	'.'	;SEE IF IT'S A PERIOD
	JZ	STNM3	;YUP
	CPI	'E'	;SEE IF IT'S AN E
	JZ	STNMA	;LOOKS THAT WAY
	CPI	'0'	;SEE IF IT'S MAYBE A DIGIT
	JM	STNM4	;'PEARS NOT TO BE
	CPI	'9'+1	;IS IT STILL A DIGIT?
	JP	STNM4	;NOPE
	SUI	30H	;STRIP ASCII OFFSET
	JNZ	STNM6	;GO STORE IT
	LDA	WORK1	;SEE IF WE ARE INTO INSIGNIFICANT ZEROES
	ANA	A	;SET FLAGS
	MVI	A,0	;RESTORE THE ZERO
	JNZ	STNM6	;GO STORE IT
	LDA	CNVR3	;INCREMENT THE LEADING ZEROES COUNTER
	INR	A
	STA	CNVR3
STNM7	INX	H	;GET THE NEXT ASCII CHARACTER
	JMP	STNM5	;LOOP TO PROCESS
STNM6	STAX	D	;STORE THE CHARACTER IN THE BUFFER
	INX	D	;UPDATE INDEX
	INR	B	;UPDATE DIGIT COUNTER
	JMP	STNM7	;GO GET NEXT CHARACTER
STNM1	INR	B	;CHECK FOR B=0
	DCR	B
	JNZ	STNM4	;NO,NO, CAN'T HAVE MINUS SIGNS IN THE MIDDLE
*             OF NUMBERS.
	MVI	A,80H	;SET THE MINUS MANTISSA INDICATOR
	ORA	C
	MOV	C,A	;PUT IT BACK
	JMP	STNM7	;GO GET NEXT CHARACTER
STNMA	INX	H	;GET CHARACTER FOLLOWING E
	MOV	A,M
	ANI	7FH	;STRIP OFF UPPER BIT
	CPI	'-'	;IS IT A MINUS SIGN??
	JZ	STNMB	;SURE IS
	CPI	'+'	;IS IT A PLUS SIGN?
	JNZ	STNMQQ	;NOPE
	MVI	A,20H	;YUP, SO GE T A FAKE SPACE
STNMQQ	SUI	20H	;IS IT A SPACE??
	JNZ	STNM9	;NO, SO WE'VE GOT AN ERROR
	INR	A	;ONE TO A
STNMC	ORA	C	;SET THE EXPONENT SIGN INDICATOR
	MOV	C,A	;PUT IT BACK
	CALL	STNMN	;GET AND CHECK CHARACTER
	STA	CNVR4	;SAVE THE MSD
	CALL	STNMN	;GET AND CHECK CHARACTER
	PUSH	B	;SAVE TEMP
	MOV	B,A	;SAVE LSD
	LDA	CNVR4	;GET THE MSD BACK
	RLC		;SHIFT IT INTO UPPER POSITION
	RLC
	RLC
	RLC
	ADD	B	;PUT IN THE LOWER DIGIT
	POP	B	;RESTORE
	CALL	BCDBN	;CONVERT IT TO BINARY
	STA	CNVR2	;STORE IT
	INX	H	;CORRECT HL TO SHOW END PROPERLY
	JMP	STNM4	;GO FORM NUMBER
STNMB	MVI	A,41H	;SET NEGATIVE INDICATOR
	JMP	STNMC	;GO PROCESS EXPONENT
STNMN	INX	H	;UPDATE INDEX
	MOV	A,M	;GET THE CHARACTER
	ANI	7FH	;STRIP UPPER BIT
	SUI	30H	;IS IT LESS THAN A NUMBER
	JM	STNMO	;SURE WAS
	CPI	10	;IS IT MORE THAN A DIGIT?
	JP	STNMO	;YUP
	RET		;IT'S OK
STNMO	POP	D	;CLEAN UP STACK
STNM9	POP	D	;RESTORE REGISTERS FOR ERROR EXIT
	POP	H
	STC		;SET ERROR INDICATOR
	RET		;EXIT, STAGE AN ERROR
STNM4	MOV	A,B	;PUT DIGIT COUNT IN A
	CPI	11	;IS B > 10?
	JM	STNME	;NO
	MVI	A,1	;SET UP TO SET FLOATING FLAG
	ORA	C
	MOV	C,A	;PUT IT BACK
STNME	MOV	A,C	;CHECK FLOATING BIT
	ANI	1
	JZ	STNMF	;LEAP IF THIS IS AN INTEGER
	LDA	CNVR2	;CHECK STATE OF EXPONENT FLAG
	CPI	0FFH	;HAS IT BEEN READ IN?
	JZ	STNMG	;NOPE
STNML	LDA	CNVR1	;CHECK STATE OF DECIMAL POINT FLAG
	CPI	0FFH	;HAS IT BEEN READ IN?
	JZ	STNMH	;NOPE
STNMI	MOV	A,C	;CHECK SIGN OF EXPONENT
	ANI	40H
	JNZ	STNMJ	;LEAP FOR ALTERNATE CONVERSION (NEGATIVE)
	LDA	CNVR1	;GET CNVR1 TO B
	MOV	B,A
	LDA	CNVR2	;GET CNVR2 TO A
	ADD	B	;COMPUTE CNVR2+CNVR1
	DCR	A
	DCR	A
	JMP	STNMK	;SKIP
STNMJ	LDA	CNVR3	;GET CNVR3
	MOV	B,A	;SAVE IT IN B
	LDA	CNVR2	;GET CNVR2
	ADD	B	;ADD
	MOV	B,A	;SAVE IT IN B
	LDA	CNVR1	;GET CNVR1
	CMA		;2'S COMPLEMENT
	INR	A
	ADD	B
STNMK	INR	A	;CORRECTION
	CALL	STNMP	;CONVERT TO BCD
	POP	D	;GET BACK ADDRESS TO STORE TO
	INX	D	;GET EXPONENT ADDRESS
	STAX	D	;STORE EXPONENT
	DCX	D	;GET SIGNS LOCATION
	MOV	A,C	;GET ID BYTE TO A
	STAX	D	;STORE IT
	INX	D	;GET MANTISSA LOCATION
	INX	D
	PUSH	H	;SAVE INDEX
	LXI	H,WORK1	;GET LOCATION OF NUMBER
	MVI	C,8	;PRESET COUNTER
STNMW	MOV	A,M	;GET A BYTE
	ANA	A	;SET FLAGS
	JNZ	STNMV	;OK, NOT ZERO
	INX	H	;UPDATE INDEX
	DCR	C	;UPDATE COUNTER
	JNZ	STNMW	;CHECK ANOTHER BYTE
	DCX	D	;GET EXPONENT LOCATION
	STAX	D	;STORE A ZERO
	INX	D	;GET MANTISSA LOCATION BAC
STNMV	LXI	H,WORK1	;SOURCE
	MVI	C,4	;NUMBER OF PACKED BYTES
	CALL	PACK	;PACK IN THE MANTISSA
	POP	H	;RESTORE INDEX
	POP	D	;CLEAN UP STACK
	XRA	A	;CLEAR CARRY
	RET		;FLOATING POINT EXIT
STNMP	PUSH	D	;SAVE REGISTERS
	PUSH	H
	MOV	L,A	;PUT BINARY NUMBER IN HL
	MVI	H,0
	MVI	E,10	;SET UP TO DIVIDE BY 10
	CALL	DIV	;DO IT TO IT
	MOV	A,L	;ROTATE MSD INTO UPPER POSITION
	RLC
	RLC
	RLC
	RLC
	ADD	H	;ADD REMAINDER
	POP	H	;RESTORE
	POP	D
	RET		;GO BACK FROM WHENCEVER YOUSE CAME
STNMG	XRA	A	;CLEAR CNVR2
	STA	CNVR2
	JMP	STNML	;CONTINUE PROCESSING
STNMH	MOV	A,B	;SEND B TO CNVR1
	STA	CNVR1
	JMP	STNMI	;CONTINUE PROCESSING
STNM3	LDA	WORK1	;SEE IF ANY SIGNIFICANT DIGITS YET
	ANA	A	;SET FLAGS
	JNZ	STNMM	;AH, THERE ARE SIGNIFICANT DIGITS
	STA	CNVR3	;NO, SO CLEAR THE LEADING ZEROES COUNTER
	MVI	A,40H	;SET IN EXPONENT SIGN BIT
	ORA	C
	MOV	C,A
STNMM	MVI	A,1	;SET THE FLOATING POINT BIT
	ORA	C
	MOV	C,A	;PUT IT BACK
	MOV	A,B	;SEND B TO CNVR1
	STA	CNVR1
	JMP	STNM7	;JUMP BACK TO PROCESS NEXT CHARACTER
STNMF	POP	D	;GET LOCATION
	MOV	A,C	;STORE ID BYTE
	STAX	D
	INX	D
	PUSH	H	;SAVE INDEXES
	PUSH	D
	MVI	A,10	;C=10-B
	SUB	B
	MOV	C,A
	LXI	H,WORK1+9	;GET END OF NUMBER
	MOV	A,L	;DE=HL-C
	SUB	C
	MOV	E,A
	MOV	A,H
	SBI	0
	MOV	D,A
STMNQ	INR	B	;CHECK FOR B=0
	DCR	B	
	JZ	STMNR	;GO TO STORE ZEROES
	LDAX	D	;GET A BYTE
	MOV	M,A	;STORE IT
	DCX	D	;UPDATE INDEXES
	DCX	H
	DCR	B	;UPDATE COUNTER
	JMP	STMNQ	;LOOP FOR MORE BYTES TO MOVE
STMNR	INR	C	;CHECK FOR C=0
	DCR	C
	JZ	STNMQ	;ALL DONE
	MVI	M,0	;STORE A 0
	DCX	H	;UPDATE INDEX
	DCR	C	;UPDATE COUNTER
	JMP	STMNR	;LOOP FOR MORE ZEROES
STNMQ	LXI	H,WORK1	;GET SOURCE
	MVI	C,5	;NUMBER OF PACKED BYTES
	POP	D	;GET DESTINATION
	CALL	PACK	;PACK IT IN, BOYS.
	POP	H	;RESTORE INDEX
	POP	D	;CLEAN UP STACK
	XRA	A	;CLEAR CARRY 
	RET		;INTEGER EXIT
* RTN. B.29
* CONVERT NUMBER TO ASCII STRING
* NUMBER AT (HL) CONVERTED TO STRING STARTING AT (DE)
* ON EXIT, DE IS NEXT CHARACTER AFTER STRING
NMST	XRA	A	;CLEAR A AND SOME FLAGS
	STA	CNVR5	;CLEAR FLOATING/INTEGER FLAG
	STA	CNVR1	;CLEAR LEADING ZEROES FLAG
	MOV	B,M	;GET ID BYTE
	MOV	A,B	;GET ID BYTE TO A
	ANI	80H	;SEE IF MANTISSA IS NEGATIVE
	JZ	NMSTZ	;SKIP IF POSITIVE
	MVI	A,'-'	;SET UP A MINUS
	STAX	D	;STORE TO STRING LOCATION
	INX	D	;GET NEXT LOCATION
NMSTZ	PUSH	D	;SAVE IT
	MOV	A,B	;GET ID BYTE AGAIN
	ANI	1	;SEE IF THIS IS AN INTEGER
	JZ	NMST1	;SURE WAS!!
	INX	H	;GET EXPONENT LOCATION
	INX	H	;GET FIRST BYTE
	MOV	A,M	;CHECK FOR FLOATING ZERO
	DCX	H	;BACK TO EXPONENT
	ANA	A
	JNZ	NMS47	;IT'S A ZERO!
	MVI	M,0	;MAKE IT RIGHT
	DCX	H
	MVI	M,2
	JMP	NMST1	;PROCESS AS INTEGER
NMS47	MOV	A,M	;GET EXPONENT
	MOV	C,A	;PUT IT IN C AND EXPONENT FLAG
	STA	CNVR4
	MOV	A,B	;GET ID BYTE TO FLOATING/INTEGER FLAG
	STA	CNVR5
	MVI	A,1	;GET A ONE TO DECIMAL POINT FLAG
	STA	CNVR3
	LDA	CNVRA	;GET MAX NORMAL DISPLAY FLAG
	CMP	C	;CHECK THIS TURKEY NUMBER'S SIZE
	JC	NMST2	;OOPS, TOO BIG, SO EXPONENT DISPLAY
	XRA	A	;CLEAR EXPONENT DISPLAY FLAG
	STA	CNVR5
	MOV	A,B	;GET ID BYTE AGAIN
	ANI	40H	;CHECK SIGN OF EXPONENT
	JNZ	NMST3	;LEAP IF IT'S MINUS
	LDA	CNVR4	;GET EXPONENT
	CALL	BCDBN	;CONVERT IT TO BINARY
	INR	A	;ADD ONE
	STA	CNVR3	;SET DECIMAL POINT FLAG
	JMP	NMST2	;SKIP
NMST1	INX	H	;UPDATE INDEX
	MVI	A,10	;TEN TO DECIMAL POINT FLAG
	STA	CNVR3
	JMP	NMST4	;CONTINUE
NMST3	XRA	A	;CLEAR DECIMAL POINT FLAG
	STA	CNVR3
	LDA	CNVR4	;GET EXPONENT
	CALL	BCDBN	;CONVERT THE THING TO BINARY
	DCR	A	;SUBTRACT ONE
	STA	CNVR1	;SET THE LEADING ZEROES FLAG
NMST2	INX	H	;GET MANTISSA ADDRESS
	MVI	A,8	;SET NUMBER OF BYTES
NMST4	STA	CNVR6	;SET NUMBER OF DIGITS FLAG
	RRC		;DIVIDE BY TWO
	ANI	0FH
	MOV	B,A	;STICK IT IN B
	LXI	D,WORK1	;SET UP TO UNPACK
	CALL	UNPK	;DO IT
	MVI	C,10	;SET UP TO TURN IT ALL INTO ASCII
	LXI	H,WORK1
NMST5	MOV	A,M	;GET A BYTE
	ORI	30H	;SET ASCII BITS
	MOV	M,A	;PUT IT BACK
	INX	H	;UPDATE INDEX
	DCR	C	;CHECK NUMBER OF BYTES
	JNZ	NMST5	;LOOP TO CONVERT MORE BYTES
	LDA	CNVR6	;GET NUMBER OF DIGITS
	MOV	C,A	;SEND THE MESS TO C
	LXI	H,WORK1	;GET BUFFER LOCATION
	CALL	ADHL	;HL=HL+A
	DCX	H
NMST6	MOV	A,M	;GET A BYTE
	CPI	30H	;SEE IF IT'S AN ASCII ZERO
	JNZ	NMST7	;NO, SIREE
	DCX	H	;WELL THEN, CHECK SOME MORE
	DCR	C	;IS WE DONE YET???
	JNZ	NMST6	;NO? WELL, THEN GO AND CHECK ANOTHER ONE
	MVI	C,09H
NMST7	MOV	A,C	;STORE C IN TRAILING ZEROES FLAG
	STA	CNVR2
	LXI	H,WORK1	;GET BUFFER START
	LXI	B,0	;CLEAR COUNTERS
	POP	D	;RESTORE INDEX
NMST8	LDA	CNVR3	;GET DECIMAL POINT FLAG
	CMP	B	;=B?
	JNZ	NMST9	;NO, SO SKIP
	LDA	CNVR6	;CHECK FOR FLOATING POINT
	CPI	8
	JZ	NMS00	;SURE WAS, SO DUMP A DECIMAL POINT
	LDA	CNVR2	;GET TRAILING ZEROES START
	CMP	B	;ANYTHING LEFT TO PRINT?
	JZ	NMSTA	;NOPE.
NMS00	MVI	A,'.'	;GET AN ASCII PERIOD
	STAX	D	;STORE IT
	INX	D	;UPDATE INDEX
NMST9	LDA	CNVR2	;GET TRAILING ZEROES FLAG
	CMP	B	;ANYTHING LEFT TO PRINT??
	JZ	NMSTA	;NOPE
	LDA	CNVR1	;GET LEADING ZEROES FLAG
	ANA	A	;CHECK FOR A ZERO
	JZ	NMSTB	;SKIP IF IT'S ZERO
	PUSH	B	;SAVE COUNTERS
	MOV	C,A	;NUMBER OF ZEROES TO C
	MVI	A,30H	;ASCII ZERO TO A
NMSTC	STAX	D	;STORE A ZERO
	INX	D	;UPDATE INDEX
	DCR	C	;CHECK BYTES COUNTER
	JNZ	NMSTC	;LOOP FOR MORE ZEROES
	POP	B	;RESTORE COUNTERS
	XRA	A	;CLEAR LEADING ZEROES FLAG
	STA	CNVR1
NMSTB	MOV	A,M	;GET ANOTHER BYTE
	CPI	30H	;IS IT A ZERO (ASCII)??
	JNZ	NMSTD	;NO, NOT THIS TIME
	INR	C	;CHECK FOR C = 0
	DCR	C
	JZ	NMSTE	;SURE IS
NMSTD	INR	C	;SET SIGNIFICANT DIGIT FLAG
	STAX	D	;STORE A DIGIT
	INX	D	;UPDATE INDEXES
NMSTE	INX	H
	INR	B	;INCREMENT DIGIT COUNTER
	LDA	CNVR6	;GET NUMBER OF DIGITS
	CMP	B	;HAVE WE DONE THAT MANY?
	JNZ	NMST8	;NO, SO LOOP FOR SOME MORE
NMSTA	LDA	CNVR2	;CHECK FOR MORE ZEROES TO SPIT OUT
	MOV	B,A	;SAVE IN B
	LDA	CNVR3	;GET DECIMAL LOCATION
	SUB	B	;SUBTRACT
	MOV	B,A	;STICK IT IN B
	JZ	NMSTU	;YUP
	JM	NMSTU	;YUP
NMSTX	DCR	B	;CHECK COUNT
	JM	NMS57	;CONTINUE
	MVI	A,'0'	;STORE A ZERO
	STAX	D
	INX	D	;INCREMENT INDEX
	JMP	NMSTX	;LOOP FOR MORE ZEROES
NMSTU	LDA	CNVR5	;CHECK FOR EXPONENT DISPLAY
	ANA	A	;SET FLAGS
	RZ		;RETURN IF NO EXPONENT NECESARY
	ANI	40H	;CHECK FOR MINUS EXPONENT
	MVI	A,'E'	;STORE AN E
	STAX	D
	INX	D	;UPDATE INDEX
	MVI	A,20H	;GET A SPACE
	JZ	NMSTF	;SKIP IF EXPONENT POSITIVE
	MVI	A,'-'	;GET A MINUS SIGN
NMSTF	STAX	D	;STORE THIS
	INX	D	;INCREMENT INDEX
	LDA	CNVR4	;GET EXPONENT
	MOV	B,A	;PUT IT IN B
	RRC		;SHIFT MSD INTO BOTTOM
	RRC
	RRC	
	RRC
	ANI	0FH	;STRIP OFF UPPER
	ORI	30H	;SET ASCII OFFSET
	STAX	D	;STORE IT
	INX	D
	MOV	A,B	;GET THE EXPONENT AGAIN
	ANI	0FH	;STRIP OFF UPPER
	ORI	30H	;SET ASCII OFFSET
	STAX	D	;STORE IT
	INX	D	;UPDATE INDEX
	RET		;AHHHHH, DONE.
NMS57	LDA	CNVR6	;SEE IF THIS IS FLOATING
	CPI	8
	JNZ	NMSTU	;NOPE
	MVI	A,'.'	;STUFF A PERIOD
	STAX	D
	INX	D	;UPDATE
	JMP	NMSTU	;CONTINUE
* MATH MODULE
* RTN. B.37
* TERMINATOR FOR TRANSCENDENTAL FUNCTIONS
* TRMN ENTRANCE CHANGES SIGNF AND CHECKS TMP6
* TRMN1 ENTRANCE JUST CHECKS TMP6
TRMN	LDA	SIGNF	;GET THE SIGN CHANGE FLAG
	MOV	B,A	;STICK IT IN B
	LXI	H,TMP6	;GET ADDRESS OF TERM
	XRA	M	;CHANGE THE SIGN BIT IF INDICATED
	MOV	M,A	;STUFF IT BACK
	MOV	A,B	;GET THE SIGN FLAG BACK
	XRI	80H	;CHANGE IT
	STA	SIGNF	;STUFF IT BACK TOO
TRMN1	LHLD	TMP5	;GET ID BYTE AND EXPONENT
	MOV	C,H	;MOVE TO BC
	MOV	B,L
	LHLD	TMP6	;GET ID BYTE AND EXPONENT
	MOV	E,H	;MOVE TO DE
	MOV	A,L	;CHANGE EXPONENT SIGN
	XRI	40H
	MOV	D,A
	LDA	TMP6+2	;CHECK FOR TERM=0
	ANA	A	;SET FLAGS
	STC		;SET THE CARRY JUST IN CASE
	RZ
	CALL	EXAD	;ADD THE EXPONENTS
	MOV	A,B	;CHECK THE SIGN
	ANI	40H	;STRIP IT OFF
	RNZ		;RETURN WITHOUT CARRY IF WAS NEGATIVE
	MOV	A,C	;GET THE EXPONENT
	SUI	8	;SET CARRY TO WRONG STATE
	CMC		;SET IT RIGHT
	RET		;DONE..
* RTN. B.38
* COMPARE (HL) AND (DE)
* ZERO SET IF (HL) EQUALS (DE)
* CARRY SET IF (HL) < (DE)
CMPR	LXI	B,TMP7	;GET ADDRESS OF ANSWER HOME
	CALL	SUBER	;SUBTRACT (HL)-(DE)
	LXI	H,TMP7+1	;GET ADDRESS OF EXPONENT/MSD'S
	MVI	B,5	;NUMBER OF BYTES TO CHECK
CMPR2	MOV	A,M	;GET A BYTE
	ANA	A	;SET FLAGS
	JNZ	CMPR1	;AH,HA, IT'S NOT ZERO
	INX	H	;UPDATE INDEX
	DCR	B	;CHECK BYTE COUNTER
	JNZ	CMPR2	;NOT DONE, SO LOOP FOR MORE
	RET		;THIS EXIT IF NUMBER WAS ZERO
CMPR1	LDA	TMP7	;CHECKING THE MANTISSA SIGN
	ANI	80H	;STRIP IT OFF
	ORI	1	;SET A BIT SO'S WE DON'T GET A ZERO
	RLC		;SET THE CARRY FLAG IF 'TWAS NEGATIVE
	RET		;THIS EXIT IF NUMBER WAS NOT ZERO
* CONSTANT 2PI
TWOPI	DB	3	;ID BYTE
	DB	0	;EXPONENT
	DB	62H	;MANTISSA
	DB	83H	
	DB	18H
	DB	53H
* RTN. B.39
* NORMALIZE ANGLE IN RADIANS
* (HL) MODULO (2PI) TO TMP1
NRML	PUSH	H	;SAVE THE ANGLE ADDRESS
	LXI	D,TWOPI	;SET UP FOR COMPARE WITH 2*PI
	CALL	CMPR	;DO IT
	POP	H	;RETRIEVE ADDRESS
	JC	NRML1	;AH, IT'S ALREADY LESS THAN 2*PI
	PUSH	H	;SAVE THE ANGLE ADDRESS AGAIN
	LXI	D,TWOPI	;SET UP FOR DIVIDE BY TWOPI
	LXI	B,TMP1	;DESTINATION ADDRESS
	CALL	DIVER	;DIVIDE
	LXI	H,TMP1	;SET UP FOR INT(TMP1)
	MOV	D,H
	MOV	E,L
	CALL	INTG	;INT(TMP1) TO TMP1
	LXI	H,TMP1	;SET UP FOR TMP1*2*PI
	LXI	D,TWOPI
	MOV	B,H
	MOV	C,L
	CALL	MULER	;MULTIPLY
	POP	H	;GET BACK THE ANGLE ADDRESS
	LXI	D,TMP1	;SET UP FOR ANGLE-(INT(ANGLE/2*PI)*2*PI)
	MOV	B,D
	MOV	C,E
	CALL	SUBER	;SUBTRACT
	RET		;LARGE ANGLE EXIT
*
NRML1	LXI	B,TMP1	;MOVE ANGLE INTO TMP1 AS FLOATING
	LXI	D,ONE11	;FLOATING POINT ONE
	JMP	MULER	;MULTIPLY IT!
*
* RTN. B.40
* COMPUTE FACTORIAL TERM
* TMP2 = N
* TMP3 = N!
*
FCTRL	LXI	H,TMP2	;SET UP TO ADD ONE TO TMP2
	LXI	D,ONE11
	MOV	B,H
	MOV	C,L
	CALL	ADDER	;ADD IT
	LXI	H,TMP2	;SET UP FOR (TMP2)*(TMP3) TO (TMP3)
	LXI	D,TMP3
	MOV	B,D
	MOV	C,E
	CALL	MULER	;MULTIPLY IT
	RET		;DONE
* RTN. B.41
* TRIG SERIES INITIALIZER
TRIN	XRA	A	;GET A ZERO
	STA	SIGNF	;CLEAR THE SIGN FLAG
	LXI	B,6	;NUMBER OF BYTES
	PUSH	B	;SAVE IT
	LXI	D,TMP5	;CLEAR TMP5
	LXI	H,ZERO0
	CALL	MVDN
	POP	B	;SET TMP3, TMP2, TO ONE
	PUSH	B
	LXI	H,ONE11
	PUSH	H
	LXI	D,TMP2
	CALL	MVDN
	POP	H	
	POP	B
	LXI	D,TMP3
	CALL	MVDN
	LXI	H,TMP1	;TMP1 SQUARED TO TMP4
	MOV	D,H
	MOV	E,L
	LXI	B,TMP4
	CALL	MULER
	RET		;DONE..
* RTN. B.43
* SINE/COSINE SERIES EVALUATION
* RESULT IS IN TMP6
SERS	LXI	H,TMP1	;TMP6=TMP1/TMP3
	LXI	D,TMP3
	LXI	B,TMP6
	CALL	DIVER	;DIVIDE
	CALL	TRMN	;CHECK TO SEE IF WE ARE DONE
	RC		;YUP, SO RETURN
	LXI	H,TMP5	;TMP5=TMP5+TMP6
	LXI	D,TMP6
	MOV	B,H
	MOV	C,L
	CALL	ADDER	;ADD IT
	CALL	FCTRL	;COMPUTE TWO FACTORIAL TERMS
	CALL	FCTRL
	LXI	H,TMP1	;TMP1=TMP1*TMP4
	LXI	D,TMP4
	MOV	B,H
	MOV	C,L
	CALL	MULER	;MULTIPLY IT
	JMP	SERS	;LOOP AND TRY ANOTHER TERM
* RTN. B.44
* SINE AND COSINE EVALUATION
* SINE ENTRANCE PROVIDES SINE
* COSN ENTRANCE PROVIDES COSINE
* F(HL) TO (DE)
SINE	XRA	A	;CLEAR TMP6
	STA	TMP6	;THIS INDICATES SINE
SICO	PUSH	D	;SAVE DESTINATION
	CALL	NRML	;NORMALIZE ANGLE
	CALL	TRIN	;INITIALIZE
	LDA	TMP6	;GET SINE/COSINE FLAG
	ANA	A	;SET FLAGS
	JZ	SICO1	;SKIP IF SINE COMPUTATION
	LXI	H,ONE11	;THIS IS COSINE, SO 1 TO TMP1
	LXI	D,TMP1
	LXI	B,6
	CALL	MVDN
	LXI	H,ZERO0	;AND ZERO TO TMP2
	LXI	D,TMP2
	LXI	B,6
	CALL	MVDN
SICO1	CALL	SERS	;EVALUATE THE SERIES
	POP	D	;RESTORE DESTINATION ADDRESS
	LXI	H,TMP5	;MOVE FROM TMP5 TO (DE)
	LXI	B,6
	CALL	MVDN
	RET		;ALL DONE...
COSN	MVI	A,1	;SET TMP6 NONZERO
	STA	TMP6	;INDICATING THAT THIS IS A COSINE
	JMP	SICO	;COMPUTE IT
* RTN. B.45
* TANGENT
* COMPUTED BY TAN(X)=SIN(X)/COS(X)
TANG	PUSH	D	;SAVE DESTINATION
	PUSH	H	;SAVE SOURCE
	LXI	D,TMP8	;TMP8=SIN(HL)
	CALL	SINE
	POP	H	;GET SOURCE AGAIN
	LXI	D,TMP9	;TMP9=COS(HL)
	CALL	COSN
	LXI	H,TMP8	;(DE)=TMP8/TMP9
	LXI	D,TMP9
	POP	B	;GET DESTINATION BACK
	CALL	DIVER	;DO IT TO IT
	RET		;FINI!
* RTN. B.46
* ARCTANGENT
* FOR (HL) > 1.3, USES MACLAURIN SERIES FOR ARCTAN
* FOR (HL) < 1.3, USES MACLAURIN SERIES FOR ARCSIN,
* AND THE IDENTITY, ARCTAN(X)=ARCSIN(X/SQU(X*X+1))
* THIS ENSURES CONVERGENCE WITHIN OUR LIFETIME
ATAN	PUSH	D	;SAVE DESTINATION
	PUSH	H	;SAVE SOURCE
	LXI	D,TMP1	;MOVE (HL) TO TMP1
	LXI	B,6
	CALL	MVDN	;MOVE IT
	MOV	H,D	;COMPUTE TMP4=TMP1*TMP1
	MOV	L,E
	LXI	B,TMP4
	CALL	MULER	;MULTIPLY
	LXI	H,TMP4	;COMPARE TMP4 AND 1.69
	LXI	D,CONS1
	CALL	CMPR	;COMPARE
	POP	H	;RESTORE SOURCE ADDRESS
	JC	ATAN2	;TOO SMALL, SO USE ARCSIN SERIES
	LXI	H,CONS2	;MOVE PI/2 TO TMP5
	LXI	D,TMP5
	LXI	B,6
	CALL	MVDN
	LXI	H,ONE11	;MOVE ONE INTO TMP2
	LXI	D,TMP2
	LXI	B,6
	CALL	MVDN
	MVI	A,80H	;SET SIGN CHANGE FLAG TO 80H
	STA	SIGNF
	LDA	TMP1	;MAKE MANTISSA SIGN OF TMP5 SAME
	ANI	80H	;AS SIGN OF TMP1
	MOV	B,A	;SAVE SIGN OF TMP1 IN B
	LXI	H,TMP5	;ADDRESS OF ID BYTE
	MOV	A,M	;GET IT
	ANI	7FH	;STRIP ALL BUT SIGN OF MANTISSA
	ORA	B	;SET IN SIGN OF TMP1
	MOV	M,A	;STICK IT BACK
	LXI	H,ONE11	;TMP1=1/TMP1
	PUSH	H	;SAVE THIS ADDRESS
	LXI	D,TMP1
	MOV	B,D
	MOV	C,E
	CALL	DIVER	;DIVIDE IT
	POP	H	;GET ONE.. ADDRESS BACK
	LXI	D,TMP4	;TMP4=1/TMP4
	MOV	B,D
	MOV	C,E
	CALL	DIVER	;DIVIDE IT
ATAN1	LXI	H,TMP1	;TMP6=TMP1/TMP2
	LXI	D,TMP2
	LXI	B,TMP6
	CALL	DIVER	;DIVIDE
	CALL	TRMN	;CHECK FOR DONENESS
	JC	ATAN3	;OH, MY, ALL DONE
	LXI	H,TMP2	;TMP2=TMP2+2
	MOV	B,H
	MOV	C,L
	LXI	D,TWO22
	CALL	ADDER	;ADD
	LXI	H,TMP1	;TMP1=TMP1*TMP4
	MOV	B,H
	MOV	C,L
	LXI	D,TMP4
	CALL	MULER	;MULTIPLY
	LXI	H,TMP5	;TMP5=TMP5+TMP6
	MOV	B,H
	MOV	C,L
	LXI	D,TMP6
	CALL	ADDER	;ADD
	JMP	ATAN1	;LOOP FOR ANOTHER TERM
*
ATAN2	PUSH	H	;SAVE SOURCE ADDRESS
	LXI	H,ONE11	;TMP10=TMP4+1
	LXI	D,TMP4
	LXI	B,TMP10
	CALL	ADDER	;ADD
	LXI	H,TMP10	;TMP10=SQR(TMP10)
	MOV	D,H
	MOV	E,L
	CALL	SQUR	;COMPUTE SQUARE ROOT
	POP	H	;RESTORE SOURCE ADDRESS
	LXI	D,TMP10	;TMP1=(HL)/TMP10
	LXI	B,TMP1
	CALL	DIVER	;DIVIDE IT
	LXI	H,TMP1	;TMP4=TMP1*TMP1
	MOV	D,H
	MOV	E,L
	LXI	B,TMP4
	CALL	MULER	;MULTIPLY
	LXI	H,ONE11	;TMP3=1
	LXI	D,TMP3
	LXI	B,6
	CALL	MVDN
	LXI	D,TMP9	;TMP9=1
	CALL	MVDN
	LXI	H,ZERO0	;TMP5=0
	LXI	D,TMP5
	CALL	MVDN
	LXI	D,TMP2	;TMP2=0
	CALL	MVDN
ATAN4	LXI	H,TMP9	;TMP7=TMP9*TMP1
	LXI	D,TMP1
	LXI	B,TMP7
	CALL	MULER	;MULTIPLY
	LXI	H,ONE11	;TMP8=TMP2+1
	LXI	D,TMP2
	LXI	B,TMP8
	CALL	ADDER	;ADD
	LXI	H,TMP7	;TMP7=TMP7/TMP8
	LXI	D,TMP8
	MOV	B,H
	MOV	C,L
	CALL	DIVER	;DIVIDE
	LXI	H,TMP7	;TMP6=TMP7/TMP3
	LXI	D,TMP3
	LXI	B,TMP6
	CALL	DIVER	;DIVIDE
	CALL	TRMN1	;CHECK FOR DONENESS
	JC	ATAN3	;OK, WE'RE DONE
	LXI	H,TMP5	;TMP5=TMP5+TMP6
	LXI	D,TMP6
	MOV	B,H
	MOV	C,L
	CALL	ADDER	;ADD
	LXI	H,TMP2	;TMP2=TMP2+1
	LXI	D,ONE11	
	MOV	B,H
	MOV	C,L
	CALL	ADDER	;ADD
	LXI	H,TMP9	;TMP9=TMP9*TMP2
	LXI	D,TMP2
	MOV	B,H
	MOV	C,L
	CALL	MULER	;MULTIPLY
	CALL	FCTRL	;COMPUTE ANOTHER FACTORIAL TERM
	LXI	H,TMP1	;TMP1=TMP1*TMP4
	LXI	D,TMP4
	MOV	B,H
	MOV	C,L
	CALL	MULER	;MULTIPLY
	JMP	ATAN4	;LOOP FOR ANOTHER TERM
ATAN3	POP	D	;GET DESTINATION ADDRESS
	LXI	H,TMP5	;MOVE TMP5 THERE
	LXI	B,6
	CALL	MVDN
	RET		;DONE AT LAST!!
* RTN. B.47
* CONVERT NUMBER TO TWO BYTE BINARY
* (HL) TO HL
BCDB	LXI	D,TMP9	;CONVERT TO INTEGER IN TMP9
	CALL	INTG
	LXI	H,TMP9	;COMPARE WITH 32767
	LXI	D,C2767
	CALL	CMPR
	JNC	BCDB2	;JUMP IF NUMBER TOO LARGE TO CONVERT
	LXI	H,0	;CLEAR HL
	LXI	B,TMP9+3	;INITIALIZE FOR CONVERSION LOOP
	LDAX	B	;GET A DIGIT
	MOV	L,A	;TO L
	INX	B	;GET NEXT DIGIT ADDRESS
	XRA	A	;CLEAR FLAGS AND A
BCDB1	PUSH	PSW	;SAVE FLAGS
	PUSH	B	;SAVE INDEX
	DAD	H	;HL=HL*100 (BY TOM GALLANT)
	DAD	H	;GENERATE HL*4
	MOV	D,H	;TO DE
	MOV	E,L
	DAD	H	;GENERATE HL*32
	DAD	H
	DAD	H
	MOV	B,H	;TO BC
	MOV	C,L
	DAD	H	;GENERATE HL*64
	DAD	D
	DAD	B
	POP	B	;RESTORE INDEX
	LDAX	B	;GET NEXT DIGIT
	CALL	BCDBN	;CONVERT TO BINARY
	MOV	E,A	;TO DE
	MVI	D,0	;CLEAR D
	DAD	D	;ADD TO PARTIAL SUM
	INX	B	;UPDATE INDEX
	POP	PSW	;GET FLAGS BACK
	CMC		;TEST LOOP COUNTER
	JC	BCDB1	;MORE TO GO!
	LDA	TMP9	;CHECK SIGN BIT
	ANA	A	;SET FLAGS
	RP		;ALL'S OK
	XCHG
	LXI	H,0	;GET THE COMPLEMENT
	CALL	SUB16
	RET		;DONE%
* RTN. B.48
* CONVERT BINARY TO NUMBER
* HL TO (DE)
BBCD	MOV	A,H	;CHECK FOR A NEGATIVE NUMBER
	ANI	80H	;SET FLAGS AND STRIP OTHER BITS
	MOV	B,A	;SIGN BIT TO B FOR PATTERN
	JZ	BBBCD	;POSITIVE NUMBER
	MOV	A,H	;COMPLEMENT HL
	CMA
	MOV	H,A
	MOV	A,L
	CMA
	MOV	L,A
	INX	H	;CORRECT FOR 2'S COMPLEMENT
BBBCD	MVI	A,2	;SET ID BYTE
	ORA	B	;SET IN THE SIGN BIT
	STAX	D
	XCHG		;SET UP TO ZERO OUT NUMBER
	INX	H	;GET NEXT BYTE
	MVI	A,5	;SET UP FOR 5 BYTES
	CALL	ZERO	;ZERO OUT FIVE BYTES
	DCX	H	;CORRECT THE INDEX
	MVI	A,3	;NUMBER OF EXECUTIONS FOR CONVERSION LOOP
	XCHG		;PUT BINARY BACK IN HL
	MOV	B,D	;PUT DESTINATION IN BC
	MOV	C,E
BBCD1	PUSH	PSW	;SAVE THE COUNT
	PUSH	B	;SAVE INDEX
	LXI	B,0	;CLEAR COUNTER
	LXI	D,100	;SET SUBTRACTOR
BBCDA	CALL	CMP16	;CHECK IT FOR FITTING
	JC	BBCDB	;NOPE
	CALL	SUB16	;YUP
	INX	B
	JMP	BBCDA
BBCDB	MOV	A,L	;GET REMAINDER TO A
	MOV	L,C	;MOVE QUOTIENT TO HL
	MOV	H,B
	CALL	STNMP
	POP	B	;RESTORE INDEX
	STAX	B	;STORE IT AWAY
	DCX	B	;UPDATE INDEX
	POP	PSW	;GET THE COUNT BACK TO A
	DCR	A	;CHECK THE COUNT
	JNZ	BBCD1	;LOOP IF MORE TO DO
	RET		;DONE$$$$
BCDB2	MVI	B,5	;GET ERROR TYPE
	JMP	ERROR	;ERROR ESCAPE
* I/O MODULE
* RTN. C.1
* FIND MODE ENTRY, GET CHANNEL ADDRESS AND TERMINAL
* DELIMITERS
* IN: A = MODE TO LOOK FOR
*  BC = CHANNEL NUMBER TO START LOOKING WITH
* OUT: IF Z = 0 THEN NO FIND
*  IF Z = 1, THEN FIND AND;
*  HL = CHANNEL ADDRESS
*  DE = ADDRESS OF WIDTH/POSITION/RUBOUT CODE
*  BC = NEXT CHANNEL NUMBER
MFND	LXI	H,MODES-1	 ;COMPUTE STARTING ADDRESS
	DAD	B
	MOV	D,A	;MASK TO D
MFND3	MOV	A,C	;BC=11?
	CPI	11
	JZ	MFND1	;YUP
	MOV	A,M	;GET A BYTE
	ANA	D	;CHECK AGAINST MASK
	JNZ	MFND2	;GOT ONE
	INX	B	;SET UP FOR NEXT ONE
	INX	H
	JMP	MFND3	;GO GET IT
MFND2	MOV	L,C	;HL=BC
	MOV	H,B
	DAD	H	;TIMES TWO
	PUSH	H	;SAVE TIMES TWO
	LXI	D,CHANL-2	;GET BEGINNING OF CHANNEL TABLE - OFFSET
	DAD	D	;COMPUTE ENTRY ADDRESS
	MOV	E,M	;PUT THE ENTRY IN DE
	INX	H	;NEXT ONE
	MOV	D,M
	POP	H	;GET BACK TIMES TWO
	DAD	B	;MAKE IT TIMES THREE
	PUSH	D	;SAVE CHANNEL ADDRESS
	LXI	D,TRMNL-3	;GET WIDTH/POSITION/RUBOUT START-OFFSET
	DAD	D	;COMPUTE ENTRY ADDRESS
	POP	D	;RESTORE CHANNEL ADDRESS
	XCHG		;SWAP
	INX	B	;GET NEXT ITEM NUMBER
	XRA	A	;SET THE ZERO FLAG
	RET		;DONE..
	POP	H	;CLEAN UP STACK
	RET		;LEAVE..
MFND1	ORI	100	;RESTORE A
	ORI	1	;CLEAR THE ZERO FLAG
	RET		;DONE......
* RTN. C.2
* CONTROL C SCANNER
* CALLS THE KEYBOARD ROUTINE WITH ZERO SET FOR 
* A CHECK FOR CONTROL C PUSHED.
* OUT: ZERO SET IF CONTROL C PUSHED
CONT	XRA	A	;SET THE ZERO FLAG
CONT1	PUSH	PSW	;SAVE IT
	MVI	A,1	;GET MODE KEYBOARD
	PUSH	B	;SAVE BC
	LXI	B,1	;START WITH CHANNEL ONE
	CALL	MFND	;FIND THE KEYBOARD CHANNEL
	POP	B	;RESTORE BC
	POP	PSW	;GET THE FLAG BACK
	PCHL		;GO TO THE KEYBOARD ROUTINE
*
LINK06	LINK	A:TBASIC7
