*
*
* TARBELL BASIC SOURCE MODULE #4
* COPYRIGHT (C) 1978 TARBELL ELECTRONICS
* LAST CHANGE MADE ON THIS MODULE 3-15-79.
*
* RTN. B.6
* NORMALIZE WORKING REGISTER
* IN: HL = ADDRESS OF REFERENCE NUMBER
*    DE = ADDRESS OF WORKING REGISTER
* OUT: HL = ADDRESS OF REFERENCE NUMBER
*      DE = ADDRESS OF MANTISSA, NORMALIZED
*      BC = NORMALIZED EXPONENT
NORM	MVI	B,0	;CLEAR 0'S COUNTER
NORM1	LDAX	D	;GET A BYTE
	ANI	0F0H	;LOOK AT UPPER BCD DIGIT
	JNZ	NORM3	;JUMP IF DIGIT IS NONZERO
	MOV	A,B	;UPDATE 0'S COUNTER
	ADI	1	
	DAA		;BCD ADJUST
	MOV	B,A	;PUT IT BACK
	LDAX	D	;NOW LET'S TRY THE LOWER DIGIT
	ANI	0FH	;STRIP OFF LOWER BCD DIGIT
	JNZ	NORM3	;JUMP IF DIGIT IS NONZERO
	MOV	A,B	;UPDATE 0'S COUNTER
	ADI	1
	DAA		;BCD ADJUST
	MOV	B,A	;STUFF IT BACK
	INX	D	;GET NEXT BYTE ADDRESS
	MVI	A,16H	;CHECK FOR A ZERO RESULT
	CMP	B
	JNZ	NORM1	;LOOP TO CHECK SOME MORE
	DCX	D	;LOOKS LIKE ALL ZEROES
	DCX	D	;CORRECT THE INDEX
	DCX	D	;TO GIVE A ZEROES MANTISSA
	DCX	D
	LXI	B,0	;SET UP A ZERO EXPONENT
	RET
*
NORM3	MVI	A,1	;SEE IF B IS ODD
	ANA	B
	JZ	NORM4	;NOPE, SO DON'T SHIFT
	XCHG		;SWAP
	INX	H	;CORRECT THE INDEX
	CALL	SFTL	;SHIFT THE MANTISSA LEFT ONE
	XCHG		;PUT EVERYTHING BACK WHERE IT BELONGS
NORM4	MOV	C,B	;SET UP FOR OFFSET SUBTRACTION
	MVI	B,40H	;SET SIGN BIT
	PUSH	D	;SAVE DE
	LXI	D,8	;SET UP DE
	CALL	EXAD	;PERFORM SUBTRACTION
	MOV	D,M	;GET REFERENCE PARAMETERS
	INX	H
	MOV	E,M
	DCX	H
	CALL	EXAD	;COMPUTE NORMALIZED EXPONENT
	POP	D	;RESTORE DE
	RET		;DONE
*
* RTN. B.7
* FIXED POINT ADD
* NUMBERS POINTED TO BY DE,HL ARE ADDED TO BC
* THE NUMBER AT HL PROVIDES THE ROUNDING BYTE
* A = NUMBER OF BYTES TO ADD
* ON RETURN, A=40H IF A SIGN CHANGE HAS OCCURED
*
FXAD	PUSH	B	;SAVE DESTINATION
	STA	QFLAG	;SAVE FLOATING/FIXED INDICATION
	MOV	C,A	;SAVE NUMBER OF BYTES
	MVI	B,0	;CLEAR B
	XTHL		;GET DESTINATION TO HL
	DAD	B	;ADD OFFSET
	XTHL		;PUT IT BACK ON THE STACK
	DAD	B	;ADD OFFSET
	XCHG		;GET DE TO HL
	DAD	B	;ADD OFFSET
	PUSH	B	;SAVE COUNT
	XCHG		;SWAP 'EM
	PUSH	D	;SAVE ONE SOURCE
	LXI	D,WORK2+8	;GET DESTINATION
	LXI	B,4	;NUMBER OF BYTES
	CALL	MVDN	;MOVE LESS SIGNIFICANT BITS IN
	POP	D	;RESTORE
	POP	B
	XCHG		;SWAP 'EM BACK
	XRA	A	;CLEAR CARRY
FXAD1	DCX	D	;UPDATE INDEXES
	DCX	H	
	LDAX	D	;GET A BYTE TO ADD
	ADC	M	;ADD MEMORY AND THE CARRY
	DAA		;BCD ADJUST
	XTHL		;GET DESTINATION
	DCX	H	;UPDATE INDEX
	MOV	M,A	;STORE THE RESULT
	XTHL		;STUFF IT BACK ON THE STACK
	DCR	C	;CHECK BYTES COUNTER
	JNZ	FXAD1	;LOOP FOR MORE BYTES TO ADD
	RAL		;GET CARRY TO A
	ANI	1	;STRIP ALL BUT LOWER BIT
	POP	H	;CLEAN UP STACK
	MOV	C,A	;SAVE A TO C
	LDA	QFLAG	;GET FLOATING/FIXED INDICATION
	CPI	4	;CHECK FOR FLOATING
	JNZ	FXAD3	;SKIP ROUNDING IF FIXED
	PUSH	H	;SAVE ADDRESS
	LXI	H,WORK2	;INITIALIZE FIRST DIGIT SEARCH
	MVI	B,8D	;MAX BYTE COUNT
FXAD4	MVI	A,0F0H	;MASK UPPER DIGIT
	ANA	M	;AND WITH MEMORY
	JNZ	FXAD5	;LEAP IF NONZERO
	MVI	A,0FH	;MASK LOWER DIGIT
	ANA	M	;AND WITH MEMORY
	JNZ	FXAD6	;LEAP IF NONZERO
	INX	H	;UPDATE INDEX
	DCR	B	;CHECK COUNTER
	JNZ	FXAD4	;LOOP FOR MORE CHECKING
FXAD9	POP	H	;RESTORE ADDRESS
	JMP	FXAD3	;NO ROUNDING IS REQUIRED FOR ZEROES!!
*
FXAD5	MVI	A,50H	;GET ROUNDING NUMBER FOR UPPER FIND
	JMP	FXAD7	;SKIP
*
FXAD6	MVI	A,5H	;GET ROUNDING NUMBER FOR LOWER FIND
FXAD7	LXI	D,8D	;GET OFFSET
	DAD	D	;ADD TO FIND ADDRESS
	ADD	M	;ADD THE ROUNDING NUMBER
	DAA		;BCD ADJUST
FXAD8	JNC	FXADA	;JUMP WHEN DONE
	DCX	H	;UPDATE INDEX
	MOV	A,M	;GET A BYTE
	ADI	1	;INCREMENT
	DAA		;BCD ADJUST
	MOV	M,A	;STORE IT BACK
	JC	FXAD8+3	;LOOP FOR MORE ADDS
FXADA	POP	H	;GET ADDRESS BACK TO HL
	DCX	H	;GET OVERFLOW ADDRESS
	MOV	A,M	;GET IT TO A
	MVI	M,0	;CLEAR IT OUT
	INX	H	;RESTORE ADDRESS
	ORA	C	;SET IN OLD OVERFLOW
	MOV	C,A	;BACK TO C
FXAD3	LDA	ASFLG	;GET ADD/SUBTRACT FLAG
	ANA	A	;SET FLAGS
	JNZ	FXAD2	;JUMP IF SUBTRACT WAS JUST PERFORMED
	DCX	H	;GET OVERFLOW ADDRESS
	MOV	M,C	;STORE ANY OVERFLOW FOR ADD OPERATION
	XRA	A	;CLEAR A FOR NO SIGN CHANGE
	RET		;DONE
*
FXAD2	XRA	A	;CLEAR A
	DCR	C	;CHECK FOR OVERFLOW
	RZ		;OK, NORMAL FOR SUBTRACT
	MVI	C,5	;OH,OH, SIGN CHANGE, SO COMPLEMENT
	CALL	CMPL	;GET 10'S COMPLEMENT
	MVI	A,080H	;SET SIGN CHANGE FLAG
	RET		;DONE
*
* RTN. B.8
* 10'S COMPLEMENT BUFFER BCD
* COMPLEMENTS C BYTES STARTING AT HL
*
CMPL	PUSH	B	;SAVE BYTES COUNTER FOR LATER
CMPL1	MOV	A,M	;GET A BYTE
	CMA		;GET 1'S COMPLEMENT
	SUI	66H	;GET 9'S COMPLEMENT
	MOV	M,A	;STICK IT BACK
	INX	H	;UPDATE INDEX
	DCR	C	;CHECK BYTES COUNTER
	JNZ	CMPL1	;LOOP FOR MORE BYTES
	STC		;SET UP FOR 10'S COMPLEMENT
	POP	B	;RESTORE BYTE COUNT
CMPL2	DCX	H	;UPDATE INDEX
	MOV	A,M	;GET BYTE BACK
	ACI	0	;ADD CARRY FOR 10'S COMPLEMENT
	DAA		;BCD ADJUST
	MOV	M,A	;STICK IT BACK
	RNC		;RETURN IF NO CARRY PROPAGATE
	DCR	C	;CHECK BYTES COUNTER
	JNZ	CMPL2	;LOOP FOR MORE BYTES
	RET		;DONE
*
* RTN. B.9
* FLOATING POINT ADD AND SUBTRACT
* ADD ENTERS AT FPADD
* SUBTRACT ENTERS AT FPSUB
* PERFORMS (HL)+-(DE), PUTS RESULT IN (BC)
*
FPSUB	PUSH	B	;SAVE REGISTERS
	PUSH	H
	XCHG		;GET 'FROM' TO HL
	INX	H	;GET ADDRESS OF MSD
	INX	H
	MOV	A,M	;GET THE MSD BYTE
	DCX	H	;RESTORE THE ADDRESS
	DCX	H
	LXI	D,TEMP1	;GET ADDRESS OF TEMPORARY 1
	LXI	B,6	;GET NUMBER OF BYTES
	CALL	MVDN	;MOVE TO TEMPORARY
	ANA	A	;SET FLAGS
	JZ	FPSB1	;SKIP SIGN CHANGE IF ZERO
	LDAX	D	;GET SIGN BYTE
	XRI	80H	;CHANGE SIGN OF MANTISSA
	STAX	D	;PUT IT BACK
FPSB1	POP	H	;RESTORE REGISTERS
	POP	B
FPADD	XRA	A	;CLEAR ADD/SUBTRACT FLAG
	STA	ASFLG
	PUSH	H	;SAVE HL
	LXI	H,WORK1	;CLEAR OUT WORKING REGISTERS 1 AND 2
	MVI	A,24	;NUMBER OF BYTES
	CALL	ZERO	;CLEAR THEM
	POP	H	;RESTORE HL
	PUSH	B	;SAVE DESTINATION
	LDAX	D	;GET SIGNS BYTE
	XRA	M	;GET BITS DIFFERENT THAN OTHER NUMBER
	ANI	80H	;GET MANTISSA SIGN BIT ALONE
	JZ	FPAS1	;JUMP IF SIGNS ARE THE SAME
	ANA	M	;CHECK SIGN OF NUMBER AT HL
	JNZ	FPAS2	;HL NEGATIVE ALREADY, SO SKIP SWAP
	XCHG		;PUT NEGATIVE NUMBER IN HL
FPAS2	PUSH	D	;SAVE OTHER NUMBER
	LXI	B,6	;GET NUMBER OF BYTES
	LXI	D,TEMP2	;GET ADDRESS TO MOVE TO
	CALL	MVDN	;MOVE IT
	PUSH	D	;SAVE NUMBER LOCATION
	XCHG		;PUT DESTINATION IN HL
	INX	H	;MOVE UP TO MANTISSA
	INX	H
	MVI	C,4	;NUMBER OF BYTES
	CALL	CMPL	;DO A 10'S COMPLEMENT
	POP	H	;RESTORE LOCATION
	POP	D	;RESTORE THE OTHER LOCATION
	MVI	A,0FFH	;SET ADD/SUBTRACT FLAG
	STA	ASFLG
FPAS1	PUSH	H	;SAVE LOCATIONS
	PUSH	D
	MOV	B,M	;GET EXPONENTS AND SIGNS
	INX	H
	MOV	C,M
	XCHG
	MOV	D,M
	INX	H
	MOV	E,M
	PUSH	B	;SAVE ORIGINAL EXPONENT
	MVI	A,40H	;COMPLEMENT SIGN BIT OF ONE
	XRA	B	;FOR SUBTRACT
	MOV	B,A	;STICK THE COMPLEMENTED BIT BACK
	PUSH	D	;SAVE ORIGINAL EXPONENT
	CALL	EXAD	;COMPUTE DIFFERENCE IN EXPONENTS
	POP	D	;RESTORE ORIGINAL EXPONENT
	MOV	A,D	;SAVE ORIGINAL EXPONENT
	POP	D	;GET THE OTHER ORIGINAL BACK
	MOV	E,A	;TWO ORIGINALS IN D,E
	PUSH	PSW	;SAVE ANY CARRY FLAG FOR LATER
	MOV	A,E	;COMPUTE A'B'R'+AB'+ABR TO FIND LARGER
	ORA	D
	CMA
	ANA	B
	MOV	H,A
	MOV	A,B
	ANA	E
	ANA	D
	ORA	H
	MOV	H,A
	MOV	A,D
	CMA
	ANA	E
	ORA	H
	ANI	40H	;SEPARATE SIGN BIT
	POP	H	;GET LOCATIONS BACK
	POP	D
	XTHL
	JNZ	FPAS4	;JUMP IF NO SWAP NECCESARY
	XCHG		;SWAP LOCATIONS TO GET LARGER TO HL
FPAS4	INX	H
	INX	H
	MOV	A,M
	DCX	H
	DCX	H
	ANA	A
	JNZ	FPAS4W
	XCHG
FPAS4W	POP	PSW	;GET THE CARRY FLAG BACK
	JC	FPAS7	;JUMP IF NO NEED TO ADD
	MOV	A,C	;GET EXPONENTS DIFFERENCE TO A
	CPI	9	;SEE IF > 8
	JP	FPAS7	;YES, SO NO ADD REQUIRED
	PUSH	H	;SAVE LOCATION
	PUSH	D	;SAVE LOCATION
	PUSH	B	;SAVE THE DIFFERENCE
	XCHG		;SET UP TO MOVE MANTISSA
	LXI	D,WORK1+4	;GET WORKING REGISTER ADDRESS
	INX	H	;GET MANTISSA ADDRESS
	INX	H
	LXI	B,4	;GET NUMBER OF BYTES
	CALL	MVDN	;MOVE IT IN
	POP	B	;GET THE DIFFERENCE BACK
	XCHG		;GET MANTISSA LOCATION TO HL
	POP	D	;GET THE NUMBER LOCATION
	LDAX	D	;GET THE SIGNS BYTE
	ANI	80H	;CHECK SIGN
	JZ	FPAS5	;POSITIVE, SO LEAVE ZEROES
	LDA	ASFLG	;CHECK FOR SUBTRACT OPERATION
	ANA	A	;SET FLAGS
	JZ	FPAS5	;JUMP IF BOTH SIGNS THE SAME
	MVI	A,99H	;GET A 99
FPAS5	MOV	B,A	;STICK IT IN B
	MOV	A,C	;GET NUMBER OF SHIFTS
	CALL	SHFT	;SHIFT THE BUFFER
	XCHG		;PUT ADDRESS TO DE
	POP	H	;GET THE LOCATION
	PUSH	H	;SAVE IT AGAIN
	INX	H	;GET MANTISSA LOCATION
	INX	H
	LXI	B,WORK2+4D	 ;GET RESULT ADDRESS
	MVI	A,4	;GET NUMBER OF BYTES
	XCHG		;GET REGISTERS IN THE RIGHT PLACE
	CALL	FXAD	;ADD THE MANTISSAS
	POP	H	;GET ADDRESS OF REFERENCE NUMBER
	PUSH	H	;SAVE REFERENCE LOCATION
	PUSH	PSW	;SAVE ANY SIGN CHANGE
	LDA	TEMP2	;CHANGE SIGN OF TEMP2
	XRI	80H
	STA	TEMP2
	XRA	A	;CLEAR ERROR FLAG
	STA	MERR
	LXI	D,WORK2	;GET ADDRESS OF WORKING REGISTER
	CALL	NORM	;NORMALIZE RESULT
	POP	PSW	;GET ADDRESS FOR RESULT
	POP	H	;GET ANY SIGN CHANGE
	XRA	M	;CHANGE SIGN IF NEEDED
	POP	H	;CLEAN UP THE STACK
	PUSH	PSW	;SAVE SIGNS BYTE
	MOV	A,B	;GET THE EXPONENT SIGN
	ANI	40H	;STRIP OFF THE SIGN BIT
	MOV	B,A	;BACK TO B
	POP	PSW	;GET SIGNS BYTE BACK
	ANI	0BFH	;CLEAR THE SIGN BIT
	ORA	B	;SET THE REAL SIGN BIT IN
	MOV	M,A	;STORE SIGNS BYTE
	INX	H	;UPDATE INDEX
	MOV	M,C	;STORE EXPONENT
	XCHG		;SWAP ADDRESSES FOR MANTISSA MOVE
	INX	D	;GET RIGHT ADDRESS
	LXI	B,4	;NUMBER OF BYTES
	CALL	MVDN	;MOVE IT
	RET
*
FPAS7	LXI	D,TEMP2
	CALL	CMP16
	JNZ	FPAS7A
	PUSH	H
	INX	H
	INX	H
	MVI	C,4
	CALL	CMPL
	POP	H
FPAS7A	POP	D	;GET DESTINATION
	LXI	B,6	;GET NUMBER OF BYTES
	CALL	MVDN	;MOVE IT
	RET
*
* MULTIPLICATION TABLE.
* NOTE THAT SOME CONSTANTS ARE SANDWICHED
* IN BETWEEN TABLE ENTRIES, WHICH START
* EVERY 16 BYTES, AND ARE 10 BYTES LONG.
*
MTBLE	DB	0,1,2,3,4,5,6,7,8,9
ZERO0	DB	2,0,0,0,0,0	;CONSTANT ZERO.
	DB	0,2,4,6,8,10H,12H,14H,16H,18H
ONE11	DB	3,0,10H,0,0,0	;CONSTANT ONE.
	DB	0,3,6,9,12H,15H,18H,21H,24H,27H
TWO22	DB	3,0,20H,0,0,0	;CONSTANT TWO.
	DB	0,4,8,12H,16H,20H,24H,28H,32H,36H
CONS1	DB	3,0,16H,90H,0,0	;CONSTANT 1.69.
	DB	0,5,10H,15H,20H,25H,30H,35H,40H,45H
CONS2	DB	3,0,15H,70H,79H,63H	;CONSTANT PI/2.
	DB	0,6,12H,18H,24H,30H,36H,42H,48H,54H
CONS3	DB	2,0,0,6,55H,36H	;CONSTANT 65536.
	DB	0,7,14H,21H,28H,35H,42H,49H,56H,63H
CON99	DB	43H,1,99H,99H,99H,50H
	DB	0,8,16H,24H,32H,40H,48H,56H,64H,72H
HNDRD	DB	2,0,0,0,1,0	;CONSTANT ONE HUNDRED.
	DB	0,9,18H,27H,36H,45H,54H,63H,72H,81H
*
* RTN. B.10
* MULTIPLY TWO BCD DIGITS BY TWO DIGITS, FOUR DIGIT
* PRODUCT. B * C = BC
*
MUL2	INR	B	;CHECK FOR B = 0
	DCR	B
	JZ	MUL20	;YUP, SO CLEAR BC AND RETURN
	INR	C	;CHECK FOR C = 0
	DCR	C	
	JZ	MUL20	;YUP, SO CLEAR BC AND RETURN
	PUSH	D	;SAVE DE,HL
	PUSH	H
	LXI	D,0	;CLEAR PRODUCT REGISTERS
	MOV	A,C	;GET A DIGIT
	ANI	0FH
	JZ	MUL21	;NO MULTIPLY NEEDED
	MOV	L,A	;SAVE IT
	MOV	A,B	;GET ANOTHER DIGIT
	ANI	0F0H
	JZ	MUL21	;NO MULTIPLY NEEDED
	ADD	L	;GENERATE TABLE ADDRESS
	LXI	H,MTBLE-10H
	ADD	L
	JNC	MUL25
	INR	H
MUL25	MOV	L,A
	MOV	E,M	;GET PRODUCT TO E
MUL21	MOV	A,B	;GET A DIGIT
	ANI	0FH
	JZ	MUL22	;NO MULTIPLY NEEDED
	MOV	L,A
	MOV	A,C	;GET ANOTHER ONE
	ANI	0F0H
	JZ	MUL22	;NO MULTIPLY NEEDED
	ADD	L	;GENERATE TABLE ADDRESS
	LXI	H,MTBLE-10H
	ADD	L
	JNC	MUL28
	INR	H
MUL28	MOV	L,A
	MOV	A,M	;GET PRODUCT TO A
	ADD	E	;ADD TO PRODUCT REGISTER
	DAA		;BCD ADJUST
	MOV	E,A	;STUFF IT IN
	JNC	MUL22	;NO CARRY PROPAGATE
	INR	D	;CARRY
MUL22	XCHG		;SET UP TO SHIFT PRODUCT REGISTER ONE DIGIT
	DAD	H	;SHIFT LEFT FOUR PLACES
	DAD	H
	DAD	H
	DAD	H
	XCHG		;PUT IT BACK
	MOV	A,C	;GET A DIGIT
	ANI	0FH
	JZ	MUL23	;NO MULTIPLY NEEDED
	MOV	L,A
	MOV	A,B	;GET ANOTHER DIGIT
	ANI	0FH
	JZ	MUL23	;NO MULTIPLY NEEDED
	RLC		;SHIFT LEFT 4
	RLC	
	RLC
	RLC
	ADD	L	;GENERATE TABLE ADDRESS
	LXI	H,MTBLE-10H
	ADD	L
	JNC	MUL26
	INR	H
MUL26	MOV	L,A
	MOV	A,M	;GET PARTIAL PRODUCT
	ADD	E	;ADD IT TO PRODUCT REGISTER
	DAA
	MOV	E,A	;PUT RESULT IN
	JNC	MUL23	;NO CARRY
	INR	D	;PROPAGATE CARRY
MUL23	MOV	A,B	;GET A DIGIT
	ANI	0F0H
	JZ	MUL24	;NO MULTIPLY NEEDED
	MOV	L,A	;SAVE IT
	MOV	A,C	;GET ANOTHER DIGIT
	ANI	0F0H
	JZ	MUL24	;NO MULTIPLY NEEDED
	RLC!RLC!RLC!RLC	;LEFT SHIFT 4
	ADD	L	;GENERATE TABLE ADDRESS
	LXI	H,MTBLE-10H
	ADD	L
	JNC	MUL27
	INR	H
MUL27	MOV	L,A
	XRA	A	;CLEAR CARRY
	MOV	A,D	;GET PRODUCT REGISTER
	DAA		;ADJUST FOR ANY PREVIOUS CARRYS
	ADD	M	;ADD NEW PRODUCT
	DAA		;BCD ADJUST
	MOV	D,A	;STUFF IT BACK
MUL24	XRA	A	;CLEAR CARRYS
	MOV	A,D	;ADJUST D IN CASE OF PREVIOUS CARRYS
	DAA
	MOV	B,A	;PUT IT IN B
	MOV	C,E	;MOVE E TO C
	POP	H	;RESTORE REGISTERS
	POP	D
	RET		;DONE!!!
*
MUL20	LXI	B,0	;CLEAR BC
	RET		;FAST EXIT
*
LINK04	LINK	A:TBASIC5
