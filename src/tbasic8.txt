*
*
* TARBELL BASIC SOURCE MODULE #8
* COPYRIGHT (C) 1978, 1979 TARBELL ELECTRONICS
* LAST CHANGE MADE ON THIS MODULE 1-23-79.
*
* RTN. M.1
* EDIT COMMAND EXECUTIVE
EDIT	LHLD	FSRC	;INITILIZE EDITED LINE POINTER
	SHLD	EDLNP
	CALL	GLFC	;LOOK FOR PARAMETER
	JC	SPRAT	;NO PARAMETER
	XRA	A	;SET COMMAND MODE
	STA	CMND
	XCHG		;OFFSET TO HL
	SHLD	EDITO	;SAVE IT
	MOV	H,B	;BC TO HL
	MOV	L,C
	SHLD	EDITS	;SAVE THE SYMBOL NUMBER
EDITJ	LHLD	EDITS	;GET THE SYMBOL NUMBER
	MOV	C,L	;TO BC
	MOV	B,H
	LHLD	EDITO	;GET THE OFFSET
	XCHG		;TO DE
	CALL	LILO	;FIND THE LINE
	SHLD	EDLNP	;GET THE POINTER
EDITA	LHLD	SDIR
	LXI	D,300
	CALL	SUB16	;FIND PLACE TO PUT ALL THIS STUFF
	MVI	M,80H	;STORE FAKEOUT FLAGS
	INX	H
	MVI	M,80H
	INX	H
	SHLD	DMPMM	;STORE DUMP TO MEMORY FLAG
	LHLD	EDLNP	;EDITED LINE POINTER
	CALL	DMST	;DUMP THE STATEMENT OUT
	LHLD	DMPMM	;SET THE LAST BIT
	DCX	H
	MOV	A,M
	ORI	80H
	MOV	M,A
	LXI	H,0	;CLEAR THE DUMP MEMORY FLAG
	SHLD	DMPMM
EDITH	LHLD	SDIR	;SET EDITING FLAGS
	LXI	D,298
	CALL	SUB16	;COMPUTE PLACE OF STRING
	SHLD	LLST
	SHLD	FLST
	SHLD	TMP9
EDITD	LXI	H,0	;INPUT A COMMAND
	XRA	A	;CLEAR NEW LINE FLAG
	STA	NWFLG
	SHLD	TMP1	;N=0
EDITB	CALL	KYIN	;GET A CHARACTER
	CPI	7FH	;IS IT A RUBOUT??
	JZ	EDITD	;YUP, SO START OVER ON THE COMMAND
	CPI	3AH	;IS IT A DIGIT
	JNC	EDITC	;NOPE
	CPI	30H	;CHECK AGAIN
	JC	EDITC	;FOR SURE
	ANI	0FH	;STRIP OF ASCII BITS
	MVI	B,10	;MULTIPLY TMP1 BY TEN
	LHLD	TMP1	;GET OLD N
	XCHG		;TO DE
	LXI	H,0	;CLEAR HL
EDITZ	DAD	D	;ADD
	DCR	B	;CHECK FOR DONENESS
	JNZ	EDITZ
	CALL	ADHL	;ADD THE NEW DIGIT
	SHLD	TMP1	;STORE IT
	JMP	EDITB	;GET ANOTHER ONE
EDITC	LXI	B,19	;NUMBER OF COMMAND TYPES
	LXI	H,EDITY	;COMMAND TABLE
	CALL	SRC8	;SEARCH FOR THE COMMAND
	JNZ	EDITE	;NOT A COMMAND, ROCK!
	PUSH	B	;SAVE COMMAND NUMBER
	LHLD	TMP1	;CHECK FOR N=0
	MOV	A,H
	ORA	L
	JNZ	EDITX	;NOPE
	INX	H
EDITX	SHLD	TMP1	;OK
	LHLD	ESRC	;GET PLACE TO STORE PARAMETER STRING
	MVI	M,80H	;STORE THE FAKEOUT FLAGS
	INX	H
	MVI	M,80H
	MOV	A,C	;CHECK COMMAND NUMBER OUT
	CPI	3
	JZ	EDITG
	CPI	4
	JZ	EDITG
	CPI	5
	JZ	EDITG
	CPI	12
	JNZ	EDI45
EDITG	PUSH	H	;SAVE ADDRESS
	CALL	KYIN	;GET A CHARACTER
	POP	H	;GET ADDRESS BACK
	CPI	7FH	;IS IT A RUBOUT?
	POP	B	;RESTORE STACK
	JZ	EDITD	;YUP, SO START OVER AGAIN
	PUSH	B	;BACK DOWN, BOY!
	CPI	0DH	;IS IT A CARRIAGE RETURN?
	JZ	EDITF	;YUP, SO COMMAND IS FINISHED
	MOV	M,A	;NO, SO STORE THE CHARACTER
	INX	H	;UPDATE THE INDEX
	JMP	EDITG	;GO GET ANOTHER ONE
EDITF	DCX	H	;SET UPPER BIT ON LAST CHARACTER
	MOV	A,M
	ORI	80H
	MOV	M,A
EDI45	POP	B	;GET BACK COMMAND NUMBER
	LXI	H,EDITW-2	;COMMAND ADDRESS TABLE
	DAD	B	;ADD OFFSET
	DAD	B
	MOV	E,M	;GET THE ADDRESS OUT
	INX	H	
	MOV	D,M
	XCHG		;TO HL
	LXI	D,EDITD	;SET UP RETURN ADDRESS
	PUSH	D
	PCHL		;GOTO PROCESSOR
EDITE	MVI	A,'?'	;PRINT A QUESTION MARK
	CALL	TOUT	;TO INDICATE AN ILLEGAL COMMAND
	CALL	PSSU	;PRINT LINE UNTIL POINTER
	JMP	EDITD	;GET ANOTHER COMMAND
EDITY	DB	'U'
	DB	'D'
	DB	'I'
	DB	'C'
	DB	'S'
	DB	'Q'
	DB	'R'
	DB	'K'
	DB	'F'
	DB	'B'
	DB	'A'
	DB	'M'
	DB	'L'
	DB	'T'
	DB	20H
	DB	'X'
	DB	'P'
	DB	'N'
	DB	'W'
EDITW	DW	PSSU
	DW	PSSD
	DW	PSSI
	DW	PSSC
	DW	PSSS
	DW	PSSQ
	DW	PSSR
	DW	PSSK
	DW	PSSF
	DW	PSSB
	DW	PSSA
	DW	PSSM
	DW	PSSL
	DW	PSST
	DW	PSSZ
	DW	PSSX
	DW	PSSP
	DW	PSSN
	DW	PSSW
EDIT1	PUSH	PSW	;SAVE REGISTERS
	PUSH	H
	LHLD	DMPMM	;GET INDEX
	PUSH	PSW
	MOV	A,H	;SEE IF IT'S ZERO
	ORA	L
	JZ	EDXT11	;SURE IS
	POP	PSW
	CPI	0DH	;CHECK FOR CARRIAGE RETURN
	JZ	EDOT12	;SURE WAS, SO IGNORE IT
	MOV	M,A	;STORE THE CHARACTER
	INX	H	;UPDATE THE INDEX
	SHLD	DMPMM	;SAVE IT
EDOT12	POP	H	;RESTORE REGISTERS
	POP	PSW
	RET		;DONE
EDXT11	POP	PSW
	JMP	EDOT12
EDIT4	MOV	A,D	;DE = 0
	ORA	E
	RZ		;YUP, SO WE ARE DONE
	PUSH	H	;SAVE INDEXES
	PUSH	D
	MOV	A,M	;GET A CHARACTER
	ANI	7FH	;STRIP ANY STROBE
	CALL	TOUT	;PRINT IT
	POP	D	;RESTORE INDEXES
	POP	H
	INX	H	;UPDATE
	DCX	D
	JMP	EDIT4	;TRY AGAIN
EDIT5	LHLD	TMP1
	DCX	H
	SHLD	TMP1
	MOV	A,H
	ORA	L
	RET
EDIT6	LHLD	FLST
	CALL	COUNT	;CHECK FOR POINTER OVERFLOW
	DAD	D
	XCHG
	LHLD	LLST
	CALL	CMP16	;CHECK IT OUT
	RC		;IT'S OKAY
	XCHG		;FIX IT
	DCX	H
	SHLD	LLST
	RET		;DONE.
PSSK	LHLD	FLST	;GET FIRST CHARACTER POSITION
	MVI	M,0A0H	;STORE A SPACE, END
	SHLD	LLST	;POINTER SET
	JMP	PSSI1	;INSERT MODE
PSSU	MVI	A,0DH	;PRINT A CARRIAGE RETURN
	CALL	TOUT	;SEND IT
	LHLD	FLST	;COMPUTE NUMBER OF CHARACTERS TO SEND
	XCHG
	LHLD	LLST
	CALL	SUB16
	XCHG		;RESULT TO DE
	LHLD	FLST	;GET FIRST CHARACTER TO DUMP
	CALL	EDIT4	;DUMP 'EM
	RET		;DONE
PSSD	MVI	A,5CH	;DUMP A BACKSLASH
	CALL	TOUT
PSSD4	LHLD	LLST	;COUNT REMAINING CHARACTERS
	CALL	EDIT6	;CHECK FOR OVERRUN OF POINTER
	CALL	COUNT
	LXI	H,1	;IS IT ONE?
	CALL	CMP16
	JZ	PSSD1	;YUP
	LHLD	LLST	;GET CHARACTER TO DELETE
	PUSH	D	;SAVE COUNT
	PUSH	H	;SAVE ADDRESS
	MOV	A,M	;GET THE CHARACTER
	CALL	TOUT	;DUMP IT
	POP	D	;GET BACK THE ADDRESS
	POP	B	;GET BACK THE COUNT
	DCX	B	;CORRECT
	MOV	L,E	;ADDRESS TO HL
	MOV	H,D
	INX	H	;GET ADDRESS PLUS ONE
	MOV	A,C	;CHECK FOR COUNT OF 0
	ORA	B
	JZ	PSSD2+6	;SURE IS
	CALL	MOVE	;MOVE 'EM DOWN
PSSD2	CALL	EDIT5	;DECREMENT N
	JNZ	PSSD4	;DO IT AGAIN
	MVI	A,5CH	;DUMP ANOTHER BACKSLASH
	CALL	TOUT
	RET		;ALL DONE
PSSD1	LHLD	LLST	;POINTER = FIRST CHARACTER?
	XCHG		;TO DE
	LHLD	FLST
	CALL	CMP16	;CHECK THEM
	JZ	PSSD3	;SURE WERE THE SAME
	XCHG		;LLST TO HL
	MOV	C,M	;CHARACTER TO C
	DCX	H	;SET NEW LAST CHARACTER
	MOV	A,M
	ORI	80H
	MOV	M,A
	INX	H
	SHLD	LLST	;NEW POINTER
	MOV	A,C	;GET THE CHARACTER
	ANI	7FH	;STRIP THE STROBE
	CALL	TOUT	;PRINT IT
	JMP	PSSD2	;CONTINUE
PSSD3	XCHG		;LLST TO HL
	MOV	A,M	;CHECK THE CHARACTER THERE
	CPI	80H
	JZ	PSSD2	;NONE LEFT!
	MVI	M,80H	;SET AN 80 IN
	ANI	7FH	;STRIP ANY STROBE
	CALL	TOUT	;PRINT IT
	JMP	PSSD2	;CONTINUE
PSSS	LHLD	LLST	;SET SEARCH FLAG UP
	SHLD	TMP2
	CALL	EDIT6	;CHECK FOR POINTER OVERRUN
	LHLD	ESRC	;CHECK FOR ANY INPUT
	INX	H
	MOV	A,M
	CPI	80H
	RZ		;NO INPUT, SO NO SEARCH
PSSS4	LHLD	ESRC	;INITIALIZE INDEXES
	XCHG		;TO DE
	INX	D	;CORRECT TO GET PAST FAKEOUT
	LHLD	TMP2
PSSS3	MOV	A,M	;GET A CHARACTER
	ANI	7FH	;STRIP STROBE OFF
	MOV	B,A	;TO B
	LDAX	D	;GET A CHARACTER
	ANI	7FH	;STRIP THE STROBE
	CMP	B	;THE SAME?
	JNZ	PSSS1	;NOPE
	LDAX	D	;CHECK FOR END OF SEARCH STRING
	ANA	A
	JM	PSSS2	;SURE IS, SO WE'VE GOT A FIND
	MOV	A,M	;CHECK FOR END STRUCK
	ANA	A
	JM	PSSS1	;SURE DID
	INX	D	;UPDATE INDEXES
	INX	H
	JMP	PSSS3	;TRY ANOTHER CHARACTER
PSSS1	LHLD	TMP2	;UPDATE INPUT STRING TRY POSITION
	PUSH	H	;SAVE ADDRESS
	MOV	A,M	;GET A BYTE
	CALL	TOUT	;PRINT IT
	POP	H	;RESTORE ADDRESS
	MOV	A,M	;CHECK FOR END
	ANA	A
	JM	PSSS5	;SURE IS
	INX	H
	SHLD	TMP2
	JMP	PSSS4	;TRY AGAIN!
PSSS2	CALL	EDIT5	;DECREMENT N
	JNZ	PSSS1	;MORE TO GO
	LHLD	TMP2	;SET POINTER
	SHLD	LLST
	RET		;DONE.
PSSI	CALL	PSSS	;PERFORM SEARCH FIRST
PSSI1	CALL	KYIN	;GET A CHARACTER
	CPI	0DH	;IS IT A CARRIAGE RETURN
	JZ	PSSID	;DONE
	CPI	7FH	;IS IT A RUBOUT
	JZ	PSSI2	;SURE WAS
	PUSH	PSW	;SAVE THE CHARACTER
	CALL	EDIT6	;CHECK FOR POINTER OVERRUN
	JC	PSSI9	;NOPE
	MOV	A,M	;GET LAST CHARACTER
	ANI	7FH	;STRIP THE STROBE
	MOV	M,A
	INX	H	;SET IN THE FAKEOUT
	MVI	M,80H
	SHLD	LLST
PSSI9	LHLD	LLST	;COUNT CHARACTERS REMAINING
	CALL	COUNT
	MOV	C,E
	MOV	B,D
	MOV	E,L
	MOV	D,H
	INX	D
	CALL	MOVE
	XCHG		;FIND THE LAST CHARACTER
	DAD	B
	DCX	H
	MOV	A,M	;GET IT
	CPI	80H	;IS IT A FAKEOUT?
	JNZ	PSSI7	;NOPE
	DCX	H	;SURE WAS
	MOV	A,M	;SET UPPER BIT
	ORI	80H
	MOV	M,A
PSSI7	XCHG		;HL BACK TO NORMAL
	POP	PSW	;RESTORE CHARACTER
	MOV	M,A	;STUFF IT IN
	CALL	TOUT	;ECHO IT
	LHLD	LLST	;UPDATE THE POINTER
	INX	H
	SHLD	LLST
	JMP	PSSI1
PSSI2	LXI	H,1	;SET UP N
	SHLD	TMP1
	LHLD	LLST	;FIX THE POINTER
	DCX	H	;BACK UP
	SHLD	LLST
	MOV	A,M	;CHECK FOR A FAKEOUT
	CPI	80H
	JNZ	PSSI8	;NOPE
	DCX	H
	SHLD	LLST
	MOV	A,M
	ORI	80H	;SET END UP
	MOV	M,A
PSSI8	CALL	PSSD	;KILL ONE
	JMP	PSSI1	;CONTINUE
PSSC	CALL	PSSS	;FIND THE STRING
	LHLD	ESRC	;FIND OUT HOW MANY CHARACTERS
	INX	H
	CALL	COUNT	;COUNT 'EM
	XCHG
	SHLD	TMP1	;SAVE AS N
	CALL	PSSD	;DELETE THAT MANY
	JMP	PSSI1	;GO TO INSERT MODE
PSSQ	MVI	A,0FFH	;SET COMMAND MODE
	STA	CMND
	JMP	RSTRT	;BACK TO COMMAND LEVEL
PSSW	MVI	A,0FFH	;SET EDIT MODE FLAG
	STA	EDITM
	LHLD	EDLNP	;GET CURRENT INSERTION ADDRESS
	SHLD	LINE	;BACK UP
	CALL	MBOS
	LHLD	LINE
	SHLD	INSR	;SET UP FOR CORRECT DELETION
EDIT2	LHLD	INSR	;SET UP FOR DELETION
	SHLD	FLST
	SHLD	LINE	;SET UP LINE FLAG
	SHLD	LLST
	LDA	NWFLG	;CHECK FOR NEW STATEMENT
	ANA	A
	JNZ	CLER	;SURE WAS, SO NO DELETION
	JMP	DLTE1	;DELETE IT
PSSN	MVI	A,0FFH	;SET NEW LINE FLAG
	STA	NWFLG
PSSR	LHLD	FLST	;STORE A BLANK AT THE END
	CALL	COUNT
	DAD	D
	MVI	M,0
	LHLD	FRAV	;SET UP CODED LINE START
	MVI	A,0FFH	;SET UP EDIT MODE
	STA	EDITM
	SHLD	SLIN
	CALL	CRLF	;DO A CARRIAGE RETURN
	LHLD	EDLNP	;SET UP INSERTION POINT
	SHLD	INSR
	XRA	A	;CLEAR ESCN
	STA	ESCN
	LHLD	TMP9	;SET UP FOR LINE DECODING
	DCX	H
	JMP	EXE77	;DECODE AND ENTER THE LINE
PSSP	MVI	A,0DH	;PRINT A CR
	CALL	TOUT
	LHLD	FLST	;START OF LINE
	CALL	MSGER	;PRINT IT
	MVI	A,0DH	;PRINT A CR
	CALL	TOUT
	LHLD	FLST	;RESET POINTER
	SHLD	LLST
	RET		;DONE.
PSSF	LHLD	TMP1	;GET N
	XCHG		;TO DE
	LHLD	EDITO	;GET OFFSET
	DAD	D	;ADD IT UP
	SHLD	EDITO	;SAVE NEW OFFSET
	POP	H	;CLEAN UP THE STACK
	XRA	A	;CLEAR EDIT MODE
	STA	EDITM
	JMP	EDITJ	;NEW LINE
PSSB	LHLD	TMP1	;GET N
	XCHG		;TO DE
	LHLD	EDITO	;GET OFFSET
	CALL	SUB16	;BACK UP
	SHLD	EDITO	;SAVE NEW OFFSET
	POP	H	;CLEAN UP THE STACK
	JMP	EDITJ	;NEW LINE
PSSA	CALL	EDIT6	;GET POINTER
	CALL	MSGER	;SEND IT OUT
	LHLD	FLST	;FIND END OF LINE
	CALL	COUNT
	DAD	D
	INX	H	;CORRECT
	SHLD	LLST	;SET POINTER
	CALL	PSSI1	;INSERT AT END
	RET		;DONE
PSSM	LHLD	ESRC	;SET UP SCAN FLAGS
	SHLD	NSCN
	XRA	A
	STA	ESCN
	CALL	USCN	;SCAN OFF FAKEOUT
	POP	H	;CLEAN UP THE STACK
	JMP	EDIT	;MOVE TO THE NEW LINE
PSSL	MVI	A,0DH	;DUMP A CR
	CALL	TOUT
PSSL1	CALL	EDIT5	;DECREMENT N
	JZ	PSSL2	;ALL DONE
	LHLD	EDLNP	;DUMP STATEMENT AT POINTER
	CALL	DMST
	LHLD	EDITO	;GET OFFSET
	INX	H	;INCREMENT IT
	SHLD	EDITO
	XCHG		;TO DE
	LHLD	EDITS	;GET SYMBOL NUMBER
	MOV	C,L	;TO BC
	MOV	B,H
	CALL	LILO	;FIND THE LINE
	SHLD	EDLNP
	XCHG
	LHLD	ESRC	;SEE IF WE ARE DONE
	XCHG
	CALL	CMP16
	JNC	PSSL2	;DONE (END OF SOURCE)
	JMP	PSSL1	;GET ANOTHER LINE
PSSL2	POP	H	;CLEAN UP THE STACK
	JMP	EDITA	;INTO EDIT MODE
PSST	CALL	EDIT6	;CHECK FOR OVERRUN
	CALL	MSGER	;PRINT IT
	JMP	PSSU	;PRINT UP TO POINTER
PSSZ	CALL	EDIT6	;GET POINTER
	MOV	A,M	;GET THE CHARACTER
	ANI	7FH	;STRIP UPPER BIT
	INX	H	;INCREMENT POINTER
	SHLD	LLST
	CALL	TOUT	;DUMP THE CHARACTER
	CALL	EDIT5	;CHECK FOR DONENESS
	JNZ	PSSZ	;NOPE
	RET		;DONE
PSSX	CALL	EDIT6	;CHECK FOR OVERRUN
	XCHG		;TO DE
	LHLD	FLST	;CHECK FOR NO BACKUP
	CALL	CMP16
	RZ		;DAT'S RIGHT FOLKS
	DCX	D
	XCHG		;GET LAST CHARACTER
	MOV	A,M
	SHLD	LLST	;NEW POINTER
	CALL	TOUT	;PRINT IT
	CALL	EDIT5	;CHECK FOR DONENESS
	JNZ	PSSX
	RET		;ALL DONE
PSSS5	MVI	A,'?'	;PRINT A QUESTION MARK
	CALL	TOUT
	CALL	PSSP	;PRINT THE LINE
	POP	H	;CLEAN UP THE STACK
	JMP	EDITH	;TRY AGAIN
PSSID	LHLD	LLST	;CHECK FOR 80 AT END
	MOV	A,M
	CPI	80H
	RNZ		;NOPE, SO ALL'S WELL
	DCX	H	;STRIP IT
	MOV	A,M
	ORI	80H
	MOV	M,A
	RET		;DONE.
EDI96	JMP	RSTRT	;DONE
*
LINK08	LINK	A:TBASIC9
